// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public static partial class Netmessages {

  #region Extension registration
  public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
  }
  #endregion
  #region Static variables
  internal static pbd::MessageDescriptor internal__static_CMsgVector__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CMsgVector, global::CMsgVector.Builder> internal__static_CMsgVector__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CMsgVector2D__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CMsgVector2D, global::CMsgVector2D.Builder> internal__static_CMsgVector2D__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CMsgQAngle__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CMsgQAngle, global::CMsgQAngle.Builder> internal__static_CMsgQAngle__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CMsgRGBA__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CMsgRGBA, global::CMsgRGBA.Builder> internal__static_CMsgRGBA__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CNETMsg_Tick__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CNETMsg_Tick, global::CNETMsg_Tick.Builder> internal__static_CNETMsg_Tick__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CNETMsg_StringCmd__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CNETMsg_StringCmd, global::CNETMsg_StringCmd.Builder> internal__static_CNETMsg_StringCmd__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CNETMsg_SignonState__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CNETMsg_SignonState, global::CNETMsg_SignonState.Builder> internal__static_CNETMsg_SignonState__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CMsg_CVars__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CMsg_CVars, global::CMsg_CVars.Builder> internal__static_CMsg_CVars__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CMsg_CVars_CVar__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CMsg_CVars.Types.CVar, global::CMsg_CVars.Types.CVar.Builder> internal__static_CMsg_CVars_CVar__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CNETMsg_SetConVar__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CNETMsg_SetConVar, global::CNETMsg_SetConVar.Builder> internal__static_CNETMsg_SetConVar__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CNETMsg_NOP__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CNETMsg_NOP, global::CNETMsg_NOP.Builder> internal__static_CNETMsg_NOP__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CNETMsg_Disconnect__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CNETMsg_Disconnect, global::CNETMsg_Disconnect.Builder> internal__static_CNETMsg_Disconnect__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CNETMsg_File__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CNETMsg_File, global::CNETMsg_File.Builder> internal__static_CNETMsg_File__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CNETMsg_SplitScreenUser__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CNETMsg_SplitScreenUser, global::CNETMsg_SplitScreenUser.Builder> internal__static_CNETMsg_SplitScreenUser__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CCLCMsg_ClientInfo__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_ClientInfo, global::CCLCMsg_ClientInfo.Builder> internal__static_CCLCMsg_ClientInfo__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CCLCMsg_Move__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_Move, global::CCLCMsg_Move.Builder> internal__static_CCLCMsg_Move__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CCLCMsg_VoiceData__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_VoiceData, global::CCLCMsg_VoiceData.Builder> internal__static_CCLCMsg_VoiceData__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CCLCMsg_BaselineAck__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_BaselineAck, global::CCLCMsg_BaselineAck.Builder> internal__static_CCLCMsg_BaselineAck__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CCLCMsg_ListenEvents__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_ListenEvents, global::CCLCMsg_ListenEvents.Builder> internal__static_CCLCMsg_ListenEvents__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CCLCMsg_RespondCvarValue__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_RespondCvarValue, global::CCLCMsg_RespondCvarValue.Builder> internal__static_CCLCMsg_RespondCvarValue__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CCLCMsg_FileCRCCheck__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_FileCRCCheck, global::CCLCMsg_FileCRCCheck.Builder> internal__static_CCLCMsg_FileCRCCheck__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CCLCMsg_LoadingProgress__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_LoadingProgress, global::CCLCMsg_LoadingProgress.Builder> internal__static_CCLCMsg_LoadingProgress__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CCLCMsg_SplitPlayerConnect__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_SplitPlayerConnect, global::CCLCMsg_SplitPlayerConnect.Builder> internal__static_CCLCMsg_SplitPlayerConnect__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CCLCMsg_CmdKeyValues__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_CmdKeyValues, global::CCLCMsg_CmdKeyValues.Builder> internal__static_CCLCMsg_CmdKeyValues__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_ServerInfo__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_ServerInfo, global::CSVCMsg_ServerInfo.Builder> internal__static_CSVCMsg_ServerInfo__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_ClassInfo__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_ClassInfo, global::CSVCMsg_ClassInfo.Builder> internal__static_CSVCMsg_ClassInfo__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_ClassInfo_class_t__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_ClassInfo.Types.class_t, global::CSVCMsg_ClassInfo.Types.class_t.Builder> internal__static_CSVCMsg_ClassInfo_class_t__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_SendTable__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_SendTable, global::CSVCMsg_SendTable.Builder> internal__static_CSVCMsg_SendTable__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_SendTable_sendprop_t__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_SendTable.Types.sendprop_t, global::CSVCMsg_SendTable.Types.sendprop_t.Builder> internal__static_CSVCMsg_SendTable_sendprop_t__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_Print__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_Print, global::CSVCMsg_Print.Builder> internal__static_CSVCMsg_Print__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_SetPause__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_SetPause, global::CSVCMsg_SetPause.Builder> internal__static_CSVCMsg_SetPause__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_SetView__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_SetView, global::CSVCMsg_SetView.Builder> internal__static_CSVCMsg_SetView__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_CreateStringTable__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_CreateStringTable, global::CSVCMsg_CreateStringTable.Builder> internal__static_CSVCMsg_CreateStringTable__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_UpdateStringTable__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_UpdateStringTable, global::CSVCMsg_UpdateStringTable.Builder> internal__static_CSVCMsg_UpdateStringTable__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_VoiceInit__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_VoiceInit, global::CSVCMsg_VoiceInit.Builder> internal__static_CSVCMsg_VoiceInit__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_VoiceData__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_VoiceData, global::CSVCMsg_VoiceData.Builder> internal__static_CSVCMsg_VoiceData__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_FixAngle__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_FixAngle, global::CSVCMsg_FixAngle.Builder> internal__static_CSVCMsg_FixAngle__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_CrosshairAngle__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_CrosshairAngle, global::CSVCMsg_CrosshairAngle.Builder> internal__static_CSVCMsg_CrosshairAngle__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_Prefetch__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_Prefetch, global::CSVCMsg_Prefetch.Builder> internal__static_CSVCMsg_Prefetch__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_BSPDecal__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_BSPDecal, global::CSVCMsg_BSPDecal.Builder> internal__static_CSVCMsg_BSPDecal__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_SplitScreen__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_SplitScreen, global::CSVCMsg_SplitScreen.Builder> internal__static_CSVCMsg_SplitScreen__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_GetCvarValue__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GetCvarValue, global::CSVCMsg_GetCvarValue.Builder> internal__static_CSVCMsg_GetCvarValue__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_Menu__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_Menu, global::CSVCMsg_Menu.Builder> internal__static_CSVCMsg_Menu__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_UserMessage__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_UserMessage, global::CSVCMsg_UserMessage.Builder> internal__static_CSVCMsg_UserMessage__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_PaintmapData__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_PaintmapData, global::CSVCMsg_PaintmapData.Builder> internal__static_CSVCMsg_PaintmapData__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_GameEvent__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GameEvent, global::CSVCMsg_GameEvent.Builder> internal__static_CSVCMsg_GameEvent__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_GameEvent_key_t__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GameEvent.Types.key_t, global::CSVCMsg_GameEvent.Types.key_t.Builder> internal__static_CSVCMsg_GameEvent_key_t__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_GameEventList__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GameEventList, global::CSVCMsg_GameEventList.Builder> internal__static_CSVCMsg_GameEventList__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_GameEventList_key_t__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GameEventList.Types.key_t, global::CSVCMsg_GameEventList.Types.key_t.Builder> internal__static_CSVCMsg_GameEventList_key_t__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_GameEventList_descriptor_t__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GameEventList.Types.descriptor_t, global::CSVCMsg_GameEventList.Types.descriptor_t.Builder> internal__static_CSVCMsg_GameEventList_descriptor_t__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_TempEntities__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_TempEntities, global::CSVCMsg_TempEntities.Builder> internal__static_CSVCMsg_TempEntities__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_PacketEntities__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_PacketEntities, global::CSVCMsg_PacketEntities.Builder> internal__static_CSVCMsg_PacketEntities__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_Sounds__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_Sounds, global::CSVCMsg_Sounds.Builder> internal__static_CSVCMsg_Sounds__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_Sounds_sounddata_t__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_Sounds.Types.sounddata_t, global::CSVCMsg_Sounds.Types.sounddata_t.Builder> internal__static_CSVCMsg_Sounds_sounddata_t__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_EntityMsg__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_EntityMsg, global::CSVCMsg_EntityMsg.Builder> internal__static_CSVCMsg_EntityMsg__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_CmdKeyValues__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_CmdKeyValues, global::CSVCMsg_CmdKeyValues.Builder> internal__static_CSVCMsg_CmdKeyValues__FieldAccessorTable;
  internal static pbd::MessageDescriptor internal__static_CSVCMsg_EncryptedData__Descriptor;
  internal static pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_EncryptedData, global::CSVCMsg_EncryptedData.Builder> internal__static_CSVCMsg_EncryptedData__FieldAccessorTable;
  #endregion
  #region Descriptor
  public static pbd::FileDescriptor Descriptor {
    get { return descriptor; }
  }
  private static pbd::FileDescriptor descriptor;
  
  static Netmessages() {
    byte[] descriptorData = global::System.Convert.FromBase64String(
        "ChFuZXRtZXNzYWdlcy5wcm90bxogZ29vZ2xlL3Byb3RvYnVmL2Rlc2NyaXB0" + 
        "b3IucHJvdG8iLQoKQ01zZ1ZlY3RvchIJCgF4GAEgASgCEgkKAXkYAiABKAIS" + 
        "CQoBehgDIAEoAiIkCgxDTXNnVmVjdG9yMkQSCQoBeBgBIAEoAhIJCgF5GAIg" + 
        "ASgCIi0KCkNNc2dRQW5nbGUSCQoBeBgBIAEoAhIJCgF5GAIgASgCEgkKAXoY" + 
        "AyABKAIiNgoIQ01zZ1JHQkESCQoBchgBIAEoBRIJCgFnGAIgASgFEgkKAWIY" + 
        "AyABKAUSCQoBYRgEIAEoBSKRAQoMQ05FVE1zZ19UaWNrEgwKBHRpY2sYASAB" + 
        "KA0SHAoUaG9zdF9jb21wdXRhdGlvbnRpbWUYBCABKA0SKgoiaG9zdF9jb21w" + 
        "dXRhdGlvbnRpbWVfc3RkX2RldmlhdGlvbhgFIAEoDRIpCiFob3N0X2ZyYW1l" + 
        "c3RhcnR0aW1lX3N0ZF9kZXZpYXRpb24YBiABKA0iJAoRQ05FVE1zZ19TdHJp" + 
        "bmdDbWQSDwoHY29tbWFuZBgBIAEoCSKKAQoTQ05FVE1zZ19TaWdub25TdGF0" + 
        "ZRIUCgxzaWdub25fc3RhdGUYASABKA0SEwoLc3Bhd25fY291bnQYAiABKA0S" + 
        "GgoSbnVtX3NlcnZlcl9wbGF5ZXJzGAMgASgNEhoKEnBsYXllcnNfbmV0d29y" + 
        "a2lkcxgEIAMoCRIQCghtYXBfbmFtZRgFIAEoCSJSCgpDTXNnX0NWYXJzEh8K" + 
        "BWN2YXJzGAEgAygLMhAuQ01zZ19DVmFycy5DVmFyGiMKBENWYXISDAoEbmFt" + 
        "ZRgBIAEoCRINCgV2YWx1ZRgCIAEoCSIxChFDTkVUTXNnX1NldENvblZhchIc" + 
        "Cgdjb252YXJzGAEgASgLMgsuQ01zZ19DVmFycyINCgtDTkVUTXNnX05PUCIi" + 
        "ChJDTkVUTXNnX0Rpc2Nvbm5lY3QSDAoEdGV4dBgBIAEoCSJhCgxDTkVUTXNn" + 
        "X0ZpbGUSEwoLdHJhbnNmZXJfaWQYASABKAUSEQoJZmlsZV9uYW1lGAIgASgJ" + 
        "EhsKE2lzX3JlcGxheV9kZW1vX2ZpbGUYAyABKAgSDAoEZGVueRgEIAEoCCIn" + 
        "ChdDTkVUTXNnX1NwbGl0U2NyZWVuVXNlchIMCgRzbG90GAEgASgFIqYBChJD" + 
        "Q0xDTXNnX0NsaWVudEluZm8SFgoOc2VuZF90YWJsZV9jcmMYASABKAcSFAoM" + 
        "c2VydmVyX2NvdW50GAIgASgNEg8KB2lzX2hsdHYYAyABKAgSEQoJaXNfcmVw" + 
        "bGF5GAQgASgIEhIKCmZyaWVuZHNfaWQYBSABKA0SFAoMZnJpZW5kc19uYW1l" + 
        "GAYgASgJEhQKDGN1c3RvbV9maWxlcxgHIAMoByJTCgxDQ0xDTXNnX01vdmUS" + 
        "GwoTbnVtX2JhY2t1cF9jb21tYW5kcxgBIAEoDRIYChBudW1fbmV3X2NvbW1h" + 
        "bmRzGAIgASgNEgwKBGRhdGEYAyABKAwiLwoRQ0NMQ01zZ19Wb2ljZURhdGES" + 
        "DAoEZGF0YRgBIAEoDBIMCgR4dWlkGAIgASgGIkEKE0NDTENNc2dfQmFzZWxp" + 
        "bmVBY2sSFQoNYmFzZWxpbmVfdGljaxgBIAEoBRITCgtiYXNlbGluZV9uchgC" + 
        "IAEoBSIqChRDQ0xDTXNnX0xpc3RlbkV2ZW50cxISCgpldmVudF9tYXNrGAEg" + 
        "AygHIlwKGENDTENNc2dfUmVzcG9uZEN2YXJWYWx1ZRIOCgZjb29raWUYASAB" + 
        "KAUSEwoLc3RhdHVzX2NvZGUYAiABKAUSDAoEbmFtZRgDIAEoCRINCgV2YWx1" + 
        "ZRgEIAEoCSLrAQoUQ0NMQ01zZ19GaWxlQ1JDQ2hlY2sSEQoJY29kZV9wYXRo" + 
        "GAEgASgFEgwKBHBhdGgYAiABKAkSFQoNY29kZV9maWxlbmFtZRgDIAEoBRIQ" + 
        "CghmaWxlbmFtZRgEIAEoCRIVCg1maWxlX2ZyYWN0aW9uGAUgASgFEgsKA21k" + 
        "NRgGIAEoDBILCgNjcmMYByABKA0SFgoOZmlsZV9oYXNoX3R5cGUYCCABKAUS" + 
        "EAoIZmlsZV9sZW4YCSABKAUSFAoMcGFja19maWxlX2lkGAogASgFEhgKEHBh" + 
        "Y2tfZmlsZV9udW1iZXIYCyABKAUiKwoXQ0NMQ01zZ19Mb2FkaW5nUHJvZ3Jl" + 
        "c3MSEAoIcHJvZ3Jlc3MYASABKAUiOgoaQ0NMQ01zZ19TcGxpdFBsYXllckNv" + 
        "bm5lY3QSHAoHY29udmFycxgBIAEoCzILLkNNc2dfQ1ZhcnMiKQoUQ0NMQ01z" + 
        "Z19DbWRLZXlWYWx1ZXMSEQoJa2V5dmFsdWVzGAEgASgMIuoDChJDU1ZDTXNn" + 
        "X1NlcnZlckluZm8SEAoIcHJvdG9jb2wYASABKAUSFAoMc2VydmVyX2NvdW50" + 
        "GAIgASgFEhQKDGlzX2RlZGljYXRlZBgDIAEoCBIgChhpc19vZmZpY2lhbF92" + 
        "YWx2ZV9zZXJ2ZXIYBCABKAgSDwoHaXNfaGx0dhgFIAEoCBIRCglpc19yZXBs" + 
        "YXkYBiABKAgSJQodaXNfcmVkaXJlY3RpbmdfdG9fcHJveHlfcmVsYXkYFSAB" + 
        "KAgSDAoEY19vcxgHIAEoBRIPCgdtYXBfY3JjGAggASgHEhIKCmNsaWVudF9j" + 
        "cmMYCSABKAcSGAoQc3RyaW5nX3RhYmxlX2NyYxgKIAEoBxITCgttYXhfY2xp" + 
        "ZW50cxgLIAEoBRITCgttYXhfY2xhc3NlcxgMIAEoBRITCgtwbGF5ZXJfc2xv" + 
        "dBgNIAEoBRIVCg10aWNrX2ludGVydmFsGA4gASgCEhAKCGdhbWVfZGlyGA8g" + 
        "ASgJEhAKCG1hcF9uYW1lGBAgASgJEhYKDm1hcF9ncm91cF9uYW1lGBEgASgJ" + 
        "EhAKCHNreV9uYW1lGBIgASgJEhEKCWhvc3RfbmFtZRgTIAEoCRIRCglwdWJs" + 
        "aWNfaXAYFCABKA0SEgoKdWdjX21hcF9pZBgWIAEoBCKkAQoRQ1NWQ01zZ19D" + 
        "bGFzc0luZm8SGAoQY3JlYXRlX29uX2NsaWVudBgBIAEoCBIrCgdjbGFzc2Vz" + 
        "GAIgAygLMhouQ1NWQ01zZ19DbGFzc0luZm8uY2xhc3NfdBpICgdjbGFzc190" + 
        "EhAKCGNsYXNzX2lkGAEgASgFEhcKD2RhdGFfdGFibGVfbmFtZRgCIAEoCRIS" + 
        "CgpjbGFzc19uYW1lGAMgASgJIrACChFDU1ZDTXNnX1NlbmRUYWJsZRIOCgZp" + 
        "c19lbmQYASABKAgSFgoObmV0X3RhYmxlX25hbWUYAiABKAkSFQoNbmVlZHNf" + 
        "ZGVjb2RlchgDIAEoCBIsCgVwcm9wcxgEIAMoCzIdLkNTVkNNc2dfU2VuZFRh" + 
        "YmxlLnNlbmRwcm9wX3QarQEKCnNlbmRwcm9wX3QSDAoEdHlwZRgBIAEoBRIQ" + 
        "Cgh2YXJfbmFtZRgCIAEoCRINCgVmbGFncxgDIAEoBRIQCghwcmlvcml0eRgE" + 
        "IAEoBRIPCgdkdF9uYW1lGAUgASgJEhQKDG51bV9lbGVtZW50cxgGIAEoBRIR" + 
        "Cglsb3dfdmFsdWUYByABKAISEgoKaGlnaF92YWx1ZRgIIAEoAhIQCghudW1f" + 
        "Yml0cxgJIAEoBSIdCg1DU1ZDTXNnX1ByaW50EgwKBHRleHQYASABKAkiIgoQ" + 
        "Q1NWQ01zZ19TZXRQYXVzZRIOCgZwYXVzZWQYASABKAgiJwoPQ1NWQ01zZ19T" + 
        "ZXRWaWV3EhQKDGVudGl0eV9pbmRleBgBIAEoBSLKAQoZQ1NWQ01zZ19DcmVh" + 
        "dGVTdHJpbmdUYWJsZRIMCgRuYW1lGAEgASgJEhMKC21heF9lbnRyaWVzGAIg" + 
        "ASgFEhMKC251bV9lbnRyaWVzGAMgASgFEhwKFHVzZXJfZGF0YV9maXhlZF9z" + 
        "aXplGAQgASgIEhYKDnVzZXJfZGF0YV9zaXplGAUgASgFEhsKE3VzZXJfZGF0" + 
        "YV9zaXplX2JpdHMYBiABKAUSDQoFZmxhZ3MYByABKAUSEwoLc3RyaW5nX2Rh" + 
        "dGEYCCABKAwiXwoZQ1NWQ01zZ19VcGRhdGVTdHJpbmdUYWJsZRIQCgh0YWJs" + 
        "ZV9pZBgBIAEoBRIbChNudW1fY2hhbmdlZF9lbnRyaWVzGAIgASgFEhMKC3N0" + 
        "cmluZ19kYXRhGAMgASgMIjMKEUNTVkNNc2dfVm9pY2VJbml0Eg8KB3F1YWxp" + 
        "dHkYASABKAUSDQoFY29kZWMYAiABKAkifgoRQ1NWQ01zZ19Wb2ljZURhdGES" + 
        "DgoGY2xpZW50GAEgASgFEhEKCXByb3hpbWl0eRgCIAEoCBIMCgR4dWlkGAMg" + 
        "ASgGEhQKDGF1ZGlibGVfbWFzaxgEIAEoBRISCgp2b2ljZV9kYXRhGAUgASgM" + 
        "Eg4KBmNhc3RlchgGIAEoCCJAChBDU1ZDTXNnX0ZpeEFuZ2xlEhAKCHJlbGF0" + 
        "aXZlGAEgASgIEhoKBWFuZ2xlGAIgASgLMgsuQ01zZ1FBbmdsZSI0ChZDU1ZD" + 
        "TXNnX0Nyb3NzaGFpckFuZ2xlEhoKBWFuZ2xlGAEgASgLMgsuQ01zZ1FBbmds" + 
        "ZSInChBDU1ZDTXNnX1ByZWZldGNoEhMKC3NvdW5kX2luZGV4GAEgASgFIooB" + 
        "ChBDU1ZDTXNnX0JTUERlY2FsEhgKA3BvcxgBIAEoCzILLkNNc2dWZWN0b3IS" + 
        "GwoTZGVjYWxfdGV4dHVyZV9pbmRleBgCIAEoBRIUCgxlbnRpdHlfaW5kZXgY" + 
        "AyABKAUSEwoLbW9kZWxfaW5kZXgYBCABKAUSFAoMbG93X3ByaW9yaXR5GAUg" + 
        "ASgIInoKE0NTVkNNc2dfU3BsaXRTY3JlZW4SPwoEdHlwZRgBIAEoDjIYLkVT" + 
        "cGxpdFNjcmVlbk1lc3NhZ2VUeXBlOhdNU0dfU1BMSVRTQ1JFRU5fQUREVVNF" + 
        "UhIMCgRzbG90GAIgASgFEhQKDHBsYXllcl9pbmRleBgDIAEoBSI5ChRDU1ZD" + 
        "TXNnX0dldEN2YXJWYWx1ZRIOCgZjb29raWUYASABKAUSEQoJY3Zhcl9uYW1l" + 
        "GAIgASgJIjwKDENTVkNNc2dfTWVudRITCgtkaWFsb2dfdHlwZRgBIAEoBRIX" + 
        "Cg9tZW51X2tleV92YWx1ZXMYAiABKAwiOQoTQ1NWQ01zZ19Vc2VyTWVzc2Fn" + 
        "ZRIQCghtc2dfdHlwZRgBIAEoBRIQCghtc2dfZGF0YRgCIAEoDCIoChRDU1ZD" + 
        "TXNnX1BhaW50bWFwRGF0YRIQCghwYWludG1hcBgBIAEoDCKRAgoRQ1NWQ01z" + 
        "Z19HYW1lRXZlbnQSEgoKZXZlbnRfbmFtZRgBIAEoCRIPCgdldmVudGlkGAIg" + 
        "ASgFEiYKBGtleXMYAyADKAsyGC5DU1ZDTXNnX0dhbWVFdmVudC5rZXlfdBqu" + 
        "AQoFa2V5X3QSDAoEdHlwZRgBIAEoBRISCgp2YWxfc3RyaW5nGAIgASgJEhEK" + 
        "CXZhbF9mbG9hdBgDIAEoAhIQCgh2YWxfbG9uZxgEIAEoBRIRCgl2YWxfc2hv" + 
        "cnQYBSABKAUSEAoIdmFsX2J5dGUYBiABKAUSEAoIdmFsX2Jvb2wYByABKAgS" + 
        "EgoKdmFsX3VpbnQ2NBgIIAEoBBITCgt2YWxfd3N0cmluZxgJIAEoDCLRAQoV" + 
        "Q1NWQ01zZ19HYW1lRXZlbnRMaXN0EjgKC2Rlc2NyaXB0b3JzGAEgAygLMiMu" + 
        "Q1NWQ01zZ19HYW1lRXZlbnRMaXN0LmRlc2NyaXB0b3JfdBojCgVrZXlfdBIM" + 
        "CgR0eXBlGAEgASgFEgwKBG5hbWUYAiABKAkaWQoMZGVzY3JpcHRvcl90Eg8K" + 
        "B2V2ZW50aWQYASABKAUSDAoEbmFtZRgCIAEoCRIqCgRrZXlzGAMgAygLMhwu" + 
        "Q1NWQ01zZ19HYW1lRXZlbnRMaXN0LmtleV90IlIKFENTVkNNc2dfVGVtcEVu" + 
        "dGl0aWVzEhAKCHJlbGlhYmxlGAEgASgIEhMKC251bV9lbnRyaWVzGAIgASgF" + 
        "EhMKC2VudGl0eV9kYXRhGAMgASgMIqwBChZDU1ZDTXNnX1BhY2tldEVudGl0" + 
        "aWVzEhMKC21heF9lbnRyaWVzGAEgASgFEhcKD3VwZGF0ZWRfZW50cmllcxgC" + 
        "IAEoBRIQCghpc19kZWx0YRgDIAEoCBIXCg91cGRhdGVfYmFzZWxpbmUYBCAB" + 
        "KAgSEAoIYmFzZWxpbmUYBSABKAUSEgoKZGVsdGFfZnJvbRgGIAEoBRITCgtl" + 
        "bnRpdHlfZGF0YRgHIAEoDCK2AwoOQ1NWQ01zZ19Tb3VuZHMSFgoOcmVsaWFi" + 
        "bGVfc291bmQYASABKAgSKwoGc291bmRzGAIgAygLMhsuQ1NWQ01zZ19Tb3Vu" + 
        "ZHMuc291bmRkYXRhX3Qa3gIKC3NvdW5kZGF0YV90EhAKCG9yaWdpbl94GAEg" + 
        "ASgREhAKCG9yaWdpbl95GAIgASgREhAKCG9yaWdpbl96GAMgASgREg4KBnZv" + 
        "bHVtZRgEIAEoDRITCgtkZWxheV92YWx1ZRgFIAEoAhIXCg9zZXF1ZW5jZV9u" + 
        "dW1iZXIYBiABKAUSFAoMZW50aXR5X2luZGV4GAcgASgFEg8KB2NoYW5uZWwY" + 
        "CCABKAUSDQoFcGl0Y2gYCSABKAUSDQoFZmxhZ3MYCiABKAUSEQoJc291bmRf" + 
        "bnVtGAsgASgNEhgKEHNvdW5kX251bV9oYW5kbGUYDCABKAcSFgoOc3BlYWtl" + 
        "cl9lbnRpdHkYDSABKAUSEwoLcmFuZG9tX3NlZWQYDiABKAUSEwoLc291bmRf" + 
        "bGV2ZWwYDyABKAUSEwoLaXNfc2VudGVuY2UYECABKAgSEgoKaXNfYW1iaWVu" + 
        "dBgRIAEoCCJKChFDU1ZDTXNnX0VudGl0eU1zZxIRCgllbnRfaW5kZXgYASAB" + 
        "KAUSEAoIY2xhc3NfaWQYAiABKAUSEAoIZW50X2RhdGEYAyABKAwiKQoUQ1NW" + 
        "Q01zZ19DbWRLZXlWYWx1ZXMSEQoJa2V5dmFsdWVzGAEgASgMIjwKFUNTVkNN" + 
        "c2dfRW5jcnlwdGVkRGF0YRIRCgllbmNyeXB0ZWQYASABKAwSEAoIa2V5X3R5" + 
        "cGUYAiABKAUqnwEKDE5FVF9NZXNzYWdlcxILCgduZXRfTk9QEAASEgoObmV0" + 
        "X0Rpc2Nvbm5lY3QQARIMCghuZXRfRmlsZRACEhcKE25ldF9TcGxpdFNjcmVl" + 
        "blVzZXIQAxIMCghuZXRfVGljaxAEEhEKDW5ldF9TdHJpbmdDbWQQBRIRCg1u" + 
        "ZXRfU2V0Q29uVmFyEAYSEwoPbmV0X1NpZ25vblN0YXRlEAcqgAIKDENMQ19N" + 
        "ZXNzYWdlcxISCg5jbGNfQ2xpZW50SW5mbxAIEgwKCGNsY19Nb3ZlEAkSEQoN" + 
        "Y2xjX1ZvaWNlRGF0YRAKEhMKD2NsY19CYXNlbGluZUFjaxALEhQKEGNsY19M" + 
        "aXN0ZW5FdmVudHMQDBIYChRjbGNfUmVzcG9uZEN2YXJWYWx1ZRANEhQKEGNs" + 
        "Y19GaWxlQ1JDQ2hlY2sQDhIXChNjbGNfTG9hZGluZ1Byb2dyZXNzEA8SGgoW" + 
        "Y2xjX1NwbGl0UGxheWVyQ29ubmVjdBAQEhUKEWNsY19DbGllbnRNZXNzYWdl" + 
        "EBESFAoQY2xjX0NtZEtleVZhbHVlcxASKnUKF0VTcGxpdFNjcmVlbk1lc3Nh" + 
        "Z2VUeXBlEhsKF01TR19TUExJVFNDUkVFTl9BRERVU0VSEAASHgoaTVNHX1NQ" + 
        "TElUU0NSRUVOX1JFTU9WRVVTRVIQARIdChlNU0dfU1BMSVRTQ1JFRU5fVFlQ" + 
        "RV9CSVRTEAIqtAQKDFNWQ19NZXNzYWdlcxISCg5zdmNfU2VydmVySW5mbxAI" + 
        "EhEKDXN2Y19TZW5kVGFibGUQCRIRCg1zdmNfQ2xhc3NJbmZvEAoSEAoMc3Zj" + 
        "X1NldFBhdXNlEAsSGQoVc3ZjX0NyZWF0ZVN0cmluZ1RhYmxlEAwSGQoVc3Zj" + 
        "X1VwZGF0ZVN0cmluZ1RhYmxlEA0SEQoNc3ZjX1ZvaWNlSW5pdBAOEhEKDXN2" + 
        "Y19Wb2ljZURhdGEQDxINCglzdmNfUHJpbnQQEBIOCgpzdmNfU291bmRzEBES" + 
        "DwoLc3ZjX1NldFZpZXcQEhIQCgxzdmNfRml4QW5nbGUQExIWChJzdmNfQ3Jv" + 
        "c3NoYWlyQW5nbGUQFBIQCgxzdmNfQlNQRGVjYWwQFRITCg9zdmNfU3BsaXRT" + 
        "Y3JlZW4QFhITCg9zdmNfVXNlck1lc3NhZ2UQFxIVChFzdmNfRW50aXR5TWVz" + 
        "c2FnZRAYEhEKDXN2Y19HYW1lRXZlbnQQGRIWChJzdmNfUGFja2V0RW50aXRp" + 
        "ZXMQGhIUChBzdmNfVGVtcEVudGl0aWVzEBsSEAoMc3ZjX1ByZWZldGNoEBwS" + 
        "DAoIc3ZjX01lbnUQHRIVChFzdmNfR2FtZUV2ZW50TGlzdBAeEhQKEHN2Y19H" + 
        "ZXRDdmFyVmFsdWUQHxIUChBzdmNfUGFpbnRtYXBEYXRhECESFAoQc3ZjX0Nt" + 
        "ZEtleVZhbHVlcxAiEhUKEXN2Y19FbmNyeXB0ZWREYXRhECM=");
    pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
      descriptor = root;
      internal__static_CMsgVector__Descriptor = Descriptor.MessageTypes[0];
      internal__static_CMsgVector__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CMsgVector, global::CMsgVector.Builder>(internal__static_CMsgVector__Descriptor,
              new string[] { "X", "Y", "Z", });
      internal__static_CMsgVector2D__Descriptor = Descriptor.MessageTypes[1];
      internal__static_CMsgVector2D__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CMsgVector2D, global::CMsgVector2D.Builder>(internal__static_CMsgVector2D__Descriptor,
              new string[] { "X", "Y", });
      internal__static_CMsgQAngle__Descriptor = Descriptor.MessageTypes[2];
      internal__static_CMsgQAngle__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CMsgQAngle, global::CMsgQAngle.Builder>(internal__static_CMsgQAngle__Descriptor,
              new string[] { "X", "Y", "Z", });
      internal__static_CMsgRGBA__Descriptor = Descriptor.MessageTypes[3];
      internal__static_CMsgRGBA__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CMsgRGBA, global::CMsgRGBA.Builder>(internal__static_CMsgRGBA__Descriptor,
              new string[] { "R", "G", "B", "A", });
      internal__static_CNETMsg_Tick__Descriptor = Descriptor.MessageTypes[4];
      internal__static_CNETMsg_Tick__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CNETMsg_Tick, global::CNETMsg_Tick.Builder>(internal__static_CNETMsg_Tick__Descriptor,
              new string[] { "Tick", "HostComputationtime", "HostComputationtimeStdDeviation", "HostFramestarttimeStdDeviation", });
      internal__static_CNETMsg_StringCmd__Descriptor = Descriptor.MessageTypes[5];
      internal__static_CNETMsg_StringCmd__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CNETMsg_StringCmd, global::CNETMsg_StringCmd.Builder>(internal__static_CNETMsg_StringCmd__Descriptor,
              new string[] { "Command", });
      internal__static_CNETMsg_SignonState__Descriptor = Descriptor.MessageTypes[6];
      internal__static_CNETMsg_SignonState__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CNETMsg_SignonState, global::CNETMsg_SignonState.Builder>(internal__static_CNETMsg_SignonState__Descriptor,
              new string[] { "SignonState", "SpawnCount", "NumServerPlayers", "PlayersNetworkids", "MapName", });
      internal__static_CMsg_CVars__Descriptor = Descriptor.MessageTypes[7];
      internal__static_CMsg_CVars__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CMsg_CVars, global::CMsg_CVars.Builder>(internal__static_CMsg_CVars__Descriptor,
              new string[] { "Cvars", });
      internal__static_CMsg_CVars_CVar__Descriptor = internal__static_CMsg_CVars__Descriptor.NestedTypes[0];
      internal__static_CMsg_CVars_CVar__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CMsg_CVars.Types.CVar, global::CMsg_CVars.Types.CVar.Builder>(internal__static_CMsg_CVars_CVar__Descriptor,
              new string[] { "Name", "Value", });
      internal__static_CNETMsg_SetConVar__Descriptor = Descriptor.MessageTypes[8];
      internal__static_CNETMsg_SetConVar__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CNETMsg_SetConVar, global::CNETMsg_SetConVar.Builder>(internal__static_CNETMsg_SetConVar__Descriptor,
              new string[] { "Convars", });
      internal__static_CNETMsg_NOP__Descriptor = Descriptor.MessageTypes[9];
      internal__static_CNETMsg_NOP__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CNETMsg_NOP, global::CNETMsg_NOP.Builder>(internal__static_CNETMsg_NOP__Descriptor,
              new string[] { });
      internal__static_CNETMsg_Disconnect__Descriptor = Descriptor.MessageTypes[10];
      internal__static_CNETMsg_Disconnect__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CNETMsg_Disconnect, global::CNETMsg_Disconnect.Builder>(internal__static_CNETMsg_Disconnect__Descriptor,
              new string[] { "Text", });
      internal__static_CNETMsg_File__Descriptor = Descriptor.MessageTypes[11];
      internal__static_CNETMsg_File__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CNETMsg_File, global::CNETMsg_File.Builder>(internal__static_CNETMsg_File__Descriptor,
              new string[] { "TransferId", "FileName", "IsReplayDemoFile", "Deny", });
      internal__static_CNETMsg_SplitScreenUser__Descriptor = Descriptor.MessageTypes[12];
      internal__static_CNETMsg_SplitScreenUser__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CNETMsg_SplitScreenUser, global::CNETMsg_SplitScreenUser.Builder>(internal__static_CNETMsg_SplitScreenUser__Descriptor,
              new string[] { "Slot", });
      internal__static_CCLCMsg_ClientInfo__Descriptor = Descriptor.MessageTypes[13];
      internal__static_CCLCMsg_ClientInfo__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_ClientInfo, global::CCLCMsg_ClientInfo.Builder>(internal__static_CCLCMsg_ClientInfo__Descriptor,
              new string[] { "SendTableCrc", "ServerCount", "IsHltv", "IsReplay", "FriendsId", "FriendsName", "CustomFiles", });
      internal__static_CCLCMsg_Move__Descriptor = Descriptor.MessageTypes[14];
      internal__static_CCLCMsg_Move__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_Move, global::CCLCMsg_Move.Builder>(internal__static_CCLCMsg_Move__Descriptor,
              new string[] { "NumBackupCommands", "NumNewCommands", "Data", });
      internal__static_CCLCMsg_VoiceData__Descriptor = Descriptor.MessageTypes[15];
      internal__static_CCLCMsg_VoiceData__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_VoiceData, global::CCLCMsg_VoiceData.Builder>(internal__static_CCLCMsg_VoiceData__Descriptor,
              new string[] { "Data", "Xuid", });
      internal__static_CCLCMsg_BaselineAck__Descriptor = Descriptor.MessageTypes[16];
      internal__static_CCLCMsg_BaselineAck__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_BaselineAck, global::CCLCMsg_BaselineAck.Builder>(internal__static_CCLCMsg_BaselineAck__Descriptor,
              new string[] { "BaselineTick", "BaselineNr", });
      internal__static_CCLCMsg_ListenEvents__Descriptor = Descriptor.MessageTypes[17];
      internal__static_CCLCMsg_ListenEvents__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_ListenEvents, global::CCLCMsg_ListenEvents.Builder>(internal__static_CCLCMsg_ListenEvents__Descriptor,
              new string[] { "EventMask", });
      internal__static_CCLCMsg_RespondCvarValue__Descriptor = Descriptor.MessageTypes[18];
      internal__static_CCLCMsg_RespondCvarValue__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_RespondCvarValue, global::CCLCMsg_RespondCvarValue.Builder>(internal__static_CCLCMsg_RespondCvarValue__Descriptor,
              new string[] { "Cookie", "StatusCode", "Name", "Value", });
      internal__static_CCLCMsg_FileCRCCheck__Descriptor = Descriptor.MessageTypes[19];
      internal__static_CCLCMsg_FileCRCCheck__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_FileCRCCheck, global::CCLCMsg_FileCRCCheck.Builder>(internal__static_CCLCMsg_FileCRCCheck__Descriptor,
              new string[] { "CodePath", "Path", "CodeFilename", "Filename", "FileFraction", "Md5", "Crc", "FileHashType", "FileLen", "PackFileId", "PackFileNumber", });
      internal__static_CCLCMsg_LoadingProgress__Descriptor = Descriptor.MessageTypes[20];
      internal__static_CCLCMsg_LoadingProgress__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_LoadingProgress, global::CCLCMsg_LoadingProgress.Builder>(internal__static_CCLCMsg_LoadingProgress__Descriptor,
              new string[] { "Progress", });
      internal__static_CCLCMsg_SplitPlayerConnect__Descriptor = Descriptor.MessageTypes[21];
      internal__static_CCLCMsg_SplitPlayerConnect__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_SplitPlayerConnect, global::CCLCMsg_SplitPlayerConnect.Builder>(internal__static_CCLCMsg_SplitPlayerConnect__Descriptor,
              new string[] { "Convars", });
      internal__static_CCLCMsg_CmdKeyValues__Descriptor = Descriptor.MessageTypes[22];
      internal__static_CCLCMsg_CmdKeyValues__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CCLCMsg_CmdKeyValues, global::CCLCMsg_CmdKeyValues.Builder>(internal__static_CCLCMsg_CmdKeyValues__Descriptor,
              new string[] { "Keyvalues", });
      internal__static_CSVCMsg_ServerInfo__Descriptor = Descriptor.MessageTypes[23];
      internal__static_CSVCMsg_ServerInfo__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_ServerInfo, global::CSVCMsg_ServerInfo.Builder>(internal__static_CSVCMsg_ServerInfo__Descriptor,
              new string[] { "Protocol", "ServerCount", "IsDedicated", "IsOfficialValveServer", "IsHltv", "IsReplay", "IsRedirectingToProxyRelay", "COs", "MapCrc", "ClientCrc", "StringTableCrc", "MaxClients", "MaxClasses", "PlayerSlot", "TickInterval", "GameDir", "MapName", "MapGroupName", "SkyName", "HostName", "PublicIp", "UgcMapId", });
      internal__static_CSVCMsg_ClassInfo__Descriptor = Descriptor.MessageTypes[24];
      internal__static_CSVCMsg_ClassInfo__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_ClassInfo, global::CSVCMsg_ClassInfo.Builder>(internal__static_CSVCMsg_ClassInfo__Descriptor,
              new string[] { "CreateOnClient", "Classes", });
      internal__static_CSVCMsg_ClassInfo_class_t__Descriptor = internal__static_CSVCMsg_ClassInfo__Descriptor.NestedTypes[0];
      internal__static_CSVCMsg_ClassInfo_class_t__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_ClassInfo.Types.class_t, global::CSVCMsg_ClassInfo.Types.class_t.Builder>(internal__static_CSVCMsg_ClassInfo_class_t__Descriptor,
              new string[] { "ClassId", "DataTableName", "ClassName", });
      internal__static_CSVCMsg_SendTable__Descriptor = Descriptor.MessageTypes[25];
      internal__static_CSVCMsg_SendTable__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_SendTable, global::CSVCMsg_SendTable.Builder>(internal__static_CSVCMsg_SendTable__Descriptor,
              new string[] { "IsEnd", "NetTableName", "NeedsDecoder", "Props", });
      internal__static_CSVCMsg_SendTable_sendprop_t__Descriptor = internal__static_CSVCMsg_SendTable__Descriptor.NestedTypes[0];
      internal__static_CSVCMsg_SendTable_sendprop_t__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_SendTable.Types.sendprop_t, global::CSVCMsg_SendTable.Types.sendprop_t.Builder>(internal__static_CSVCMsg_SendTable_sendprop_t__Descriptor,
              new string[] { "Type", "VarName", "Flags", "Priority", "DtName", "NumElements", "LowValue", "HighValue", "NumBits", });
      internal__static_CSVCMsg_Print__Descriptor = Descriptor.MessageTypes[26];
      internal__static_CSVCMsg_Print__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_Print, global::CSVCMsg_Print.Builder>(internal__static_CSVCMsg_Print__Descriptor,
              new string[] { "Text", });
      internal__static_CSVCMsg_SetPause__Descriptor = Descriptor.MessageTypes[27];
      internal__static_CSVCMsg_SetPause__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_SetPause, global::CSVCMsg_SetPause.Builder>(internal__static_CSVCMsg_SetPause__Descriptor,
              new string[] { "Paused", });
      internal__static_CSVCMsg_SetView__Descriptor = Descriptor.MessageTypes[28];
      internal__static_CSVCMsg_SetView__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_SetView, global::CSVCMsg_SetView.Builder>(internal__static_CSVCMsg_SetView__Descriptor,
              new string[] { "EntityIndex", });
      internal__static_CSVCMsg_CreateStringTable__Descriptor = Descriptor.MessageTypes[29];
      internal__static_CSVCMsg_CreateStringTable__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_CreateStringTable, global::CSVCMsg_CreateStringTable.Builder>(internal__static_CSVCMsg_CreateStringTable__Descriptor,
              new string[] { "Name", "MaxEntries", "NumEntries", "UserDataFixedSize", "UserDataSize", "UserDataSizeBits", "Flags", "StringData", });
      internal__static_CSVCMsg_UpdateStringTable__Descriptor = Descriptor.MessageTypes[30];
      internal__static_CSVCMsg_UpdateStringTable__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_UpdateStringTable, global::CSVCMsg_UpdateStringTable.Builder>(internal__static_CSVCMsg_UpdateStringTable__Descriptor,
              new string[] { "TableId", "NumChangedEntries", "StringData", });
      internal__static_CSVCMsg_VoiceInit__Descriptor = Descriptor.MessageTypes[31];
      internal__static_CSVCMsg_VoiceInit__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_VoiceInit, global::CSVCMsg_VoiceInit.Builder>(internal__static_CSVCMsg_VoiceInit__Descriptor,
              new string[] { "Quality", "Codec", });
      internal__static_CSVCMsg_VoiceData__Descriptor = Descriptor.MessageTypes[32];
      internal__static_CSVCMsg_VoiceData__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_VoiceData, global::CSVCMsg_VoiceData.Builder>(internal__static_CSVCMsg_VoiceData__Descriptor,
              new string[] { "Client", "Proximity", "Xuid", "AudibleMask", "VoiceData", "Caster", });
      internal__static_CSVCMsg_FixAngle__Descriptor = Descriptor.MessageTypes[33];
      internal__static_CSVCMsg_FixAngle__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_FixAngle, global::CSVCMsg_FixAngle.Builder>(internal__static_CSVCMsg_FixAngle__Descriptor,
              new string[] { "Relative", "Angle", });
      internal__static_CSVCMsg_CrosshairAngle__Descriptor = Descriptor.MessageTypes[34];
      internal__static_CSVCMsg_CrosshairAngle__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_CrosshairAngle, global::CSVCMsg_CrosshairAngle.Builder>(internal__static_CSVCMsg_CrosshairAngle__Descriptor,
              new string[] { "Angle", });
      internal__static_CSVCMsg_Prefetch__Descriptor = Descriptor.MessageTypes[35];
      internal__static_CSVCMsg_Prefetch__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_Prefetch, global::CSVCMsg_Prefetch.Builder>(internal__static_CSVCMsg_Prefetch__Descriptor,
              new string[] { "SoundIndex", });
      internal__static_CSVCMsg_BSPDecal__Descriptor = Descriptor.MessageTypes[36];
      internal__static_CSVCMsg_BSPDecal__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_BSPDecal, global::CSVCMsg_BSPDecal.Builder>(internal__static_CSVCMsg_BSPDecal__Descriptor,
              new string[] { "Pos", "DecalTextureIndex", "EntityIndex", "ModelIndex", "LowPriority", });
      internal__static_CSVCMsg_SplitScreen__Descriptor = Descriptor.MessageTypes[37];
      internal__static_CSVCMsg_SplitScreen__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_SplitScreen, global::CSVCMsg_SplitScreen.Builder>(internal__static_CSVCMsg_SplitScreen__Descriptor,
              new string[] { "Type", "Slot", "PlayerIndex", });
      internal__static_CSVCMsg_GetCvarValue__Descriptor = Descriptor.MessageTypes[38];
      internal__static_CSVCMsg_GetCvarValue__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GetCvarValue, global::CSVCMsg_GetCvarValue.Builder>(internal__static_CSVCMsg_GetCvarValue__Descriptor,
              new string[] { "Cookie", "CvarName", });
      internal__static_CSVCMsg_Menu__Descriptor = Descriptor.MessageTypes[39];
      internal__static_CSVCMsg_Menu__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_Menu, global::CSVCMsg_Menu.Builder>(internal__static_CSVCMsg_Menu__Descriptor,
              new string[] { "DialogType", "MenuKeyValues", });
      internal__static_CSVCMsg_UserMessage__Descriptor = Descriptor.MessageTypes[40];
      internal__static_CSVCMsg_UserMessage__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_UserMessage, global::CSVCMsg_UserMessage.Builder>(internal__static_CSVCMsg_UserMessage__Descriptor,
              new string[] { "MsgType", "MsgData", });
      internal__static_CSVCMsg_PaintmapData__Descriptor = Descriptor.MessageTypes[41];
      internal__static_CSVCMsg_PaintmapData__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_PaintmapData, global::CSVCMsg_PaintmapData.Builder>(internal__static_CSVCMsg_PaintmapData__Descriptor,
              new string[] { "Paintmap", });
      internal__static_CSVCMsg_GameEvent__Descriptor = Descriptor.MessageTypes[42];
      internal__static_CSVCMsg_GameEvent__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GameEvent, global::CSVCMsg_GameEvent.Builder>(internal__static_CSVCMsg_GameEvent__Descriptor,
              new string[] { "EventName", "Eventid", "Keys", });
      internal__static_CSVCMsg_GameEvent_key_t__Descriptor = internal__static_CSVCMsg_GameEvent__Descriptor.NestedTypes[0];
      internal__static_CSVCMsg_GameEvent_key_t__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GameEvent.Types.key_t, global::CSVCMsg_GameEvent.Types.key_t.Builder>(internal__static_CSVCMsg_GameEvent_key_t__Descriptor,
              new string[] { "Type", "ValString", "ValFloat", "ValLong", "ValShort", "ValByte", "ValBool", "ValUint64", "ValWstring", });
      internal__static_CSVCMsg_GameEventList__Descriptor = Descriptor.MessageTypes[43];
      internal__static_CSVCMsg_GameEventList__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GameEventList, global::CSVCMsg_GameEventList.Builder>(internal__static_CSVCMsg_GameEventList__Descriptor,
              new string[] { "Descriptors", });
      internal__static_CSVCMsg_GameEventList_key_t__Descriptor = internal__static_CSVCMsg_GameEventList__Descriptor.NestedTypes[0];
      internal__static_CSVCMsg_GameEventList_key_t__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GameEventList.Types.key_t, global::CSVCMsg_GameEventList.Types.key_t.Builder>(internal__static_CSVCMsg_GameEventList_key_t__Descriptor,
              new string[] { "Type", "Name", });
      internal__static_CSVCMsg_GameEventList_descriptor_t__Descriptor = internal__static_CSVCMsg_GameEventList__Descriptor.NestedTypes[1];
      internal__static_CSVCMsg_GameEventList_descriptor_t__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_GameEventList.Types.descriptor_t, global::CSVCMsg_GameEventList.Types.descriptor_t.Builder>(internal__static_CSVCMsg_GameEventList_descriptor_t__Descriptor,
              new string[] { "Eventid", "Name", "Keys", });
      internal__static_CSVCMsg_TempEntities__Descriptor = Descriptor.MessageTypes[44];
      internal__static_CSVCMsg_TempEntities__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_TempEntities, global::CSVCMsg_TempEntities.Builder>(internal__static_CSVCMsg_TempEntities__Descriptor,
              new string[] { "Reliable", "NumEntries", "EntityData", });
      internal__static_CSVCMsg_PacketEntities__Descriptor = Descriptor.MessageTypes[45];
      internal__static_CSVCMsg_PacketEntities__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_PacketEntities, global::CSVCMsg_PacketEntities.Builder>(internal__static_CSVCMsg_PacketEntities__Descriptor,
              new string[] { "MaxEntries", "UpdatedEntries", "IsDelta", "UpdateBaseline", "Baseline", "DeltaFrom", "EntityData", });
      internal__static_CSVCMsg_Sounds__Descriptor = Descriptor.MessageTypes[46];
      internal__static_CSVCMsg_Sounds__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_Sounds, global::CSVCMsg_Sounds.Builder>(internal__static_CSVCMsg_Sounds__Descriptor,
              new string[] { "ReliableSound", "Sounds", });
      internal__static_CSVCMsg_Sounds_sounddata_t__Descriptor = internal__static_CSVCMsg_Sounds__Descriptor.NestedTypes[0];
      internal__static_CSVCMsg_Sounds_sounddata_t__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_Sounds.Types.sounddata_t, global::CSVCMsg_Sounds.Types.sounddata_t.Builder>(internal__static_CSVCMsg_Sounds_sounddata_t__Descriptor,
              new string[] { "OriginX", "OriginY", "OriginZ", "Volume", "DelayValue", "SequenceNumber", "EntityIndex", "Channel", "Pitch", "Flags", "SoundNum", "SoundNumHandle", "SpeakerEntity", "RandomSeed", "SoundLevel", "IsSentence", "IsAmbient", });
      internal__static_CSVCMsg_EntityMsg__Descriptor = Descriptor.MessageTypes[47];
      internal__static_CSVCMsg_EntityMsg__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_EntityMsg, global::CSVCMsg_EntityMsg.Builder>(internal__static_CSVCMsg_EntityMsg__Descriptor,
              new string[] { "EntIndex", "ClassId", "EntData", });
      internal__static_CSVCMsg_CmdKeyValues__Descriptor = Descriptor.MessageTypes[48];
      internal__static_CSVCMsg_CmdKeyValues__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_CmdKeyValues, global::CSVCMsg_CmdKeyValues.Builder>(internal__static_CSVCMsg_CmdKeyValues__Descriptor,
              new string[] { "Keyvalues", });
      internal__static_CSVCMsg_EncryptedData__Descriptor = Descriptor.MessageTypes[49];
      internal__static_CSVCMsg_EncryptedData__FieldAccessorTable = 
          new pb::FieldAccess.FieldAccessorTable<global::CSVCMsg_EncryptedData, global::CSVCMsg_EncryptedData.Builder>(internal__static_CSVCMsg_EncryptedData__Descriptor,
              new string[] { "Encrypted", "KeyType", });
      return null;
    };
    pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
        new pbd::FileDescriptor[] {
        global::Google.ProtocolBuffers.DescriptorProtos.DescriptorProtoFile.Descriptor, 
        }, assigner);
  }
  #endregion
  
}
#region Enums
public enum NET_Messages {
  net_NOP = 0,
  net_Disconnect = 1,
  net_File = 2,
  net_SplitScreenUser = 3,
  net_Tick = 4,
  net_StringCmd = 5,
  net_SetConVar = 6,
  net_SignonState = 7,
}

public enum CLC_Messages {
  clc_ClientInfo = 8,
  clc_Move = 9,
  clc_VoiceData = 10,
  clc_BaselineAck = 11,
  clc_ListenEvents = 12,
  clc_RespondCvarValue = 13,
  clc_FileCRCCheck = 14,
  clc_LoadingProgress = 15,
  clc_SplitPlayerConnect = 16,
  clc_ClientMessage = 17,
  clc_CmdKeyValues = 18,
}

public enum ESplitScreenMessageType {
  MSG_SPLITSCREEN_ADDUSER = 0,
  MSG_SPLITSCREEN_REMOVEUSER = 1,
  MSG_SPLITSCREEN_TYPE_BITS = 2,
}

public enum SVC_Messages {
  svc_ServerInfo = 8,
  svc_SendTable = 9,
  svc_ClassInfo = 10,
  svc_SetPause = 11,
  svc_CreateStringTable = 12,
  svc_UpdateStringTable = 13,
  svc_VoiceInit = 14,
  svc_VoiceData = 15,
  svc_Print = 16,
  svc_Sounds = 17,
  svc_SetView = 18,
  svc_FixAngle = 19,
  svc_CrosshairAngle = 20,
  svc_BSPDecal = 21,
  svc_SplitScreen = 22,
  svc_UserMessage = 23,
  svc_EntityMessage = 24,
  svc_GameEvent = 25,
  svc_PacketEntities = 26,
  svc_TempEntities = 27,
  svc_Prefetch = 28,
  svc_Menu = 29,
  svc_GameEventList = 30,
  svc_GetCvarValue = 31,
  svc_PaintmapData = 33,
  svc_CmdKeyValues = 34,
  svc_EncryptedData = 35,
}

#endregion

#region Messages
[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CMsgVector : pb::GeneratedMessage<CMsgVector, CMsgVector.Builder> {
  private CMsgVector() { }
  private static readonly CMsgVector defaultInstance = new CMsgVector().MakeReadOnly();
  private static readonly string[] _cMsgVectorFieldNames = new string[] { "x", "y", "z" };
  private static readonly uint[] _cMsgVectorFieldTags = new uint[] { 13, 21, 29 };
  public static CMsgVector DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CMsgVector DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CMsgVector ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CMsgVector__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CMsgVector, CMsgVector.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CMsgVector__FieldAccessorTable; }
  }
  
  public const int XFieldNumber = 1;
  private bool hasX;
  private float x_;
  public bool HasX {
    get { return hasX; }
  }
  public float X {
    get { return x_; }
  }
  
  public const int YFieldNumber = 2;
  private bool hasY;
  private float y_;
  public bool HasY {
    get { return hasY; }
  }
  public float Y {
    get { return y_; }
  }
  
  public const int ZFieldNumber = 3;
  private bool hasZ;
  private float z_;
  public bool HasZ {
    get { return hasZ; }
  }
  public float Z {
    get { return z_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cMsgVectorFieldNames;
    if (hasX) {
      output.WriteFloat(1, field_names[0], X);
    }
    if (hasY) {
      output.WriteFloat(2, field_names[1], Y);
    }
    if (hasZ) {
      output.WriteFloat(3, field_names[2], Z);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasX) {
        size += pb::CodedOutputStream.ComputeFloatSize(1, X);
      }
      if (hasY) {
        size += pb::CodedOutputStream.ComputeFloatSize(2, Y);
      }
      if (hasZ) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, Z);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CMsgVector ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CMsgVector ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CMsgVector ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CMsgVector ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CMsgVector ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CMsgVector ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CMsgVector ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CMsgVector ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CMsgVector ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CMsgVector ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CMsgVector MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CMsgVector prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CMsgVector, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CMsgVector cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CMsgVector result;
    
    private CMsgVector PrepareBuilder() {
      if (resultIsReadOnly) {
        CMsgVector original = result;
        result = new CMsgVector();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CMsgVector MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CMsgVector.Descriptor; }
    }
    
    public override CMsgVector DefaultInstanceForType {
      get { return global::CMsgVector.DefaultInstance; }
    }
    
    public override CMsgVector BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CMsgVector) {
        return MergeFrom((CMsgVector) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CMsgVector other) {
      if (other == global::CMsgVector.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasX) {
        X = other.X;
      }
      if (other.HasY) {
        Y = other.Y;
      }
      if (other.HasZ) {
        Z = other.Z;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cMsgVectorFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cMsgVectorFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 13: {
            result.hasX = input.ReadFloat(ref result.x_);
            break;
          }
          case 21: {
            result.hasY = input.ReadFloat(ref result.y_);
            break;
          }
          case 29: {
            result.hasZ = input.ReadFloat(ref result.z_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasX {
      get { return result.hasX; }
    }
    public float X {
      get { return result.X; }
      set { SetX(value); }
    }
    public Builder SetX(float value) {
      PrepareBuilder();
      result.hasX = true;
      result.x_ = value;
      return this;
    }
    public Builder ClearX() {
      PrepareBuilder();
      result.hasX = false;
      result.x_ = 0F;
      return this;
    }
    
    public bool HasY {
      get { return result.hasY; }
    }
    public float Y {
      get { return result.Y; }
      set { SetY(value); }
    }
    public Builder SetY(float value) {
      PrepareBuilder();
      result.hasY = true;
      result.y_ = value;
      return this;
    }
    public Builder ClearY() {
      PrepareBuilder();
      result.hasY = false;
      result.y_ = 0F;
      return this;
    }
    
    public bool HasZ {
      get { return result.hasZ; }
    }
    public float Z {
      get { return result.Z; }
      set { SetZ(value); }
    }
    public Builder SetZ(float value) {
      PrepareBuilder();
      result.hasZ = true;
      result.z_ = value;
      return this;
    }
    public Builder ClearZ() {
      PrepareBuilder();
      result.hasZ = false;
      result.z_ = 0F;
      return this;
    }
  }
  static CMsgVector() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CMsgVector2D : pb::GeneratedMessage<CMsgVector2D, CMsgVector2D.Builder> {
  private CMsgVector2D() { }
  private static readonly CMsgVector2D defaultInstance = new CMsgVector2D().MakeReadOnly();
  private static readonly string[] _cMsgVector2DFieldNames = new string[] { "x", "y" };
  private static readonly uint[] _cMsgVector2DFieldTags = new uint[] { 13, 21 };
  public static CMsgVector2D DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CMsgVector2D DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CMsgVector2D ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CMsgVector2D__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CMsgVector2D, CMsgVector2D.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CMsgVector2D__FieldAccessorTable; }
  }
  
  public const int XFieldNumber = 1;
  private bool hasX;
  private float x_;
  public bool HasX {
    get { return hasX; }
  }
  public float X {
    get { return x_; }
  }
  
  public const int YFieldNumber = 2;
  private bool hasY;
  private float y_;
  public bool HasY {
    get { return hasY; }
  }
  public float Y {
    get { return y_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cMsgVector2DFieldNames;
    if (hasX) {
      output.WriteFloat(1, field_names[0], X);
    }
    if (hasY) {
      output.WriteFloat(2, field_names[1], Y);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasX) {
        size += pb::CodedOutputStream.ComputeFloatSize(1, X);
      }
      if (hasY) {
        size += pb::CodedOutputStream.ComputeFloatSize(2, Y);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CMsgVector2D ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CMsgVector2D ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CMsgVector2D ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CMsgVector2D ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CMsgVector2D ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CMsgVector2D ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CMsgVector2D ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CMsgVector2D ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CMsgVector2D ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CMsgVector2D ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CMsgVector2D MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CMsgVector2D prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CMsgVector2D, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CMsgVector2D cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CMsgVector2D result;
    
    private CMsgVector2D PrepareBuilder() {
      if (resultIsReadOnly) {
        CMsgVector2D original = result;
        result = new CMsgVector2D();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CMsgVector2D MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CMsgVector2D.Descriptor; }
    }
    
    public override CMsgVector2D DefaultInstanceForType {
      get { return global::CMsgVector2D.DefaultInstance; }
    }
    
    public override CMsgVector2D BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CMsgVector2D) {
        return MergeFrom((CMsgVector2D) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CMsgVector2D other) {
      if (other == global::CMsgVector2D.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasX) {
        X = other.X;
      }
      if (other.HasY) {
        Y = other.Y;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cMsgVector2DFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cMsgVector2DFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 13: {
            result.hasX = input.ReadFloat(ref result.x_);
            break;
          }
          case 21: {
            result.hasY = input.ReadFloat(ref result.y_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasX {
      get { return result.hasX; }
    }
    public float X {
      get { return result.X; }
      set { SetX(value); }
    }
    public Builder SetX(float value) {
      PrepareBuilder();
      result.hasX = true;
      result.x_ = value;
      return this;
    }
    public Builder ClearX() {
      PrepareBuilder();
      result.hasX = false;
      result.x_ = 0F;
      return this;
    }
    
    public bool HasY {
      get { return result.hasY; }
    }
    public float Y {
      get { return result.Y; }
      set { SetY(value); }
    }
    public Builder SetY(float value) {
      PrepareBuilder();
      result.hasY = true;
      result.y_ = value;
      return this;
    }
    public Builder ClearY() {
      PrepareBuilder();
      result.hasY = false;
      result.y_ = 0F;
      return this;
    }
  }
  static CMsgVector2D() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CMsgQAngle : pb::GeneratedMessage<CMsgQAngle, CMsgQAngle.Builder> {
  private CMsgQAngle() { }
  private static readonly CMsgQAngle defaultInstance = new CMsgQAngle().MakeReadOnly();
  private static readonly string[] _cMsgQAngleFieldNames = new string[] { "x", "y", "z" };
  private static readonly uint[] _cMsgQAngleFieldTags = new uint[] { 13, 21, 29 };
  public static CMsgQAngle DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CMsgQAngle DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CMsgQAngle ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CMsgQAngle__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CMsgQAngle, CMsgQAngle.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CMsgQAngle__FieldAccessorTable; }
  }
  
  public const int XFieldNumber = 1;
  private bool hasX;
  private float x_;
  public bool HasX {
    get { return hasX; }
  }
  public float X {
    get { return x_; }
  }
  
  public const int YFieldNumber = 2;
  private bool hasY;
  private float y_;
  public bool HasY {
    get { return hasY; }
  }
  public float Y {
    get { return y_; }
  }
  
  public const int ZFieldNumber = 3;
  private bool hasZ;
  private float z_;
  public bool HasZ {
    get { return hasZ; }
  }
  public float Z {
    get { return z_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cMsgQAngleFieldNames;
    if (hasX) {
      output.WriteFloat(1, field_names[0], X);
    }
    if (hasY) {
      output.WriteFloat(2, field_names[1], Y);
    }
    if (hasZ) {
      output.WriteFloat(3, field_names[2], Z);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasX) {
        size += pb::CodedOutputStream.ComputeFloatSize(1, X);
      }
      if (hasY) {
        size += pb::CodedOutputStream.ComputeFloatSize(2, Y);
      }
      if (hasZ) {
        size += pb::CodedOutputStream.ComputeFloatSize(3, Z);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CMsgQAngle ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CMsgQAngle ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CMsgQAngle ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CMsgQAngle ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CMsgQAngle ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CMsgQAngle ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CMsgQAngle ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CMsgQAngle ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CMsgQAngle ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CMsgQAngle ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CMsgQAngle MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CMsgQAngle prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CMsgQAngle, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CMsgQAngle cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CMsgQAngle result;
    
    private CMsgQAngle PrepareBuilder() {
      if (resultIsReadOnly) {
        CMsgQAngle original = result;
        result = new CMsgQAngle();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CMsgQAngle MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CMsgQAngle.Descriptor; }
    }
    
    public override CMsgQAngle DefaultInstanceForType {
      get { return global::CMsgQAngle.DefaultInstance; }
    }
    
    public override CMsgQAngle BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CMsgQAngle) {
        return MergeFrom((CMsgQAngle) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CMsgQAngle other) {
      if (other == global::CMsgQAngle.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasX) {
        X = other.X;
      }
      if (other.HasY) {
        Y = other.Y;
      }
      if (other.HasZ) {
        Z = other.Z;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cMsgQAngleFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cMsgQAngleFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 13: {
            result.hasX = input.ReadFloat(ref result.x_);
            break;
          }
          case 21: {
            result.hasY = input.ReadFloat(ref result.y_);
            break;
          }
          case 29: {
            result.hasZ = input.ReadFloat(ref result.z_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasX {
      get { return result.hasX; }
    }
    public float X {
      get { return result.X; }
      set { SetX(value); }
    }
    public Builder SetX(float value) {
      PrepareBuilder();
      result.hasX = true;
      result.x_ = value;
      return this;
    }
    public Builder ClearX() {
      PrepareBuilder();
      result.hasX = false;
      result.x_ = 0F;
      return this;
    }
    
    public bool HasY {
      get { return result.hasY; }
    }
    public float Y {
      get { return result.Y; }
      set { SetY(value); }
    }
    public Builder SetY(float value) {
      PrepareBuilder();
      result.hasY = true;
      result.y_ = value;
      return this;
    }
    public Builder ClearY() {
      PrepareBuilder();
      result.hasY = false;
      result.y_ = 0F;
      return this;
    }
    
    public bool HasZ {
      get { return result.hasZ; }
    }
    public float Z {
      get { return result.Z; }
      set { SetZ(value); }
    }
    public Builder SetZ(float value) {
      PrepareBuilder();
      result.hasZ = true;
      result.z_ = value;
      return this;
    }
    public Builder ClearZ() {
      PrepareBuilder();
      result.hasZ = false;
      result.z_ = 0F;
      return this;
    }
  }
  static CMsgQAngle() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CMsgRGBA : pb::GeneratedMessage<CMsgRGBA, CMsgRGBA.Builder> {
  private CMsgRGBA() { }
  private static readonly CMsgRGBA defaultInstance = new CMsgRGBA().MakeReadOnly();
  private static readonly string[] _cMsgRGBAFieldNames = new string[] { "a", "b", "g", "r" };
  private static readonly uint[] _cMsgRGBAFieldTags = new uint[] { 32, 24, 16, 8 };
  public static CMsgRGBA DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CMsgRGBA DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CMsgRGBA ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CMsgRGBA__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CMsgRGBA, CMsgRGBA.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CMsgRGBA__FieldAccessorTable; }
  }
  
  public const int RFieldNumber = 1;
  private bool hasR;
  private int r_;
  public bool HasR {
    get { return hasR; }
  }
  public int R {
    get { return r_; }
  }
  
  public const int GFieldNumber = 2;
  private bool hasG;
  private int g_;
  public bool HasG {
    get { return hasG; }
  }
  public int G {
    get { return g_; }
  }
  
  public const int BFieldNumber = 3;
  private bool hasB;
  private int b_;
  public bool HasB {
    get { return hasB; }
  }
  public int B {
    get { return b_; }
  }
  
  public const int AFieldNumber = 4;
  private bool hasA;
  private int a_;
  public bool HasA {
    get { return hasA; }
  }
  public int A {
    get { return a_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cMsgRGBAFieldNames;
    if (hasR) {
      output.WriteInt32(1, field_names[3], R);
    }
    if (hasG) {
      output.WriteInt32(2, field_names[2], G);
    }
    if (hasB) {
      output.WriteInt32(3, field_names[1], B);
    }
    if (hasA) {
      output.WriteInt32(4, field_names[0], A);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasR) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, R);
      }
      if (hasG) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, G);
      }
      if (hasB) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, B);
      }
      if (hasA) {
        size += pb::CodedOutputStream.ComputeInt32Size(4, A);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CMsgRGBA ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CMsgRGBA ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CMsgRGBA ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CMsgRGBA ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CMsgRGBA ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CMsgRGBA ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CMsgRGBA ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CMsgRGBA ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CMsgRGBA ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CMsgRGBA ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CMsgRGBA MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CMsgRGBA prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CMsgRGBA, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CMsgRGBA cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CMsgRGBA result;
    
    private CMsgRGBA PrepareBuilder() {
      if (resultIsReadOnly) {
        CMsgRGBA original = result;
        result = new CMsgRGBA();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CMsgRGBA MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CMsgRGBA.Descriptor; }
    }
    
    public override CMsgRGBA DefaultInstanceForType {
      get { return global::CMsgRGBA.DefaultInstance; }
    }
    
    public override CMsgRGBA BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CMsgRGBA) {
        return MergeFrom((CMsgRGBA) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CMsgRGBA other) {
      if (other == global::CMsgRGBA.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasR) {
        R = other.R;
      }
      if (other.HasG) {
        G = other.G;
      }
      if (other.HasB) {
        B = other.B;
      }
      if (other.HasA) {
        A = other.A;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cMsgRGBAFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cMsgRGBAFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasR = input.ReadInt32(ref result.r_);
            break;
          }
          case 16: {
            result.hasG = input.ReadInt32(ref result.g_);
            break;
          }
          case 24: {
            result.hasB = input.ReadInt32(ref result.b_);
            break;
          }
          case 32: {
            result.hasA = input.ReadInt32(ref result.a_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasR {
      get { return result.hasR; }
    }
    public int R {
      get { return result.R; }
      set { SetR(value); }
    }
    public Builder SetR(int value) {
      PrepareBuilder();
      result.hasR = true;
      result.r_ = value;
      return this;
    }
    public Builder ClearR() {
      PrepareBuilder();
      result.hasR = false;
      result.r_ = 0;
      return this;
    }
    
    public bool HasG {
      get { return result.hasG; }
    }
    public int G {
      get { return result.G; }
      set { SetG(value); }
    }
    public Builder SetG(int value) {
      PrepareBuilder();
      result.hasG = true;
      result.g_ = value;
      return this;
    }
    public Builder ClearG() {
      PrepareBuilder();
      result.hasG = false;
      result.g_ = 0;
      return this;
    }
    
    public bool HasB {
      get { return result.hasB; }
    }
    public int B {
      get { return result.B; }
      set { SetB(value); }
    }
    public Builder SetB(int value) {
      PrepareBuilder();
      result.hasB = true;
      result.b_ = value;
      return this;
    }
    public Builder ClearB() {
      PrepareBuilder();
      result.hasB = false;
      result.b_ = 0;
      return this;
    }
    
    public bool HasA {
      get { return result.hasA; }
    }
    public int A {
      get { return result.A; }
      set { SetA(value); }
    }
    public Builder SetA(int value) {
      PrepareBuilder();
      result.hasA = true;
      result.a_ = value;
      return this;
    }
    public Builder ClearA() {
      PrepareBuilder();
      result.hasA = false;
      result.a_ = 0;
      return this;
    }
  }
  static CMsgRGBA() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_Tick : pb::GeneratedMessage<CNETMsg_Tick, CNETMsg_Tick.Builder> {
  private CNETMsg_Tick() { }
  private static readonly CNETMsg_Tick defaultInstance = new CNETMsg_Tick().MakeReadOnly();
  private static readonly string[] _cNETMsgTickFieldNames = new string[] { "host_computationtime", "host_computationtime_std_deviation", "host_framestarttime_std_deviation", "tick" };
  private static readonly uint[] _cNETMsgTickFieldTags = new uint[] { 32, 40, 48, 8 };
  public static CNETMsg_Tick DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CNETMsg_Tick DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CNETMsg_Tick ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CNETMsg_Tick__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CNETMsg_Tick, CNETMsg_Tick.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CNETMsg_Tick__FieldAccessorTable; }
  }
  
  public const int TickFieldNumber = 1;
  private bool hasTick;
  private uint tick_;
  public bool HasTick {
    get { return hasTick; }
  }
  [global::System.CLSCompliant(false)]
  public uint Tick {
    get { return tick_; }
  }
  
  public const int HostComputationtimeFieldNumber = 4;
  private bool hasHostComputationtime;
  private uint hostComputationtime_;
  public bool HasHostComputationtime {
    get { return hasHostComputationtime; }
  }
  [global::System.CLSCompliant(false)]
  public uint HostComputationtime {
    get { return hostComputationtime_; }
  }
  
  public const int HostComputationtimeStdDeviationFieldNumber = 5;
  private bool hasHostComputationtimeStdDeviation;
  private uint hostComputationtimeStdDeviation_;
  public bool HasHostComputationtimeStdDeviation {
    get { return hasHostComputationtimeStdDeviation; }
  }
  [global::System.CLSCompliant(false)]
  public uint HostComputationtimeStdDeviation {
    get { return hostComputationtimeStdDeviation_; }
  }
  
  public const int HostFramestarttimeStdDeviationFieldNumber = 6;
  private bool hasHostFramestarttimeStdDeviation;
  private uint hostFramestarttimeStdDeviation_;
  public bool HasHostFramestarttimeStdDeviation {
    get { return hasHostFramestarttimeStdDeviation; }
  }
  [global::System.CLSCompliant(false)]
  public uint HostFramestarttimeStdDeviation {
    get { return hostFramestarttimeStdDeviation_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cNETMsgTickFieldNames;
    if (hasTick) {
      output.WriteUInt32(1, field_names[3], Tick);
    }
    if (hasHostComputationtime) {
      output.WriteUInt32(4, field_names[0], HostComputationtime);
    }
    if (hasHostComputationtimeStdDeviation) {
      output.WriteUInt32(5, field_names[1], HostComputationtimeStdDeviation);
    }
    if (hasHostFramestarttimeStdDeviation) {
      output.WriteUInt32(6, field_names[2], HostFramestarttimeStdDeviation);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasTick) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, Tick);
      }
      if (hasHostComputationtime) {
        size += pb::CodedOutputStream.ComputeUInt32Size(4, HostComputationtime);
      }
      if (hasHostComputationtimeStdDeviation) {
        size += pb::CodedOutputStream.ComputeUInt32Size(5, HostComputationtimeStdDeviation);
      }
      if (hasHostFramestarttimeStdDeviation) {
        size += pb::CodedOutputStream.ComputeUInt32Size(6, HostFramestarttimeStdDeviation);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CNETMsg_Tick ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_Tick ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_Tick ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_Tick ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_Tick ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_Tick ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_Tick ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CNETMsg_Tick ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CNETMsg_Tick ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_Tick ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CNETMsg_Tick MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CNETMsg_Tick prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CNETMsg_Tick, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CNETMsg_Tick cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CNETMsg_Tick result;
    
    private CNETMsg_Tick PrepareBuilder() {
      if (resultIsReadOnly) {
        CNETMsg_Tick original = result;
        result = new CNETMsg_Tick();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CNETMsg_Tick MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CNETMsg_Tick.Descriptor; }
    }
    
    public override CNETMsg_Tick DefaultInstanceForType {
      get { return global::CNETMsg_Tick.DefaultInstance; }
    }
    
    public override CNETMsg_Tick BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CNETMsg_Tick) {
        return MergeFrom((CNETMsg_Tick) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CNETMsg_Tick other) {
      if (other == global::CNETMsg_Tick.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasTick) {
        Tick = other.Tick;
      }
      if (other.HasHostComputationtime) {
        HostComputationtime = other.HostComputationtime;
      }
      if (other.HasHostComputationtimeStdDeviation) {
        HostComputationtimeStdDeviation = other.HostComputationtimeStdDeviation;
      }
      if (other.HasHostFramestarttimeStdDeviation) {
        HostFramestarttimeStdDeviation = other.HostFramestarttimeStdDeviation;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cNETMsgTickFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cNETMsgTickFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasTick = input.ReadUInt32(ref result.tick_);
            break;
          }
          case 32: {
            result.hasHostComputationtime = input.ReadUInt32(ref result.hostComputationtime_);
            break;
          }
          case 40: {
            result.hasHostComputationtimeStdDeviation = input.ReadUInt32(ref result.hostComputationtimeStdDeviation_);
            break;
          }
          case 48: {
            result.hasHostFramestarttimeStdDeviation = input.ReadUInt32(ref result.hostFramestarttimeStdDeviation_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasTick {
      get { return result.hasTick; }
    }
    [global::System.CLSCompliant(false)]
    public uint Tick {
      get { return result.Tick; }
      set { SetTick(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetTick(uint value) {
      PrepareBuilder();
      result.hasTick = true;
      result.tick_ = value;
      return this;
    }
    public Builder ClearTick() {
      PrepareBuilder();
      result.hasTick = false;
      result.tick_ = 0;
      return this;
    }
    
    public bool HasHostComputationtime {
      get { return result.hasHostComputationtime; }
    }
    [global::System.CLSCompliant(false)]
    public uint HostComputationtime {
      get { return result.HostComputationtime; }
      set { SetHostComputationtime(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetHostComputationtime(uint value) {
      PrepareBuilder();
      result.hasHostComputationtime = true;
      result.hostComputationtime_ = value;
      return this;
    }
    public Builder ClearHostComputationtime() {
      PrepareBuilder();
      result.hasHostComputationtime = false;
      result.hostComputationtime_ = 0;
      return this;
    }
    
    public bool HasHostComputationtimeStdDeviation {
      get { return result.hasHostComputationtimeStdDeviation; }
    }
    [global::System.CLSCompliant(false)]
    public uint HostComputationtimeStdDeviation {
      get { return result.HostComputationtimeStdDeviation; }
      set { SetHostComputationtimeStdDeviation(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetHostComputationtimeStdDeviation(uint value) {
      PrepareBuilder();
      result.hasHostComputationtimeStdDeviation = true;
      result.hostComputationtimeStdDeviation_ = value;
      return this;
    }
    public Builder ClearHostComputationtimeStdDeviation() {
      PrepareBuilder();
      result.hasHostComputationtimeStdDeviation = false;
      result.hostComputationtimeStdDeviation_ = 0;
      return this;
    }
    
    public bool HasHostFramestarttimeStdDeviation {
      get { return result.hasHostFramestarttimeStdDeviation; }
    }
    [global::System.CLSCompliant(false)]
    public uint HostFramestarttimeStdDeviation {
      get { return result.HostFramestarttimeStdDeviation; }
      set { SetHostFramestarttimeStdDeviation(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetHostFramestarttimeStdDeviation(uint value) {
      PrepareBuilder();
      result.hasHostFramestarttimeStdDeviation = true;
      result.hostFramestarttimeStdDeviation_ = value;
      return this;
    }
    public Builder ClearHostFramestarttimeStdDeviation() {
      PrepareBuilder();
      result.hasHostFramestarttimeStdDeviation = false;
      result.hostFramestarttimeStdDeviation_ = 0;
      return this;
    }
  }
  static CNETMsg_Tick() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_StringCmd : pb::GeneratedMessage<CNETMsg_StringCmd, CNETMsg_StringCmd.Builder> {
  private CNETMsg_StringCmd() { }
  private static readonly CNETMsg_StringCmd defaultInstance = new CNETMsg_StringCmd().MakeReadOnly();
  private static readonly string[] _cNETMsgStringCmdFieldNames = new string[] { "command" };
  private static readonly uint[] _cNETMsgStringCmdFieldTags = new uint[] { 10 };
  public static CNETMsg_StringCmd DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CNETMsg_StringCmd DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CNETMsg_StringCmd ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CNETMsg_StringCmd__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CNETMsg_StringCmd, CNETMsg_StringCmd.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CNETMsg_StringCmd__FieldAccessorTable; }
  }
  
  public const int CommandFieldNumber = 1;
  private bool hasCommand;
  private string command_ = "";
  public bool HasCommand {
    get { return hasCommand; }
  }
  public string Command {
    get { return command_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cNETMsgStringCmdFieldNames;
    if (hasCommand) {
      output.WriteString(1, field_names[0], Command);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCommand) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Command);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CNETMsg_StringCmd ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_StringCmd ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_StringCmd ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_StringCmd ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_StringCmd ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_StringCmd ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_StringCmd ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CNETMsg_StringCmd ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CNETMsg_StringCmd ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_StringCmd ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CNETMsg_StringCmd MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CNETMsg_StringCmd prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CNETMsg_StringCmd, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CNETMsg_StringCmd cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CNETMsg_StringCmd result;
    
    private CNETMsg_StringCmd PrepareBuilder() {
      if (resultIsReadOnly) {
        CNETMsg_StringCmd original = result;
        result = new CNETMsg_StringCmd();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CNETMsg_StringCmd MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CNETMsg_StringCmd.Descriptor; }
    }
    
    public override CNETMsg_StringCmd DefaultInstanceForType {
      get { return global::CNETMsg_StringCmd.DefaultInstance; }
    }
    
    public override CNETMsg_StringCmd BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CNETMsg_StringCmd) {
        return MergeFrom((CNETMsg_StringCmd) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CNETMsg_StringCmd other) {
      if (other == global::CNETMsg_StringCmd.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasCommand) {
        Command = other.Command;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cNETMsgStringCmdFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cNETMsgStringCmdFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasCommand = input.ReadString(ref result.command_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasCommand {
      get { return result.hasCommand; }
    }
    public string Command {
      get { return result.Command; }
      set { SetCommand(value); }
    }
    public Builder SetCommand(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasCommand = true;
      result.command_ = value;
      return this;
    }
    public Builder ClearCommand() {
      PrepareBuilder();
      result.hasCommand = false;
      result.command_ = "";
      return this;
    }
  }
  static CNETMsg_StringCmd() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_SignonState : pb::GeneratedMessage<CNETMsg_SignonState, CNETMsg_SignonState.Builder> {
  private CNETMsg_SignonState() { }
  private static readonly CNETMsg_SignonState defaultInstance = new CNETMsg_SignonState().MakeReadOnly();
  private static readonly string[] _cNETMsgSignonStateFieldNames = new string[] { "map_name", "num_server_players", "players_networkids", "signon_state", "spawn_count" };
  private static readonly uint[] _cNETMsgSignonStateFieldTags = new uint[] { 42, 24, 34, 8, 16 };
  public static CNETMsg_SignonState DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CNETMsg_SignonState DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CNETMsg_SignonState ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CNETMsg_SignonState__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CNETMsg_SignonState, CNETMsg_SignonState.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CNETMsg_SignonState__FieldAccessorTable; }
  }
  
  public const int SignonStateFieldNumber = 1;
  private bool hasSignonState;
  private uint signonState_;
  public bool HasSignonState {
    get { return hasSignonState; }
  }
  [global::System.CLSCompliant(false)]
  public uint SignonState {
    get { return signonState_; }
  }
  
  public const int SpawnCountFieldNumber = 2;
  private bool hasSpawnCount;
  private uint spawnCount_;
  public bool HasSpawnCount {
    get { return hasSpawnCount; }
  }
  [global::System.CLSCompliant(false)]
  public uint SpawnCount {
    get { return spawnCount_; }
  }
  
  public const int NumServerPlayersFieldNumber = 3;
  private bool hasNumServerPlayers;
  private uint numServerPlayers_;
  public bool HasNumServerPlayers {
    get { return hasNumServerPlayers; }
  }
  [global::System.CLSCompliant(false)]
  public uint NumServerPlayers {
    get { return numServerPlayers_; }
  }
  
  public const int PlayersNetworkidsFieldNumber = 4;
  private pbc::PopsicleList<string> playersNetworkids_ = new pbc::PopsicleList<string>();
  public scg::IList<string> PlayersNetworkidsList {
    get { return pbc::Lists.AsReadOnly(playersNetworkids_); }
  }
  public int PlayersNetworkidsCount {
    get { return playersNetworkids_.Count; }
  }
  public string GetPlayersNetworkids(int index) {
    return playersNetworkids_[index];
  }
  
  public const int MapNameFieldNumber = 5;
  private bool hasMapName;
  private string mapName_ = "";
  public bool HasMapName {
    get { return hasMapName; }
  }
  public string MapName {
    get { return mapName_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cNETMsgSignonStateFieldNames;
    if (hasSignonState) {
      output.WriteUInt32(1, field_names[3], SignonState);
    }
    if (hasSpawnCount) {
      output.WriteUInt32(2, field_names[4], SpawnCount);
    }
    if (hasNumServerPlayers) {
      output.WriteUInt32(3, field_names[1], NumServerPlayers);
    }
    if (playersNetworkids_.Count > 0) {
      output.WriteStringArray(4, field_names[2], playersNetworkids_);
    }
    if (hasMapName) {
      output.WriteString(5, field_names[0], MapName);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSignonState) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, SignonState);
      }
      if (hasSpawnCount) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, SpawnCount);
      }
      if (hasNumServerPlayers) {
        size += pb::CodedOutputStream.ComputeUInt32Size(3, NumServerPlayers);
      }
      {
        int dataSize = 0;
        foreach (string element in PlayersNetworkidsList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * playersNetworkids_.Count;
      }
      if (hasMapName) {
        size += pb::CodedOutputStream.ComputeStringSize(5, MapName);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CNETMsg_SignonState ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_SignonState ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_SignonState ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_SignonState ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_SignonState ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_SignonState ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_SignonState ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CNETMsg_SignonState ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CNETMsg_SignonState ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_SignonState ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CNETMsg_SignonState MakeReadOnly() {
    playersNetworkids_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CNETMsg_SignonState prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CNETMsg_SignonState, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CNETMsg_SignonState cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CNETMsg_SignonState result;
    
    private CNETMsg_SignonState PrepareBuilder() {
      if (resultIsReadOnly) {
        CNETMsg_SignonState original = result;
        result = new CNETMsg_SignonState();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CNETMsg_SignonState MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CNETMsg_SignonState.Descriptor; }
    }
    
    public override CNETMsg_SignonState DefaultInstanceForType {
      get { return global::CNETMsg_SignonState.DefaultInstance; }
    }
    
    public override CNETMsg_SignonState BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CNETMsg_SignonState) {
        return MergeFrom((CNETMsg_SignonState) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CNETMsg_SignonState other) {
      if (other == global::CNETMsg_SignonState.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasSignonState) {
        SignonState = other.SignonState;
      }
      if (other.HasSpawnCount) {
        SpawnCount = other.SpawnCount;
      }
      if (other.HasNumServerPlayers) {
        NumServerPlayers = other.NumServerPlayers;
      }
      if (other.playersNetworkids_.Count != 0) {
        result.playersNetworkids_.Add(other.playersNetworkids_);
      }
      if (other.HasMapName) {
        MapName = other.MapName;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cNETMsgSignonStateFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cNETMsgSignonStateFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasSignonState = input.ReadUInt32(ref result.signonState_);
            break;
          }
          case 16: {
            result.hasSpawnCount = input.ReadUInt32(ref result.spawnCount_);
            break;
          }
          case 24: {
            result.hasNumServerPlayers = input.ReadUInt32(ref result.numServerPlayers_);
            break;
          }
          case 34: {
            input.ReadStringArray(tag, field_name, result.playersNetworkids_);
            break;
          }
          case 42: {
            result.hasMapName = input.ReadString(ref result.mapName_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasSignonState {
      get { return result.hasSignonState; }
    }
    [global::System.CLSCompliant(false)]
    public uint SignonState {
      get { return result.SignonState; }
      set { SetSignonState(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetSignonState(uint value) {
      PrepareBuilder();
      result.hasSignonState = true;
      result.signonState_ = value;
      return this;
    }
    public Builder ClearSignonState() {
      PrepareBuilder();
      result.hasSignonState = false;
      result.signonState_ = 0;
      return this;
    }
    
    public bool HasSpawnCount {
      get { return result.hasSpawnCount; }
    }
    [global::System.CLSCompliant(false)]
    public uint SpawnCount {
      get { return result.SpawnCount; }
      set { SetSpawnCount(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetSpawnCount(uint value) {
      PrepareBuilder();
      result.hasSpawnCount = true;
      result.spawnCount_ = value;
      return this;
    }
    public Builder ClearSpawnCount() {
      PrepareBuilder();
      result.hasSpawnCount = false;
      result.spawnCount_ = 0;
      return this;
    }
    
    public bool HasNumServerPlayers {
      get { return result.hasNumServerPlayers; }
    }
    [global::System.CLSCompliant(false)]
    public uint NumServerPlayers {
      get { return result.NumServerPlayers; }
      set { SetNumServerPlayers(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetNumServerPlayers(uint value) {
      PrepareBuilder();
      result.hasNumServerPlayers = true;
      result.numServerPlayers_ = value;
      return this;
    }
    public Builder ClearNumServerPlayers() {
      PrepareBuilder();
      result.hasNumServerPlayers = false;
      result.numServerPlayers_ = 0;
      return this;
    }
    
    public pbc::IPopsicleList<string> PlayersNetworkidsList {
      get { return PrepareBuilder().playersNetworkids_; }
    }
    public int PlayersNetworkidsCount {
      get { return result.PlayersNetworkidsCount; }
    }
    public string GetPlayersNetworkids(int index) {
      return result.GetPlayersNetworkids(index);
    }
    public Builder SetPlayersNetworkids(int index, string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.playersNetworkids_[index] = value;
      return this;
    }
    public Builder AddPlayersNetworkids(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.playersNetworkids_.Add(value);
      return this;
    }
    public Builder AddRangePlayersNetworkids(scg::IEnumerable<string> values) {
      PrepareBuilder();
      result.playersNetworkids_.Add(values);
      return this;
    }
    public Builder ClearPlayersNetworkids() {
      PrepareBuilder();
      result.playersNetworkids_.Clear();
      return this;
    }
    
    public bool HasMapName {
      get { return result.hasMapName; }
    }
    public string MapName {
      get { return result.MapName; }
      set { SetMapName(value); }
    }
    public Builder SetMapName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasMapName = true;
      result.mapName_ = value;
      return this;
    }
    public Builder ClearMapName() {
      PrepareBuilder();
      result.hasMapName = false;
      result.mapName_ = "";
      return this;
    }
  }
  static CNETMsg_SignonState() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CMsg_CVars : pb::GeneratedMessage<CMsg_CVars, CMsg_CVars.Builder> {
  private CMsg_CVars() { }
  private static readonly CMsg_CVars defaultInstance = new CMsg_CVars().MakeReadOnly();
  private static readonly string[] _cMsgCVarsFieldNames = new string[] { "cvars" };
  private static readonly uint[] _cMsgCVarsFieldTags = new uint[] { 10 };
  public static CMsg_CVars DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CMsg_CVars DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CMsg_CVars ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CMsg_CVars__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CMsg_CVars, CMsg_CVars.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CMsg_CVars__FieldAccessorTable; }
  }
  
  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class CVar : pb::GeneratedMessage<CVar, CVar.Builder> {
      private CVar() { }
      private static readonly CVar defaultInstance = new CVar().MakeReadOnly();
      private static readonly string[] _cVarFieldNames = new string[] { "name", "value" };
      private static readonly uint[] _cVarFieldTags = new uint[] { 10, 18 };
      public static CVar DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override CVar DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override CVar ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Netmessages.internal__static_CMsg_CVars_CVar__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<CVar, CVar.Builder> InternalFieldAccessors {
        get { return global::Netmessages.internal__static_CMsg_CVars_CVar__FieldAccessorTable; }
      }
      
      public const int NameFieldNumber = 1;
      private bool hasName;
      private string name_ = "";
      public bool HasName {
        get { return hasName; }
      }
      public string Name {
        get { return name_; }
      }
      
      public const int ValueFieldNumber = 2;
      private bool hasValue;
      private string value_ = "";
      public bool HasValue {
        get { return hasValue; }
      }
      public string Value {
        get { return value_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _cVarFieldNames;
        if (hasName) {
          output.WriteString(1, field_names[0], Name);
        }
        if (hasValue) {
          output.WriteString(2, field_names[1], Value);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasName) {
            size += pb::CodedOutputStream.ComputeStringSize(1, Name);
          }
          if (hasValue) {
            size += pb::CodedOutputStream.ComputeStringSize(2, Value);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static CVar ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static CVar ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static CVar ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static CVar ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static CVar ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static CVar ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static CVar ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static CVar ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static CVar ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static CVar ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private CVar MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(CVar prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<CVar, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(CVar cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private CVar result;
        
        private CVar PrepareBuilder() {
          if (resultIsReadOnly) {
            CVar original = result;
            result = new CVar();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override CVar MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::CMsg_CVars.Types.CVar.Descriptor; }
        }
        
        public override CVar DefaultInstanceForType {
          get { return global::CMsg_CVars.Types.CVar.DefaultInstance; }
        }
        
        public override CVar BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is CVar) {
            return MergeFrom((CVar) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(CVar other) {
          if (other == global::CMsg_CVars.Types.CVar.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasName) {
            Name = other.Name;
          }
          if (other.HasValue) {
            Value = other.Value;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_cVarFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _cVarFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 10: {
                result.hasName = input.ReadString(ref result.name_);
                break;
              }
              case 18: {
                result.hasValue = input.ReadString(ref result.value_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasName {
          get { return result.hasName; }
        }
        public string Name {
          get { return result.Name; }
          set { SetName(value); }
        }
        public Builder SetName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasName = true;
          result.name_ = value;
          return this;
        }
        public Builder ClearName() {
          PrepareBuilder();
          result.hasName = false;
          result.name_ = "";
          return this;
        }
        
        public bool HasValue {
          get { return result.hasValue; }
        }
        public string Value {
          get { return result.Value; }
          set { SetValue(value); }
        }
        public Builder SetValue(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasValue = true;
          result.value_ = value;
          return this;
        }
        public Builder ClearValue() {
          PrepareBuilder();
          result.hasValue = false;
          result.value_ = "";
          return this;
        }
      }
      static CVar() {
        object.ReferenceEquals(global::Netmessages.Descriptor, null);
      }
    }
    
  }
  #endregion
  
  public const int CvarsFieldNumber = 1;
  private pbc::PopsicleList<global::CMsg_CVars.Types.CVar> cvars_ = new pbc::PopsicleList<global::CMsg_CVars.Types.CVar>();
  public scg::IList<global::CMsg_CVars.Types.CVar> CvarsList {
    get { return cvars_; }
  }
  public int CvarsCount {
    get { return cvars_.Count; }
  }
  public global::CMsg_CVars.Types.CVar GetCvars(int index) {
    return cvars_[index];
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cMsgCVarsFieldNames;
    if (cvars_.Count > 0) {
      output.WriteMessageArray(1, field_names[0], cvars_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::CMsg_CVars.Types.CVar element in CvarsList) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CMsg_CVars ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CMsg_CVars ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CMsg_CVars ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CMsg_CVars ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CMsg_CVars ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CMsg_CVars ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CMsg_CVars ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CMsg_CVars ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CMsg_CVars ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CMsg_CVars ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CMsg_CVars MakeReadOnly() {
    cvars_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CMsg_CVars prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CMsg_CVars, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CMsg_CVars cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CMsg_CVars result;
    
    private CMsg_CVars PrepareBuilder() {
      if (resultIsReadOnly) {
        CMsg_CVars original = result;
        result = new CMsg_CVars();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CMsg_CVars MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CMsg_CVars.Descriptor; }
    }
    
    public override CMsg_CVars DefaultInstanceForType {
      get { return global::CMsg_CVars.DefaultInstance; }
    }
    
    public override CMsg_CVars BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CMsg_CVars) {
        return MergeFrom((CMsg_CVars) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CMsg_CVars other) {
      if (other == global::CMsg_CVars.DefaultInstance) return this;
      PrepareBuilder();
      if (other.cvars_.Count != 0) {
        result.cvars_.Add(other.cvars_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cMsgCVarsFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cMsgCVarsFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            input.ReadMessageArray(tag, field_name, result.cvars_, global::CMsg_CVars.Types.CVar.DefaultInstance, extensionRegistry);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public pbc::IPopsicleList<global::CMsg_CVars.Types.CVar> CvarsList {
      get { return PrepareBuilder().cvars_; }
    }
    public int CvarsCount {
      get { return result.CvarsCount; }
    }
    public global::CMsg_CVars.Types.CVar GetCvars(int index) {
      return result.GetCvars(index);
    }
    public Builder SetCvars(int index, global::CMsg_CVars.Types.CVar value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.cvars_[index] = value;
      return this;
    }
    public Builder SetCvars(int index, global::CMsg_CVars.Types.CVar.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.cvars_[index] = builderForValue.Build();
      return this;
    }
    public Builder AddCvars(global::CMsg_CVars.Types.CVar value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.cvars_.Add(value);
      return this;
    }
    public Builder AddCvars(global::CMsg_CVars.Types.CVar.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.cvars_.Add(builderForValue.Build());
      return this;
    }
    public Builder AddRangeCvars(scg::IEnumerable<global::CMsg_CVars.Types.CVar> values) {
      PrepareBuilder();
      result.cvars_.Add(values);
      return this;
    }
    public Builder ClearCvars() {
      PrepareBuilder();
      result.cvars_.Clear();
      return this;
    }
  }
  static CMsg_CVars() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_SetConVar : pb::GeneratedMessage<CNETMsg_SetConVar, CNETMsg_SetConVar.Builder> {
  private CNETMsg_SetConVar() { }
  private static readonly CNETMsg_SetConVar defaultInstance = new CNETMsg_SetConVar().MakeReadOnly();
  private static readonly string[] _cNETMsgSetConVarFieldNames = new string[] { "convars" };
  private static readonly uint[] _cNETMsgSetConVarFieldTags = new uint[] { 10 };
  public static CNETMsg_SetConVar DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CNETMsg_SetConVar DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CNETMsg_SetConVar ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CNETMsg_SetConVar__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CNETMsg_SetConVar, CNETMsg_SetConVar.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CNETMsg_SetConVar__FieldAccessorTable; }
  }
  
  public const int ConvarsFieldNumber = 1;
  private bool hasConvars;
  private global::CMsg_CVars convars_;
  public bool HasConvars {
    get { return hasConvars; }
  }
  public global::CMsg_CVars Convars {
    get { return convars_ ?? global::CMsg_CVars.DefaultInstance; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cNETMsgSetConVarFieldNames;
    if (hasConvars) {
      output.WriteMessage(1, field_names[0], Convars);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasConvars) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Convars);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CNETMsg_SetConVar ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_SetConVar ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_SetConVar ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_SetConVar ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_SetConVar ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_SetConVar ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_SetConVar ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CNETMsg_SetConVar ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CNETMsg_SetConVar ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_SetConVar ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CNETMsg_SetConVar MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CNETMsg_SetConVar prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CNETMsg_SetConVar, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CNETMsg_SetConVar cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CNETMsg_SetConVar result;
    
    private CNETMsg_SetConVar PrepareBuilder() {
      if (resultIsReadOnly) {
        CNETMsg_SetConVar original = result;
        result = new CNETMsg_SetConVar();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CNETMsg_SetConVar MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CNETMsg_SetConVar.Descriptor; }
    }
    
    public override CNETMsg_SetConVar DefaultInstanceForType {
      get { return global::CNETMsg_SetConVar.DefaultInstance; }
    }
    
    public override CNETMsg_SetConVar BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CNETMsg_SetConVar) {
        return MergeFrom((CNETMsg_SetConVar) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CNETMsg_SetConVar other) {
      if (other == global::CNETMsg_SetConVar.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasConvars) {
        MergeConvars(other.Convars);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cNETMsgSetConVarFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cNETMsgSetConVarFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            global::CMsg_CVars.Builder subBuilder = global::CMsg_CVars.CreateBuilder();
            if (result.hasConvars) {
              subBuilder.MergeFrom(Convars);
            }
            input.ReadMessage(subBuilder, extensionRegistry);
            Convars = subBuilder.BuildPartial();
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasConvars {
     get { return result.hasConvars; }
    }
    public global::CMsg_CVars Convars {
      get { return result.Convars; }
      set { SetConvars(value); }
    }
    public Builder SetConvars(global::CMsg_CVars value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasConvars = true;
      result.convars_ = value;
      return this;
    }
    public Builder SetConvars(global::CMsg_CVars.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.hasConvars = true;
      result.convars_ = builderForValue.Build();
      return this;
    }
    public Builder MergeConvars(global::CMsg_CVars value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      if (result.hasConvars &&
          result.convars_ != global::CMsg_CVars.DefaultInstance) {
          result.convars_ = global::CMsg_CVars.CreateBuilder(result.convars_).MergeFrom(value).BuildPartial();
      } else {
        result.convars_ = value;
      }
      result.hasConvars = true;
      return this;
    }
    public Builder ClearConvars() {
      PrepareBuilder();
      result.hasConvars = false;
      result.convars_ = null;
      return this;
    }
  }
  static CNETMsg_SetConVar() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_NOP : pb::GeneratedMessage<CNETMsg_NOP, CNETMsg_NOP.Builder> {
  private CNETMsg_NOP() { }
  private static readonly CNETMsg_NOP defaultInstance = new CNETMsg_NOP().MakeReadOnly();
  private static readonly string[] _cNETMsgNOPFieldNames = new string[] {  };
  private static readonly uint[] _cNETMsgNOPFieldTags = new uint[] {  };
  public static CNETMsg_NOP DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CNETMsg_NOP DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CNETMsg_NOP ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CNETMsg_NOP__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CNETMsg_NOP, CNETMsg_NOP.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CNETMsg_NOP__FieldAccessorTable; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cNETMsgNOPFieldNames;
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CNETMsg_NOP ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_NOP ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_NOP ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_NOP ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_NOP ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_NOP ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_NOP ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CNETMsg_NOP ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CNETMsg_NOP ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_NOP ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CNETMsg_NOP MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CNETMsg_NOP prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CNETMsg_NOP, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CNETMsg_NOP cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CNETMsg_NOP result;
    
    private CNETMsg_NOP PrepareBuilder() {
      if (resultIsReadOnly) {
        CNETMsg_NOP original = result;
        result = new CNETMsg_NOP();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CNETMsg_NOP MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CNETMsg_NOP.Descriptor; }
    }
    
    public override CNETMsg_NOP DefaultInstanceForType {
      get { return global::CNETMsg_NOP.DefaultInstance; }
    }
    
    public override CNETMsg_NOP BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CNETMsg_NOP) {
        return MergeFrom((CNETMsg_NOP) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CNETMsg_NOP other) {
      if (other == global::CNETMsg_NOP.DefaultInstance) return this;
      PrepareBuilder();
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cNETMsgNOPFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cNETMsgNOPFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
  }
  static CNETMsg_NOP() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_Disconnect : pb::GeneratedMessage<CNETMsg_Disconnect, CNETMsg_Disconnect.Builder> {
  private CNETMsg_Disconnect() { }
  private static readonly CNETMsg_Disconnect defaultInstance = new CNETMsg_Disconnect().MakeReadOnly();
  private static readonly string[] _cNETMsgDisconnectFieldNames = new string[] { "text" };
  private static readonly uint[] _cNETMsgDisconnectFieldTags = new uint[] { 10 };
  public static CNETMsg_Disconnect DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CNETMsg_Disconnect DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CNETMsg_Disconnect ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CNETMsg_Disconnect__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CNETMsg_Disconnect, CNETMsg_Disconnect.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CNETMsg_Disconnect__FieldAccessorTable; }
  }
  
  public const int TextFieldNumber = 1;
  private bool hasText;
  private string text_ = "";
  public bool HasText {
    get { return hasText; }
  }
  public string Text {
    get { return text_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cNETMsgDisconnectFieldNames;
    if (hasText) {
      output.WriteString(1, field_names[0], Text);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasText) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Text);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CNETMsg_Disconnect ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_Disconnect ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_Disconnect ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_Disconnect ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_Disconnect ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_Disconnect ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_Disconnect ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CNETMsg_Disconnect ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CNETMsg_Disconnect ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_Disconnect ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CNETMsg_Disconnect MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CNETMsg_Disconnect prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CNETMsg_Disconnect, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CNETMsg_Disconnect cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CNETMsg_Disconnect result;
    
    private CNETMsg_Disconnect PrepareBuilder() {
      if (resultIsReadOnly) {
        CNETMsg_Disconnect original = result;
        result = new CNETMsg_Disconnect();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CNETMsg_Disconnect MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CNETMsg_Disconnect.Descriptor; }
    }
    
    public override CNETMsg_Disconnect DefaultInstanceForType {
      get { return global::CNETMsg_Disconnect.DefaultInstance; }
    }
    
    public override CNETMsg_Disconnect BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CNETMsg_Disconnect) {
        return MergeFrom((CNETMsg_Disconnect) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CNETMsg_Disconnect other) {
      if (other == global::CNETMsg_Disconnect.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasText) {
        Text = other.Text;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cNETMsgDisconnectFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cNETMsgDisconnectFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasText = input.ReadString(ref result.text_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasText {
      get { return result.hasText; }
    }
    public string Text {
      get { return result.Text; }
      set { SetText(value); }
    }
    public Builder SetText(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasText = true;
      result.text_ = value;
      return this;
    }
    public Builder ClearText() {
      PrepareBuilder();
      result.hasText = false;
      result.text_ = "";
      return this;
    }
  }
  static CNETMsg_Disconnect() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_File : pb::GeneratedMessage<CNETMsg_File, CNETMsg_File.Builder> {
  private CNETMsg_File() { }
  private static readonly CNETMsg_File defaultInstance = new CNETMsg_File().MakeReadOnly();
  private static readonly string[] _cNETMsgFileFieldNames = new string[] { "deny", "file_name", "is_replay_demo_file", "transfer_id" };
  private static readonly uint[] _cNETMsgFileFieldTags = new uint[] { 32, 18, 24, 8 };
  public static CNETMsg_File DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CNETMsg_File DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CNETMsg_File ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CNETMsg_File__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CNETMsg_File, CNETMsg_File.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CNETMsg_File__FieldAccessorTable; }
  }
  
  public const int TransferIdFieldNumber = 1;
  private bool hasTransferId;
  private int transferId_;
  public bool HasTransferId {
    get { return hasTransferId; }
  }
  public int TransferId {
    get { return transferId_; }
  }
  
  public const int FileNameFieldNumber = 2;
  private bool hasFileName;
  private string fileName_ = "";
  public bool HasFileName {
    get { return hasFileName; }
  }
  public string FileName {
    get { return fileName_; }
  }
  
  public const int IsReplayDemoFileFieldNumber = 3;
  private bool hasIsReplayDemoFile;
  private bool isReplayDemoFile_;
  public bool HasIsReplayDemoFile {
    get { return hasIsReplayDemoFile; }
  }
  public bool IsReplayDemoFile {
    get { return isReplayDemoFile_; }
  }
  
  public const int DenyFieldNumber = 4;
  private bool hasDeny;
  private bool deny_;
  public bool HasDeny {
    get { return hasDeny; }
  }
  public bool Deny {
    get { return deny_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cNETMsgFileFieldNames;
    if (hasTransferId) {
      output.WriteInt32(1, field_names[3], TransferId);
    }
    if (hasFileName) {
      output.WriteString(2, field_names[1], FileName);
    }
    if (hasIsReplayDemoFile) {
      output.WriteBool(3, field_names[2], IsReplayDemoFile);
    }
    if (hasDeny) {
      output.WriteBool(4, field_names[0], Deny);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasTransferId) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, TransferId);
      }
      if (hasFileName) {
        size += pb::CodedOutputStream.ComputeStringSize(2, FileName);
      }
      if (hasIsReplayDemoFile) {
        size += pb::CodedOutputStream.ComputeBoolSize(3, IsReplayDemoFile);
      }
      if (hasDeny) {
        size += pb::CodedOutputStream.ComputeBoolSize(4, Deny);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CNETMsg_File ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_File ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_File ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_File ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_File ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_File ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_File ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CNETMsg_File ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CNETMsg_File ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_File ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CNETMsg_File MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CNETMsg_File prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CNETMsg_File, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CNETMsg_File cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CNETMsg_File result;
    
    private CNETMsg_File PrepareBuilder() {
      if (resultIsReadOnly) {
        CNETMsg_File original = result;
        result = new CNETMsg_File();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CNETMsg_File MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CNETMsg_File.Descriptor; }
    }
    
    public override CNETMsg_File DefaultInstanceForType {
      get { return global::CNETMsg_File.DefaultInstance; }
    }
    
    public override CNETMsg_File BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CNETMsg_File) {
        return MergeFrom((CNETMsg_File) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CNETMsg_File other) {
      if (other == global::CNETMsg_File.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasTransferId) {
        TransferId = other.TransferId;
      }
      if (other.HasFileName) {
        FileName = other.FileName;
      }
      if (other.HasIsReplayDemoFile) {
        IsReplayDemoFile = other.IsReplayDemoFile;
      }
      if (other.HasDeny) {
        Deny = other.Deny;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cNETMsgFileFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cNETMsgFileFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasTransferId = input.ReadInt32(ref result.transferId_);
            break;
          }
          case 18: {
            result.hasFileName = input.ReadString(ref result.fileName_);
            break;
          }
          case 24: {
            result.hasIsReplayDemoFile = input.ReadBool(ref result.isReplayDemoFile_);
            break;
          }
          case 32: {
            result.hasDeny = input.ReadBool(ref result.deny_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasTransferId {
      get { return result.hasTransferId; }
    }
    public int TransferId {
      get { return result.TransferId; }
      set { SetTransferId(value); }
    }
    public Builder SetTransferId(int value) {
      PrepareBuilder();
      result.hasTransferId = true;
      result.transferId_ = value;
      return this;
    }
    public Builder ClearTransferId() {
      PrepareBuilder();
      result.hasTransferId = false;
      result.transferId_ = 0;
      return this;
    }
    
    public bool HasFileName {
      get { return result.hasFileName; }
    }
    public string FileName {
      get { return result.FileName; }
      set { SetFileName(value); }
    }
    public Builder SetFileName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasFileName = true;
      result.fileName_ = value;
      return this;
    }
    public Builder ClearFileName() {
      PrepareBuilder();
      result.hasFileName = false;
      result.fileName_ = "";
      return this;
    }
    
    public bool HasIsReplayDemoFile {
      get { return result.hasIsReplayDemoFile; }
    }
    public bool IsReplayDemoFile {
      get { return result.IsReplayDemoFile; }
      set { SetIsReplayDemoFile(value); }
    }
    public Builder SetIsReplayDemoFile(bool value) {
      PrepareBuilder();
      result.hasIsReplayDemoFile = true;
      result.isReplayDemoFile_ = value;
      return this;
    }
    public Builder ClearIsReplayDemoFile() {
      PrepareBuilder();
      result.hasIsReplayDemoFile = false;
      result.isReplayDemoFile_ = false;
      return this;
    }
    
    public bool HasDeny {
      get { return result.hasDeny; }
    }
    public bool Deny {
      get { return result.Deny; }
      set { SetDeny(value); }
    }
    public Builder SetDeny(bool value) {
      PrepareBuilder();
      result.hasDeny = true;
      result.deny_ = value;
      return this;
    }
    public Builder ClearDeny() {
      PrepareBuilder();
      result.hasDeny = false;
      result.deny_ = false;
      return this;
    }
  }
  static CNETMsg_File() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CNETMsg_SplitScreenUser : pb::GeneratedMessage<CNETMsg_SplitScreenUser, CNETMsg_SplitScreenUser.Builder> {
  private CNETMsg_SplitScreenUser() { }
  private static readonly CNETMsg_SplitScreenUser defaultInstance = new CNETMsg_SplitScreenUser().MakeReadOnly();
  private static readonly string[] _cNETMsgSplitScreenUserFieldNames = new string[] { "slot" };
  private static readonly uint[] _cNETMsgSplitScreenUserFieldTags = new uint[] { 8 };
  public static CNETMsg_SplitScreenUser DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CNETMsg_SplitScreenUser DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CNETMsg_SplitScreenUser ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CNETMsg_SplitScreenUser__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CNETMsg_SplitScreenUser, CNETMsg_SplitScreenUser.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CNETMsg_SplitScreenUser__FieldAccessorTable; }
  }
  
  public const int SlotFieldNumber = 1;
  private bool hasSlot;
  private int slot_;
  public bool HasSlot {
    get { return hasSlot; }
  }
  public int Slot {
    get { return slot_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cNETMsgSplitScreenUserFieldNames;
    if (hasSlot) {
      output.WriteInt32(1, field_names[0], Slot);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSlot) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, Slot);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CNETMsg_SplitScreenUser ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_SplitScreenUser ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_SplitScreenUser ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CNETMsg_SplitScreenUser ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_SplitScreenUser ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_SplitScreenUser ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CNETMsg_SplitScreenUser ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CNETMsg_SplitScreenUser ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CNETMsg_SplitScreenUser ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CNETMsg_SplitScreenUser ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CNETMsg_SplitScreenUser MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CNETMsg_SplitScreenUser prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CNETMsg_SplitScreenUser, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CNETMsg_SplitScreenUser cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CNETMsg_SplitScreenUser result;
    
    private CNETMsg_SplitScreenUser PrepareBuilder() {
      if (resultIsReadOnly) {
        CNETMsg_SplitScreenUser original = result;
        result = new CNETMsg_SplitScreenUser();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CNETMsg_SplitScreenUser MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CNETMsg_SplitScreenUser.Descriptor; }
    }
    
    public override CNETMsg_SplitScreenUser DefaultInstanceForType {
      get { return global::CNETMsg_SplitScreenUser.DefaultInstance; }
    }
    
    public override CNETMsg_SplitScreenUser BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CNETMsg_SplitScreenUser) {
        return MergeFrom((CNETMsg_SplitScreenUser) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CNETMsg_SplitScreenUser other) {
      if (other == global::CNETMsg_SplitScreenUser.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasSlot) {
        Slot = other.Slot;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cNETMsgSplitScreenUserFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cNETMsgSplitScreenUserFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasSlot = input.ReadInt32(ref result.slot_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasSlot {
      get { return result.hasSlot; }
    }
    public int Slot {
      get { return result.Slot; }
      set { SetSlot(value); }
    }
    public Builder SetSlot(int value) {
      PrepareBuilder();
      result.hasSlot = true;
      result.slot_ = value;
      return this;
    }
    public Builder ClearSlot() {
      PrepareBuilder();
      result.hasSlot = false;
      result.slot_ = 0;
      return this;
    }
  }
  static CNETMsg_SplitScreenUser() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CCLCMsg_ClientInfo : pb::GeneratedMessage<CCLCMsg_ClientInfo, CCLCMsg_ClientInfo.Builder> {
  private CCLCMsg_ClientInfo() { }
  private static readonly CCLCMsg_ClientInfo defaultInstance = new CCLCMsg_ClientInfo().MakeReadOnly();
  private static readonly string[] _cCLCMsgClientInfoFieldNames = new string[] { "custom_files", "friends_id", "friends_name", "is_hltv", "is_replay", "send_table_crc", "server_count" };
  private static readonly uint[] _cCLCMsgClientInfoFieldTags = new uint[] { 61, 40, 50, 24, 32, 13, 16 };
  public static CCLCMsg_ClientInfo DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CCLCMsg_ClientInfo DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CCLCMsg_ClientInfo ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CCLCMsg_ClientInfo__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CCLCMsg_ClientInfo, CCLCMsg_ClientInfo.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CCLCMsg_ClientInfo__FieldAccessorTable; }
  }
  
  public const int SendTableCrcFieldNumber = 1;
  private bool hasSendTableCrc;
  private uint sendTableCrc_;
  public bool HasSendTableCrc {
    get { return hasSendTableCrc; }
  }
  [global::System.CLSCompliant(false)]
  public uint SendTableCrc {
    get { return sendTableCrc_; }
  }
  
  public const int ServerCountFieldNumber = 2;
  private bool hasServerCount;
  private uint serverCount_;
  public bool HasServerCount {
    get { return hasServerCount; }
  }
  [global::System.CLSCompliant(false)]
  public uint ServerCount {
    get { return serverCount_; }
  }
  
  public const int IsHltvFieldNumber = 3;
  private bool hasIsHltv;
  private bool isHltv_;
  public bool HasIsHltv {
    get { return hasIsHltv; }
  }
  public bool IsHltv {
    get { return isHltv_; }
  }
  
  public const int IsReplayFieldNumber = 4;
  private bool hasIsReplay;
  private bool isReplay_;
  public bool HasIsReplay {
    get { return hasIsReplay; }
  }
  public bool IsReplay {
    get { return isReplay_; }
  }
  
  public const int FriendsIdFieldNumber = 5;
  private bool hasFriendsId;
  private uint friendsId_;
  public bool HasFriendsId {
    get { return hasFriendsId; }
  }
  [global::System.CLSCompliant(false)]
  public uint FriendsId {
    get { return friendsId_; }
  }
  
  public const int FriendsNameFieldNumber = 6;
  private bool hasFriendsName;
  private string friendsName_ = "";
  public bool HasFriendsName {
    get { return hasFriendsName; }
  }
  public string FriendsName {
    get { return friendsName_; }
  }
  
  public const int CustomFilesFieldNumber = 7;
  private pbc::PopsicleList<uint> customFiles_ = new pbc::PopsicleList<uint>();
  [global::System.CLSCompliant(false)]
  public scg::IList<uint> CustomFilesList {
    get { return pbc::Lists.AsReadOnly(customFiles_); }
  }
  public int CustomFilesCount {
    get { return customFiles_.Count; }
  }
  [global::System.CLSCompliant(false)]
  public uint GetCustomFiles(int index) {
    return customFiles_[index];
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cCLCMsgClientInfoFieldNames;
    if (hasSendTableCrc) {
      output.WriteFixed32(1, field_names[5], SendTableCrc);
    }
    if (hasServerCount) {
      output.WriteUInt32(2, field_names[6], ServerCount);
    }
    if (hasIsHltv) {
      output.WriteBool(3, field_names[3], IsHltv);
    }
    if (hasIsReplay) {
      output.WriteBool(4, field_names[4], IsReplay);
    }
    if (hasFriendsId) {
      output.WriteUInt32(5, field_names[1], FriendsId);
    }
    if (hasFriendsName) {
      output.WriteString(6, field_names[2], FriendsName);
    }
    if (customFiles_.Count > 0) {
      output.WriteFixed32Array(7, field_names[0], customFiles_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSendTableCrc) {
        size += pb::CodedOutputStream.ComputeFixed32Size(1, SendTableCrc);
      }
      if (hasServerCount) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, ServerCount);
      }
      if (hasIsHltv) {
        size += pb::CodedOutputStream.ComputeBoolSize(3, IsHltv);
      }
      if (hasIsReplay) {
        size += pb::CodedOutputStream.ComputeBoolSize(4, IsReplay);
      }
      if (hasFriendsId) {
        size += pb::CodedOutputStream.ComputeUInt32Size(5, FriendsId);
      }
      if (hasFriendsName) {
        size += pb::CodedOutputStream.ComputeStringSize(6, FriendsName);
      }
      {
        int dataSize = 0;
        dataSize = 4 * customFiles_.Count;
        size += dataSize;
        size += 1 * customFiles_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CCLCMsg_ClientInfo ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_ClientInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_ClientInfo ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_ClientInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_ClientInfo ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_ClientInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_ClientInfo ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CCLCMsg_ClientInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CCLCMsg_ClientInfo ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_ClientInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CCLCMsg_ClientInfo MakeReadOnly() {
    customFiles_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CCLCMsg_ClientInfo prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CCLCMsg_ClientInfo, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CCLCMsg_ClientInfo cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CCLCMsg_ClientInfo result;
    
    private CCLCMsg_ClientInfo PrepareBuilder() {
      if (resultIsReadOnly) {
        CCLCMsg_ClientInfo original = result;
        result = new CCLCMsg_ClientInfo();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CCLCMsg_ClientInfo MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CCLCMsg_ClientInfo.Descriptor; }
    }
    
    public override CCLCMsg_ClientInfo DefaultInstanceForType {
      get { return global::CCLCMsg_ClientInfo.DefaultInstance; }
    }
    
    public override CCLCMsg_ClientInfo BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CCLCMsg_ClientInfo) {
        return MergeFrom((CCLCMsg_ClientInfo) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CCLCMsg_ClientInfo other) {
      if (other == global::CCLCMsg_ClientInfo.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasSendTableCrc) {
        SendTableCrc = other.SendTableCrc;
      }
      if (other.HasServerCount) {
        ServerCount = other.ServerCount;
      }
      if (other.HasIsHltv) {
        IsHltv = other.IsHltv;
      }
      if (other.HasIsReplay) {
        IsReplay = other.IsReplay;
      }
      if (other.HasFriendsId) {
        FriendsId = other.FriendsId;
      }
      if (other.HasFriendsName) {
        FriendsName = other.FriendsName;
      }
      if (other.customFiles_.Count != 0) {
        result.customFiles_.Add(other.customFiles_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cCLCMsgClientInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cCLCMsgClientInfoFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 13: {
            result.hasSendTableCrc = input.ReadFixed32(ref result.sendTableCrc_);
            break;
          }
          case 16: {
            result.hasServerCount = input.ReadUInt32(ref result.serverCount_);
            break;
          }
          case 24: {
            result.hasIsHltv = input.ReadBool(ref result.isHltv_);
            break;
          }
          case 32: {
            result.hasIsReplay = input.ReadBool(ref result.isReplay_);
            break;
          }
          case 40: {
            result.hasFriendsId = input.ReadUInt32(ref result.friendsId_);
            break;
          }
          case 50: {
            result.hasFriendsName = input.ReadString(ref result.friendsName_);
            break;
          }
          case 58:
          case 61: {
            input.ReadFixed32Array(tag, field_name, result.customFiles_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasSendTableCrc {
      get { return result.hasSendTableCrc; }
    }
    [global::System.CLSCompliant(false)]
    public uint SendTableCrc {
      get { return result.SendTableCrc; }
      set { SetSendTableCrc(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetSendTableCrc(uint value) {
      PrepareBuilder();
      result.hasSendTableCrc = true;
      result.sendTableCrc_ = value;
      return this;
    }
    public Builder ClearSendTableCrc() {
      PrepareBuilder();
      result.hasSendTableCrc = false;
      result.sendTableCrc_ = 0;
      return this;
    }
    
    public bool HasServerCount {
      get { return result.hasServerCount; }
    }
    [global::System.CLSCompliant(false)]
    public uint ServerCount {
      get { return result.ServerCount; }
      set { SetServerCount(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetServerCount(uint value) {
      PrepareBuilder();
      result.hasServerCount = true;
      result.serverCount_ = value;
      return this;
    }
    public Builder ClearServerCount() {
      PrepareBuilder();
      result.hasServerCount = false;
      result.serverCount_ = 0;
      return this;
    }
    
    public bool HasIsHltv {
      get { return result.hasIsHltv; }
    }
    public bool IsHltv {
      get { return result.IsHltv; }
      set { SetIsHltv(value); }
    }
    public Builder SetIsHltv(bool value) {
      PrepareBuilder();
      result.hasIsHltv = true;
      result.isHltv_ = value;
      return this;
    }
    public Builder ClearIsHltv() {
      PrepareBuilder();
      result.hasIsHltv = false;
      result.isHltv_ = false;
      return this;
    }
    
    public bool HasIsReplay {
      get { return result.hasIsReplay; }
    }
    public bool IsReplay {
      get { return result.IsReplay; }
      set { SetIsReplay(value); }
    }
    public Builder SetIsReplay(bool value) {
      PrepareBuilder();
      result.hasIsReplay = true;
      result.isReplay_ = value;
      return this;
    }
    public Builder ClearIsReplay() {
      PrepareBuilder();
      result.hasIsReplay = false;
      result.isReplay_ = false;
      return this;
    }
    
    public bool HasFriendsId {
      get { return result.hasFriendsId; }
    }
    [global::System.CLSCompliant(false)]
    public uint FriendsId {
      get { return result.FriendsId; }
      set { SetFriendsId(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetFriendsId(uint value) {
      PrepareBuilder();
      result.hasFriendsId = true;
      result.friendsId_ = value;
      return this;
    }
    public Builder ClearFriendsId() {
      PrepareBuilder();
      result.hasFriendsId = false;
      result.friendsId_ = 0;
      return this;
    }
    
    public bool HasFriendsName {
      get { return result.hasFriendsName; }
    }
    public string FriendsName {
      get { return result.FriendsName; }
      set { SetFriendsName(value); }
    }
    public Builder SetFriendsName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasFriendsName = true;
      result.friendsName_ = value;
      return this;
    }
    public Builder ClearFriendsName() {
      PrepareBuilder();
      result.hasFriendsName = false;
      result.friendsName_ = "";
      return this;
    }
    
    [global::System.CLSCompliant(false)]
    public pbc::IPopsicleList<uint> CustomFilesList {
      get { return PrepareBuilder().customFiles_; }
    }
    public int CustomFilesCount {
      get { return result.CustomFilesCount; }
    }
    [global::System.CLSCompliant(false)]
    public uint GetCustomFiles(int index) {
      return result.GetCustomFiles(index);
    }
    [global::System.CLSCompliant(false)]
    public Builder SetCustomFiles(int index, uint value) {
      PrepareBuilder();
      result.customFiles_[index] = value;
      return this;
    }
    [global::System.CLSCompliant(false)]
    public Builder AddCustomFiles(uint value) {
      PrepareBuilder();
      result.customFiles_.Add(value);
      return this;
    }
    [global::System.CLSCompliant(false)]
    public Builder AddRangeCustomFiles(scg::IEnumerable<uint> values) {
      PrepareBuilder();
      result.customFiles_.Add(values);
      return this;
    }
    public Builder ClearCustomFiles() {
      PrepareBuilder();
      result.customFiles_.Clear();
      return this;
    }
  }
  static CCLCMsg_ClientInfo() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CCLCMsg_Move : pb::GeneratedMessage<CCLCMsg_Move, CCLCMsg_Move.Builder> {
  private CCLCMsg_Move() { }
  private static readonly CCLCMsg_Move defaultInstance = new CCLCMsg_Move().MakeReadOnly();
  private static readonly string[] _cCLCMsgMoveFieldNames = new string[] { "data", "num_backup_commands", "num_new_commands" };
  private static readonly uint[] _cCLCMsgMoveFieldTags = new uint[] { 26, 8, 16 };
  public static CCLCMsg_Move DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CCLCMsg_Move DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CCLCMsg_Move ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CCLCMsg_Move__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CCLCMsg_Move, CCLCMsg_Move.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CCLCMsg_Move__FieldAccessorTable; }
  }
  
  public const int NumBackupCommandsFieldNumber = 1;
  private bool hasNumBackupCommands;
  private uint numBackupCommands_;
  public bool HasNumBackupCommands {
    get { return hasNumBackupCommands; }
  }
  [global::System.CLSCompliant(false)]
  public uint NumBackupCommands {
    get { return numBackupCommands_; }
  }
  
  public const int NumNewCommandsFieldNumber = 2;
  private bool hasNumNewCommands;
  private uint numNewCommands_;
  public bool HasNumNewCommands {
    get { return hasNumNewCommands; }
  }
  [global::System.CLSCompliant(false)]
  public uint NumNewCommands {
    get { return numNewCommands_; }
  }
  
  public const int DataFieldNumber = 3;
  private bool hasData;
  private pb::ByteString data_ = pb::ByteString.Empty;
  public bool HasData {
    get { return hasData; }
  }
  public pb::ByteString Data {
    get { return data_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cCLCMsgMoveFieldNames;
    if (hasNumBackupCommands) {
      output.WriteUInt32(1, field_names[1], NumBackupCommands);
    }
    if (hasNumNewCommands) {
      output.WriteUInt32(2, field_names[2], NumNewCommands);
    }
    if (hasData) {
      output.WriteBytes(3, field_names[0], Data);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasNumBackupCommands) {
        size += pb::CodedOutputStream.ComputeUInt32Size(1, NumBackupCommands);
      }
      if (hasNumNewCommands) {
        size += pb::CodedOutputStream.ComputeUInt32Size(2, NumNewCommands);
      }
      if (hasData) {
        size += pb::CodedOutputStream.ComputeBytesSize(3, Data);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CCLCMsg_Move ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_Move ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_Move ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_Move ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_Move ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_Move ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_Move ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CCLCMsg_Move ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CCLCMsg_Move ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_Move ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CCLCMsg_Move MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CCLCMsg_Move prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CCLCMsg_Move, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CCLCMsg_Move cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CCLCMsg_Move result;
    
    private CCLCMsg_Move PrepareBuilder() {
      if (resultIsReadOnly) {
        CCLCMsg_Move original = result;
        result = new CCLCMsg_Move();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CCLCMsg_Move MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CCLCMsg_Move.Descriptor; }
    }
    
    public override CCLCMsg_Move DefaultInstanceForType {
      get { return global::CCLCMsg_Move.DefaultInstance; }
    }
    
    public override CCLCMsg_Move BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CCLCMsg_Move) {
        return MergeFrom((CCLCMsg_Move) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CCLCMsg_Move other) {
      if (other == global::CCLCMsg_Move.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasNumBackupCommands) {
        NumBackupCommands = other.NumBackupCommands;
      }
      if (other.HasNumNewCommands) {
        NumNewCommands = other.NumNewCommands;
      }
      if (other.HasData) {
        Data = other.Data;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cCLCMsgMoveFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cCLCMsgMoveFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasNumBackupCommands = input.ReadUInt32(ref result.numBackupCommands_);
            break;
          }
          case 16: {
            result.hasNumNewCommands = input.ReadUInt32(ref result.numNewCommands_);
            break;
          }
          case 26: {
            result.hasData = input.ReadBytes(ref result.data_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasNumBackupCommands {
      get { return result.hasNumBackupCommands; }
    }
    [global::System.CLSCompliant(false)]
    public uint NumBackupCommands {
      get { return result.NumBackupCommands; }
      set { SetNumBackupCommands(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetNumBackupCommands(uint value) {
      PrepareBuilder();
      result.hasNumBackupCommands = true;
      result.numBackupCommands_ = value;
      return this;
    }
    public Builder ClearNumBackupCommands() {
      PrepareBuilder();
      result.hasNumBackupCommands = false;
      result.numBackupCommands_ = 0;
      return this;
    }
    
    public bool HasNumNewCommands {
      get { return result.hasNumNewCommands; }
    }
    [global::System.CLSCompliant(false)]
    public uint NumNewCommands {
      get { return result.NumNewCommands; }
      set { SetNumNewCommands(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetNumNewCommands(uint value) {
      PrepareBuilder();
      result.hasNumNewCommands = true;
      result.numNewCommands_ = value;
      return this;
    }
    public Builder ClearNumNewCommands() {
      PrepareBuilder();
      result.hasNumNewCommands = false;
      result.numNewCommands_ = 0;
      return this;
    }
    
    public bool HasData {
      get { return result.hasData; }
    }
    public pb::ByteString Data {
      get { return result.Data; }
      set { SetData(value); }
    }
    public Builder SetData(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasData = true;
      result.data_ = value;
      return this;
    }
    public Builder ClearData() {
      PrepareBuilder();
      result.hasData = false;
      result.data_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CCLCMsg_Move() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CCLCMsg_VoiceData : pb::GeneratedMessage<CCLCMsg_VoiceData, CCLCMsg_VoiceData.Builder> {
  private CCLCMsg_VoiceData() { }
  private static readonly CCLCMsg_VoiceData defaultInstance = new CCLCMsg_VoiceData().MakeReadOnly();
  private static readonly string[] _cCLCMsgVoiceDataFieldNames = new string[] { "data", "xuid" };
  private static readonly uint[] _cCLCMsgVoiceDataFieldTags = new uint[] { 10, 17 };
  public static CCLCMsg_VoiceData DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CCLCMsg_VoiceData DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CCLCMsg_VoiceData ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CCLCMsg_VoiceData__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CCLCMsg_VoiceData, CCLCMsg_VoiceData.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CCLCMsg_VoiceData__FieldAccessorTable; }
  }
  
  public const int DataFieldNumber = 1;
  private bool hasData;
  private pb::ByteString data_ = pb::ByteString.Empty;
  public bool HasData {
    get { return hasData; }
  }
  public pb::ByteString Data {
    get { return data_; }
  }
  
  public const int XuidFieldNumber = 2;
  private bool hasXuid;
  private ulong xuid_;
  public bool HasXuid {
    get { return hasXuid; }
  }
  [global::System.CLSCompliant(false)]
  public ulong Xuid {
    get { return xuid_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cCLCMsgVoiceDataFieldNames;
    if (hasData) {
      output.WriteBytes(1, field_names[0], Data);
    }
    if (hasXuid) {
      output.WriteFixed64(2, field_names[1], Xuid);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasData) {
        size += pb::CodedOutputStream.ComputeBytesSize(1, Data);
      }
      if (hasXuid) {
        size += pb::CodedOutputStream.ComputeFixed64Size(2, Xuid);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CCLCMsg_VoiceData ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_VoiceData ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_VoiceData ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_VoiceData ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_VoiceData ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_VoiceData ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_VoiceData ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CCLCMsg_VoiceData ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CCLCMsg_VoiceData ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_VoiceData ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CCLCMsg_VoiceData MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CCLCMsg_VoiceData prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CCLCMsg_VoiceData, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CCLCMsg_VoiceData cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CCLCMsg_VoiceData result;
    
    private CCLCMsg_VoiceData PrepareBuilder() {
      if (resultIsReadOnly) {
        CCLCMsg_VoiceData original = result;
        result = new CCLCMsg_VoiceData();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CCLCMsg_VoiceData MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CCLCMsg_VoiceData.Descriptor; }
    }
    
    public override CCLCMsg_VoiceData DefaultInstanceForType {
      get { return global::CCLCMsg_VoiceData.DefaultInstance; }
    }
    
    public override CCLCMsg_VoiceData BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CCLCMsg_VoiceData) {
        return MergeFrom((CCLCMsg_VoiceData) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CCLCMsg_VoiceData other) {
      if (other == global::CCLCMsg_VoiceData.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasData) {
        Data = other.Data;
      }
      if (other.HasXuid) {
        Xuid = other.Xuid;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cCLCMsgVoiceDataFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cCLCMsgVoiceDataFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasData = input.ReadBytes(ref result.data_);
            break;
          }
          case 17: {
            result.hasXuid = input.ReadFixed64(ref result.xuid_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasData {
      get { return result.hasData; }
    }
    public pb::ByteString Data {
      get { return result.Data; }
      set { SetData(value); }
    }
    public Builder SetData(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasData = true;
      result.data_ = value;
      return this;
    }
    public Builder ClearData() {
      PrepareBuilder();
      result.hasData = false;
      result.data_ = pb::ByteString.Empty;
      return this;
    }
    
    public bool HasXuid {
      get { return result.hasXuid; }
    }
    [global::System.CLSCompliant(false)]
    public ulong Xuid {
      get { return result.Xuid; }
      set { SetXuid(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetXuid(ulong value) {
      PrepareBuilder();
      result.hasXuid = true;
      result.xuid_ = value;
      return this;
    }
    public Builder ClearXuid() {
      PrepareBuilder();
      result.hasXuid = false;
      result.xuid_ = 0;
      return this;
    }
  }
  static CCLCMsg_VoiceData() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CCLCMsg_BaselineAck : pb::GeneratedMessage<CCLCMsg_BaselineAck, CCLCMsg_BaselineAck.Builder> {
  private CCLCMsg_BaselineAck() { }
  private static readonly CCLCMsg_BaselineAck defaultInstance = new CCLCMsg_BaselineAck().MakeReadOnly();
  private static readonly string[] _cCLCMsgBaselineAckFieldNames = new string[] { "baseline_nr", "baseline_tick" };
  private static readonly uint[] _cCLCMsgBaselineAckFieldTags = new uint[] { 16, 8 };
  public static CCLCMsg_BaselineAck DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CCLCMsg_BaselineAck DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CCLCMsg_BaselineAck ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CCLCMsg_BaselineAck__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CCLCMsg_BaselineAck, CCLCMsg_BaselineAck.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CCLCMsg_BaselineAck__FieldAccessorTable; }
  }
  
  public const int BaselineTickFieldNumber = 1;
  private bool hasBaselineTick;
  private int baselineTick_;
  public bool HasBaselineTick {
    get { return hasBaselineTick; }
  }
  public int BaselineTick {
    get { return baselineTick_; }
  }
  
  public const int BaselineNrFieldNumber = 2;
  private bool hasBaselineNr;
  private int baselineNr_;
  public bool HasBaselineNr {
    get { return hasBaselineNr; }
  }
  public int BaselineNr {
    get { return baselineNr_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cCLCMsgBaselineAckFieldNames;
    if (hasBaselineTick) {
      output.WriteInt32(1, field_names[1], BaselineTick);
    }
    if (hasBaselineNr) {
      output.WriteInt32(2, field_names[0], BaselineNr);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasBaselineTick) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, BaselineTick);
      }
      if (hasBaselineNr) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, BaselineNr);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CCLCMsg_BaselineAck ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_BaselineAck ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_BaselineAck ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_BaselineAck ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_BaselineAck ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_BaselineAck ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_BaselineAck ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CCLCMsg_BaselineAck ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CCLCMsg_BaselineAck ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_BaselineAck ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CCLCMsg_BaselineAck MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CCLCMsg_BaselineAck prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CCLCMsg_BaselineAck, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CCLCMsg_BaselineAck cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CCLCMsg_BaselineAck result;
    
    private CCLCMsg_BaselineAck PrepareBuilder() {
      if (resultIsReadOnly) {
        CCLCMsg_BaselineAck original = result;
        result = new CCLCMsg_BaselineAck();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CCLCMsg_BaselineAck MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CCLCMsg_BaselineAck.Descriptor; }
    }
    
    public override CCLCMsg_BaselineAck DefaultInstanceForType {
      get { return global::CCLCMsg_BaselineAck.DefaultInstance; }
    }
    
    public override CCLCMsg_BaselineAck BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CCLCMsg_BaselineAck) {
        return MergeFrom((CCLCMsg_BaselineAck) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CCLCMsg_BaselineAck other) {
      if (other == global::CCLCMsg_BaselineAck.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasBaselineTick) {
        BaselineTick = other.BaselineTick;
      }
      if (other.HasBaselineNr) {
        BaselineNr = other.BaselineNr;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cCLCMsgBaselineAckFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cCLCMsgBaselineAckFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasBaselineTick = input.ReadInt32(ref result.baselineTick_);
            break;
          }
          case 16: {
            result.hasBaselineNr = input.ReadInt32(ref result.baselineNr_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasBaselineTick {
      get { return result.hasBaselineTick; }
    }
    public int BaselineTick {
      get { return result.BaselineTick; }
      set { SetBaselineTick(value); }
    }
    public Builder SetBaselineTick(int value) {
      PrepareBuilder();
      result.hasBaselineTick = true;
      result.baselineTick_ = value;
      return this;
    }
    public Builder ClearBaselineTick() {
      PrepareBuilder();
      result.hasBaselineTick = false;
      result.baselineTick_ = 0;
      return this;
    }
    
    public bool HasBaselineNr {
      get { return result.hasBaselineNr; }
    }
    public int BaselineNr {
      get { return result.BaselineNr; }
      set { SetBaselineNr(value); }
    }
    public Builder SetBaselineNr(int value) {
      PrepareBuilder();
      result.hasBaselineNr = true;
      result.baselineNr_ = value;
      return this;
    }
    public Builder ClearBaselineNr() {
      PrepareBuilder();
      result.hasBaselineNr = false;
      result.baselineNr_ = 0;
      return this;
    }
  }
  static CCLCMsg_BaselineAck() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CCLCMsg_ListenEvents : pb::GeneratedMessage<CCLCMsg_ListenEvents, CCLCMsg_ListenEvents.Builder> {
  private CCLCMsg_ListenEvents() { }
  private static readonly CCLCMsg_ListenEvents defaultInstance = new CCLCMsg_ListenEvents().MakeReadOnly();
  private static readonly string[] _cCLCMsgListenEventsFieldNames = new string[] { "event_mask" };
  private static readonly uint[] _cCLCMsgListenEventsFieldTags = new uint[] { 13 };
  public static CCLCMsg_ListenEvents DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CCLCMsg_ListenEvents DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CCLCMsg_ListenEvents ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CCLCMsg_ListenEvents__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CCLCMsg_ListenEvents, CCLCMsg_ListenEvents.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CCLCMsg_ListenEvents__FieldAccessorTable; }
  }
  
  public const int EventMaskFieldNumber = 1;
  private pbc::PopsicleList<uint> eventMask_ = new pbc::PopsicleList<uint>();
  [global::System.CLSCompliant(false)]
  public scg::IList<uint> EventMaskList {
    get { return pbc::Lists.AsReadOnly(eventMask_); }
  }
  public int EventMaskCount {
    get { return eventMask_.Count; }
  }
  [global::System.CLSCompliant(false)]
  public uint GetEventMask(int index) {
    return eventMask_[index];
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cCLCMsgListenEventsFieldNames;
    if (eventMask_.Count > 0) {
      output.WriteFixed32Array(1, field_names[0], eventMask_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      {
        int dataSize = 0;
        dataSize = 4 * eventMask_.Count;
        size += dataSize;
        size += 1 * eventMask_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CCLCMsg_ListenEvents ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_ListenEvents ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_ListenEvents ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_ListenEvents ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_ListenEvents ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_ListenEvents ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_ListenEvents ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CCLCMsg_ListenEvents ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CCLCMsg_ListenEvents ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_ListenEvents ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CCLCMsg_ListenEvents MakeReadOnly() {
    eventMask_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CCLCMsg_ListenEvents prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CCLCMsg_ListenEvents, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CCLCMsg_ListenEvents cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CCLCMsg_ListenEvents result;
    
    private CCLCMsg_ListenEvents PrepareBuilder() {
      if (resultIsReadOnly) {
        CCLCMsg_ListenEvents original = result;
        result = new CCLCMsg_ListenEvents();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CCLCMsg_ListenEvents MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CCLCMsg_ListenEvents.Descriptor; }
    }
    
    public override CCLCMsg_ListenEvents DefaultInstanceForType {
      get { return global::CCLCMsg_ListenEvents.DefaultInstance; }
    }
    
    public override CCLCMsg_ListenEvents BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CCLCMsg_ListenEvents) {
        return MergeFrom((CCLCMsg_ListenEvents) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CCLCMsg_ListenEvents other) {
      if (other == global::CCLCMsg_ListenEvents.DefaultInstance) return this;
      PrepareBuilder();
      if (other.eventMask_.Count != 0) {
        result.eventMask_.Add(other.eventMask_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cCLCMsgListenEventsFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cCLCMsgListenEventsFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10:
          case 13: {
            input.ReadFixed32Array(tag, field_name, result.eventMask_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    [global::System.CLSCompliant(false)]
    public pbc::IPopsicleList<uint> EventMaskList {
      get { return PrepareBuilder().eventMask_; }
    }
    public int EventMaskCount {
      get { return result.EventMaskCount; }
    }
    [global::System.CLSCompliant(false)]
    public uint GetEventMask(int index) {
      return result.GetEventMask(index);
    }
    [global::System.CLSCompliant(false)]
    public Builder SetEventMask(int index, uint value) {
      PrepareBuilder();
      result.eventMask_[index] = value;
      return this;
    }
    [global::System.CLSCompliant(false)]
    public Builder AddEventMask(uint value) {
      PrepareBuilder();
      result.eventMask_.Add(value);
      return this;
    }
    [global::System.CLSCompliant(false)]
    public Builder AddRangeEventMask(scg::IEnumerable<uint> values) {
      PrepareBuilder();
      result.eventMask_.Add(values);
      return this;
    }
    public Builder ClearEventMask() {
      PrepareBuilder();
      result.eventMask_.Clear();
      return this;
    }
  }
  static CCLCMsg_ListenEvents() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CCLCMsg_RespondCvarValue : pb::GeneratedMessage<CCLCMsg_RespondCvarValue, CCLCMsg_RespondCvarValue.Builder> {
  private CCLCMsg_RespondCvarValue() { }
  private static readonly CCLCMsg_RespondCvarValue defaultInstance = new CCLCMsg_RespondCvarValue().MakeReadOnly();
  private static readonly string[] _cCLCMsgRespondCvarValueFieldNames = new string[] { "cookie", "name", "status_code", "value" };
  private static readonly uint[] _cCLCMsgRespondCvarValueFieldTags = new uint[] { 8, 26, 16, 34 };
  public static CCLCMsg_RespondCvarValue DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CCLCMsg_RespondCvarValue DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CCLCMsg_RespondCvarValue ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CCLCMsg_RespondCvarValue__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CCLCMsg_RespondCvarValue, CCLCMsg_RespondCvarValue.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CCLCMsg_RespondCvarValue__FieldAccessorTable; }
  }
  
  public const int CookieFieldNumber = 1;
  private bool hasCookie;
  private int cookie_;
  public bool HasCookie {
    get { return hasCookie; }
  }
  public int Cookie {
    get { return cookie_; }
  }
  
  public const int StatusCodeFieldNumber = 2;
  private bool hasStatusCode;
  private int statusCode_;
  public bool HasStatusCode {
    get { return hasStatusCode; }
  }
  public int StatusCode {
    get { return statusCode_; }
  }
  
  public const int NameFieldNumber = 3;
  private bool hasName;
  private string name_ = "";
  public bool HasName {
    get { return hasName; }
  }
  public string Name {
    get { return name_; }
  }
  
  public const int ValueFieldNumber = 4;
  private bool hasValue;
  private string value_ = "";
  public bool HasValue {
    get { return hasValue; }
  }
  public string Value {
    get { return value_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cCLCMsgRespondCvarValueFieldNames;
    if (hasCookie) {
      output.WriteInt32(1, field_names[0], Cookie);
    }
    if (hasStatusCode) {
      output.WriteInt32(2, field_names[2], StatusCode);
    }
    if (hasName) {
      output.WriteString(3, field_names[1], Name);
    }
    if (hasValue) {
      output.WriteString(4, field_names[3], Value);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCookie) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, Cookie);
      }
      if (hasStatusCode) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, StatusCode);
      }
      if (hasName) {
        size += pb::CodedOutputStream.ComputeStringSize(3, Name);
      }
      if (hasValue) {
        size += pb::CodedOutputStream.ComputeStringSize(4, Value);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CCLCMsg_RespondCvarValue ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_RespondCvarValue ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_RespondCvarValue ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_RespondCvarValue ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_RespondCvarValue ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_RespondCvarValue ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_RespondCvarValue ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CCLCMsg_RespondCvarValue ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CCLCMsg_RespondCvarValue ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_RespondCvarValue ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CCLCMsg_RespondCvarValue MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CCLCMsg_RespondCvarValue prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CCLCMsg_RespondCvarValue, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CCLCMsg_RespondCvarValue cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CCLCMsg_RespondCvarValue result;
    
    private CCLCMsg_RespondCvarValue PrepareBuilder() {
      if (resultIsReadOnly) {
        CCLCMsg_RespondCvarValue original = result;
        result = new CCLCMsg_RespondCvarValue();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CCLCMsg_RespondCvarValue MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CCLCMsg_RespondCvarValue.Descriptor; }
    }
    
    public override CCLCMsg_RespondCvarValue DefaultInstanceForType {
      get { return global::CCLCMsg_RespondCvarValue.DefaultInstance; }
    }
    
    public override CCLCMsg_RespondCvarValue BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CCLCMsg_RespondCvarValue) {
        return MergeFrom((CCLCMsg_RespondCvarValue) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CCLCMsg_RespondCvarValue other) {
      if (other == global::CCLCMsg_RespondCvarValue.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasCookie) {
        Cookie = other.Cookie;
      }
      if (other.HasStatusCode) {
        StatusCode = other.StatusCode;
      }
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasValue) {
        Value = other.Value;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cCLCMsgRespondCvarValueFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cCLCMsgRespondCvarValueFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasCookie = input.ReadInt32(ref result.cookie_);
            break;
          }
          case 16: {
            result.hasStatusCode = input.ReadInt32(ref result.statusCode_);
            break;
          }
          case 26: {
            result.hasName = input.ReadString(ref result.name_);
            break;
          }
          case 34: {
            result.hasValue = input.ReadString(ref result.value_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasCookie {
      get { return result.hasCookie; }
    }
    public int Cookie {
      get { return result.Cookie; }
      set { SetCookie(value); }
    }
    public Builder SetCookie(int value) {
      PrepareBuilder();
      result.hasCookie = true;
      result.cookie_ = value;
      return this;
    }
    public Builder ClearCookie() {
      PrepareBuilder();
      result.hasCookie = false;
      result.cookie_ = 0;
      return this;
    }
    
    public bool HasStatusCode {
      get { return result.hasStatusCode; }
    }
    public int StatusCode {
      get { return result.StatusCode; }
      set { SetStatusCode(value); }
    }
    public Builder SetStatusCode(int value) {
      PrepareBuilder();
      result.hasStatusCode = true;
      result.statusCode_ = value;
      return this;
    }
    public Builder ClearStatusCode() {
      PrepareBuilder();
      result.hasStatusCode = false;
      result.statusCode_ = 0;
      return this;
    }
    
    public bool HasName {
      get { return result.hasName; }
    }
    public string Name {
      get { return result.Name; }
      set { SetName(value); }
    }
    public Builder SetName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasName = true;
      result.name_ = value;
      return this;
    }
    public Builder ClearName() {
      PrepareBuilder();
      result.hasName = false;
      result.name_ = "";
      return this;
    }
    
    public bool HasValue {
      get { return result.hasValue; }
    }
    public string Value {
      get { return result.Value; }
      set { SetValue(value); }
    }
    public Builder SetValue(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasValue = true;
      result.value_ = value;
      return this;
    }
    public Builder ClearValue() {
      PrepareBuilder();
      result.hasValue = false;
      result.value_ = "";
      return this;
    }
  }
  static CCLCMsg_RespondCvarValue() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CCLCMsg_FileCRCCheck : pb::GeneratedMessage<CCLCMsg_FileCRCCheck, CCLCMsg_FileCRCCheck.Builder> {
  private CCLCMsg_FileCRCCheck() { }
  private static readonly CCLCMsg_FileCRCCheck defaultInstance = new CCLCMsg_FileCRCCheck().MakeReadOnly();
  private static readonly string[] _cCLCMsgFileCRCCheckFieldNames = new string[] { "code_filename", "code_path", "crc", "file_fraction", "file_hash_type", "file_len", "filename", "md5", "pack_file_id", "pack_file_number", "path" };
  private static readonly uint[] _cCLCMsgFileCRCCheckFieldTags = new uint[] { 24, 8, 56, 40, 64, 72, 34, 50, 80, 88, 18 };
  public static CCLCMsg_FileCRCCheck DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CCLCMsg_FileCRCCheck DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CCLCMsg_FileCRCCheck ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CCLCMsg_FileCRCCheck__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CCLCMsg_FileCRCCheck, CCLCMsg_FileCRCCheck.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CCLCMsg_FileCRCCheck__FieldAccessorTable; }
  }
  
  public const int CodePathFieldNumber = 1;
  private bool hasCodePath;
  private int codePath_;
  public bool HasCodePath {
    get { return hasCodePath; }
  }
  public int CodePath {
    get { return codePath_; }
  }
  
  public const int PathFieldNumber = 2;
  private bool hasPath;
  private string path_ = "";
  public bool HasPath {
    get { return hasPath; }
  }
  public string Path {
    get { return path_; }
  }
  
  public const int CodeFilenameFieldNumber = 3;
  private bool hasCodeFilename;
  private int codeFilename_;
  public bool HasCodeFilename {
    get { return hasCodeFilename; }
  }
  public int CodeFilename {
    get { return codeFilename_; }
  }
  
  public const int FilenameFieldNumber = 4;
  private bool hasFilename;
  private string filename_ = "";
  public bool HasFilename {
    get { return hasFilename; }
  }
  public string Filename {
    get { return filename_; }
  }
  
  public const int FileFractionFieldNumber = 5;
  private bool hasFileFraction;
  private int fileFraction_;
  public bool HasFileFraction {
    get { return hasFileFraction; }
  }
  public int FileFraction {
    get { return fileFraction_; }
  }
  
  public const int Md5FieldNumber = 6;
  private bool hasMd5;
  private pb::ByteString md5_ = pb::ByteString.Empty;
  public bool HasMd5 {
    get { return hasMd5; }
  }
  public pb::ByteString Md5 {
    get { return md5_; }
  }
  
  public const int CrcFieldNumber = 7;
  private bool hasCrc;
  private uint crc_;
  public bool HasCrc {
    get { return hasCrc; }
  }
  [global::System.CLSCompliant(false)]
  public uint Crc {
    get { return crc_; }
  }
  
  public const int FileHashTypeFieldNumber = 8;
  private bool hasFileHashType;
  private int fileHashType_;
  public bool HasFileHashType {
    get { return hasFileHashType; }
  }
  public int FileHashType {
    get { return fileHashType_; }
  }
  
  public const int FileLenFieldNumber = 9;
  private bool hasFileLen;
  private int fileLen_;
  public bool HasFileLen {
    get { return hasFileLen; }
  }
  public int FileLen {
    get { return fileLen_; }
  }
  
  public const int PackFileIdFieldNumber = 10;
  private bool hasPackFileId;
  private int packFileId_;
  public bool HasPackFileId {
    get { return hasPackFileId; }
  }
  public int PackFileId {
    get { return packFileId_; }
  }
  
  public const int PackFileNumberFieldNumber = 11;
  private bool hasPackFileNumber;
  private int packFileNumber_;
  public bool HasPackFileNumber {
    get { return hasPackFileNumber; }
  }
  public int PackFileNumber {
    get { return packFileNumber_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cCLCMsgFileCRCCheckFieldNames;
    if (hasCodePath) {
      output.WriteInt32(1, field_names[1], CodePath);
    }
    if (hasPath) {
      output.WriteString(2, field_names[10], Path);
    }
    if (hasCodeFilename) {
      output.WriteInt32(3, field_names[0], CodeFilename);
    }
    if (hasFilename) {
      output.WriteString(4, field_names[6], Filename);
    }
    if (hasFileFraction) {
      output.WriteInt32(5, field_names[3], FileFraction);
    }
    if (hasMd5) {
      output.WriteBytes(6, field_names[7], Md5);
    }
    if (hasCrc) {
      output.WriteUInt32(7, field_names[2], Crc);
    }
    if (hasFileHashType) {
      output.WriteInt32(8, field_names[4], FileHashType);
    }
    if (hasFileLen) {
      output.WriteInt32(9, field_names[5], FileLen);
    }
    if (hasPackFileId) {
      output.WriteInt32(10, field_names[8], PackFileId);
    }
    if (hasPackFileNumber) {
      output.WriteInt32(11, field_names[9], PackFileNumber);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCodePath) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, CodePath);
      }
      if (hasPath) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Path);
      }
      if (hasCodeFilename) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, CodeFilename);
      }
      if (hasFilename) {
        size += pb::CodedOutputStream.ComputeStringSize(4, Filename);
      }
      if (hasFileFraction) {
        size += pb::CodedOutputStream.ComputeInt32Size(5, FileFraction);
      }
      if (hasMd5) {
        size += pb::CodedOutputStream.ComputeBytesSize(6, Md5);
      }
      if (hasCrc) {
        size += pb::CodedOutputStream.ComputeUInt32Size(7, Crc);
      }
      if (hasFileHashType) {
        size += pb::CodedOutputStream.ComputeInt32Size(8, FileHashType);
      }
      if (hasFileLen) {
        size += pb::CodedOutputStream.ComputeInt32Size(9, FileLen);
      }
      if (hasPackFileId) {
        size += pb::CodedOutputStream.ComputeInt32Size(10, PackFileId);
      }
      if (hasPackFileNumber) {
        size += pb::CodedOutputStream.ComputeInt32Size(11, PackFileNumber);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CCLCMsg_FileCRCCheck ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_FileCRCCheck ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_FileCRCCheck ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_FileCRCCheck ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_FileCRCCheck ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_FileCRCCheck ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_FileCRCCheck ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CCLCMsg_FileCRCCheck ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CCLCMsg_FileCRCCheck ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_FileCRCCheck ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CCLCMsg_FileCRCCheck MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CCLCMsg_FileCRCCheck prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CCLCMsg_FileCRCCheck, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CCLCMsg_FileCRCCheck cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CCLCMsg_FileCRCCheck result;
    
    private CCLCMsg_FileCRCCheck PrepareBuilder() {
      if (resultIsReadOnly) {
        CCLCMsg_FileCRCCheck original = result;
        result = new CCLCMsg_FileCRCCheck();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CCLCMsg_FileCRCCheck MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CCLCMsg_FileCRCCheck.Descriptor; }
    }
    
    public override CCLCMsg_FileCRCCheck DefaultInstanceForType {
      get { return global::CCLCMsg_FileCRCCheck.DefaultInstance; }
    }
    
    public override CCLCMsg_FileCRCCheck BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CCLCMsg_FileCRCCheck) {
        return MergeFrom((CCLCMsg_FileCRCCheck) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CCLCMsg_FileCRCCheck other) {
      if (other == global::CCLCMsg_FileCRCCheck.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasCodePath) {
        CodePath = other.CodePath;
      }
      if (other.HasPath) {
        Path = other.Path;
      }
      if (other.HasCodeFilename) {
        CodeFilename = other.CodeFilename;
      }
      if (other.HasFilename) {
        Filename = other.Filename;
      }
      if (other.HasFileFraction) {
        FileFraction = other.FileFraction;
      }
      if (other.HasMd5) {
        Md5 = other.Md5;
      }
      if (other.HasCrc) {
        Crc = other.Crc;
      }
      if (other.HasFileHashType) {
        FileHashType = other.FileHashType;
      }
      if (other.HasFileLen) {
        FileLen = other.FileLen;
      }
      if (other.HasPackFileId) {
        PackFileId = other.PackFileId;
      }
      if (other.HasPackFileNumber) {
        PackFileNumber = other.PackFileNumber;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cCLCMsgFileCRCCheckFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cCLCMsgFileCRCCheckFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasCodePath = input.ReadInt32(ref result.codePath_);
            break;
          }
          case 18: {
            result.hasPath = input.ReadString(ref result.path_);
            break;
          }
          case 24: {
            result.hasCodeFilename = input.ReadInt32(ref result.codeFilename_);
            break;
          }
          case 34: {
            result.hasFilename = input.ReadString(ref result.filename_);
            break;
          }
          case 40: {
            result.hasFileFraction = input.ReadInt32(ref result.fileFraction_);
            break;
          }
          case 50: {
            result.hasMd5 = input.ReadBytes(ref result.md5_);
            break;
          }
          case 56: {
            result.hasCrc = input.ReadUInt32(ref result.crc_);
            break;
          }
          case 64: {
            result.hasFileHashType = input.ReadInt32(ref result.fileHashType_);
            break;
          }
          case 72: {
            result.hasFileLen = input.ReadInt32(ref result.fileLen_);
            break;
          }
          case 80: {
            result.hasPackFileId = input.ReadInt32(ref result.packFileId_);
            break;
          }
          case 88: {
            result.hasPackFileNumber = input.ReadInt32(ref result.packFileNumber_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasCodePath {
      get { return result.hasCodePath; }
    }
    public int CodePath {
      get { return result.CodePath; }
      set { SetCodePath(value); }
    }
    public Builder SetCodePath(int value) {
      PrepareBuilder();
      result.hasCodePath = true;
      result.codePath_ = value;
      return this;
    }
    public Builder ClearCodePath() {
      PrepareBuilder();
      result.hasCodePath = false;
      result.codePath_ = 0;
      return this;
    }
    
    public bool HasPath {
      get { return result.hasPath; }
    }
    public string Path {
      get { return result.Path; }
      set { SetPath(value); }
    }
    public Builder SetPath(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasPath = true;
      result.path_ = value;
      return this;
    }
    public Builder ClearPath() {
      PrepareBuilder();
      result.hasPath = false;
      result.path_ = "";
      return this;
    }
    
    public bool HasCodeFilename {
      get { return result.hasCodeFilename; }
    }
    public int CodeFilename {
      get { return result.CodeFilename; }
      set { SetCodeFilename(value); }
    }
    public Builder SetCodeFilename(int value) {
      PrepareBuilder();
      result.hasCodeFilename = true;
      result.codeFilename_ = value;
      return this;
    }
    public Builder ClearCodeFilename() {
      PrepareBuilder();
      result.hasCodeFilename = false;
      result.codeFilename_ = 0;
      return this;
    }
    
    public bool HasFilename {
      get { return result.hasFilename; }
    }
    public string Filename {
      get { return result.Filename; }
      set { SetFilename(value); }
    }
    public Builder SetFilename(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasFilename = true;
      result.filename_ = value;
      return this;
    }
    public Builder ClearFilename() {
      PrepareBuilder();
      result.hasFilename = false;
      result.filename_ = "";
      return this;
    }
    
    public bool HasFileFraction {
      get { return result.hasFileFraction; }
    }
    public int FileFraction {
      get { return result.FileFraction; }
      set { SetFileFraction(value); }
    }
    public Builder SetFileFraction(int value) {
      PrepareBuilder();
      result.hasFileFraction = true;
      result.fileFraction_ = value;
      return this;
    }
    public Builder ClearFileFraction() {
      PrepareBuilder();
      result.hasFileFraction = false;
      result.fileFraction_ = 0;
      return this;
    }
    
    public bool HasMd5 {
      get { return result.hasMd5; }
    }
    public pb::ByteString Md5 {
      get { return result.Md5; }
      set { SetMd5(value); }
    }
    public Builder SetMd5(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasMd5 = true;
      result.md5_ = value;
      return this;
    }
    public Builder ClearMd5() {
      PrepareBuilder();
      result.hasMd5 = false;
      result.md5_ = pb::ByteString.Empty;
      return this;
    }
    
    public bool HasCrc {
      get { return result.hasCrc; }
    }
    [global::System.CLSCompliant(false)]
    public uint Crc {
      get { return result.Crc; }
      set { SetCrc(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetCrc(uint value) {
      PrepareBuilder();
      result.hasCrc = true;
      result.crc_ = value;
      return this;
    }
    public Builder ClearCrc() {
      PrepareBuilder();
      result.hasCrc = false;
      result.crc_ = 0;
      return this;
    }
    
    public bool HasFileHashType {
      get { return result.hasFileHashType; }
    }
    public int FileHashType {
      get { return result.FileHashType; }
      set { SetFileHashType(value); }
    }
    public Builder SetFileHashType(int value) {
      PrepareBuilder();
      result.hasFileHashType = true;
      result.fileHashType_ = value;
      return this;
    }
    public Builder ClearFileHashType() {
      PrepareBuilder();
      result.hasFileHashType = false;
      result.fileHashType_ = 0;
      return this;
    }
    
    public bool HasFileLen {
      get { return result.hasFileLen; }
    }
    public int FileLen {
      get { return result.FileLen; }
      set { SetFileLen(value); }
    }
    public Builder SetFileLen(int value) {
      PrepareBuilder();
      result.hasFileLen = true;
      result.fileLen_ = value;
      return this;
    }
    public Builder ClearFileLen() {
      PrepareBuilder();
      result.hasFileLen = false;
      result.fileLen_ = 0;
      return this;
    }
    
    public bool HasPackFileId {
      get { return result.hasPackFileId; }
    }
    public int PackFileId {
      get { return result.PackFileId; }
      set { SetPackFileId(value); }
    }
    public Builder SetPackFileId(int value) {
      PrepareBuilder();
      result.hasPackFileId = true;
      result.packFileId_ = value;
      return this;
    }
    public Builder ClearPackFileId() {
      PrepareBuilder();
      result.hasPackFileId = false;
      result.packFileId_ = 0;
      return this;
    }
    
    public bool HasPackFileNumber {
      get { return result.hasPackFileNumber; }
    }
    public int PackFileNumber {
      get { return result.PackFileNumber; }
      set { SetPackFileNumber(value); }
    }
    public Builder SetPackFileNumber(int value) {
      PrepareBuilder();
      result.hasPackFileNumber = true;
      result.packFileNumber_ = value;
      return this;
    }
    public Builder ClearPackFileNumber() {
      PrepareBuilder();
      result.hasPackFileNumber = false;
      result.packFileNumber_ = 0;
      return this;
    }
  }
  static CCLCMsg_FileCRCCheck() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CCLCMsg_LoadingProgress : pb::GeneratedMessage<CCLCMsg_LoadingProgress, CCLCMsg_LoadingProgress.Builder> {
  private CCLCMsg_LoadingProgress() { }
  private static readonly CCLCMsg_LoadingProgress defaultInstance = new CCLCMsg_LoadingProgress().MakeReadOnly();
  private static readonly string[] _cCLCMsgLoadingProgressFieldNames = new string[] { "progress" };
  private static readonly uint[] _cCLCMsgLoadingProgressFieldTags = new uint[] { 8 };
  public static CCLCMsg_LoadingProgress DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CCLCMsg_LoadingProgress DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CCLCMsg_LoadingProgress ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CCLCMsg_LoadingProgress__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CCLCMsg_LoadingProgress, CCLCMsg_LoadingProgress.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CCLCMsg_LoadingProgress__FieldAccessorTable; }
  }
  
  public const int ProgressFieldNumber = 1;
  private bool hasProgress;
  private int progress_;
  public bool HasProgress {
    get { return hasProgress; }
  }
  public int Progress {
    get { return progress_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cCLCMsgLoadingProgressFieldNames;
    if (hasProgress) {
      output.WriteInt32(1, field_names[0], Progress);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasProgress) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, Progress);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CCLCMsg_LoadingProgress ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_LoadingProgress ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_LoadingProgress ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_LoadingProgress ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_LoadingProgress ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_LoadingProgress ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_LoadingProgress ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CCLCMsg_LoadingProgress ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CCLCMsg_LoadingProgress ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_LoadingProgress ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CCLCMsg_LoadingProgress MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CCLCMsg_LoadingProgress prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CCLCMsg_LoadingProgress, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CCLCMsg_LoadingProgress cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CCLCMsg_LoadingProgress result;
    
    private CCLCMsg_LoadingProgress PrepareBuilder() {
      if (resultIsReadOnly) {
        CCLCMsg_LoadingProgress original = result;
        result = new CCLCMsg_LoadingProgress();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CCLCMsg_LoadingProgress MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CCLCMsg_LoadingProgress.Descriptor; }
    }
    
    public override CCLCMsg_LoadingProgress DefaultInstanceForType {
      get { return global::CCLCMsg_LoadingProgress.DefaultInstance; }
    }
    
    public override CCLCMsg_LoadingProgress BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CCLCMsg_LoadingProgress) {
        return MergeFrom((CCLCMsg_LoadingProgress) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CCLCMsg_LoadingProgress other) {
      if (other == global::CCLCMsg_LoadingProgress.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasProgress) {
        Progress = other.Progress;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cCLCMsgLoadingProgressFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cCLCMsgLoadingProgressFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasProgress = input.ReadInt32(ref result.progress_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasProgress {
      get { return result.hasProgress; }
    }
    public int Progress {
      get { return result.Progress; }
      set { SetProgress(value); }
    }
    public Builder SetProgress(int value) {
      PrepareBuilder();
      result.hasProgress = true;
      result.progress_ = value;
      return this;
    }
    public Builder ClearProgress() {
      PrepareBuilder();
      result.hasProgress = false;
      result.progress_ = 0;
      return this;
    }
  }
  static CCLCMsg_LoadingProgress() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CCLCMsg_SplitPlayerConnect : pb::GeneratedMessage<CCLCMsg_SplitPlayerConnect, CCLCMsg_SplitPlayerConnect.Builder> {
  private CCLCMsg_SplitPlayerConnect() { }
  private static readonly CCLCMsg_SplitPlayerConnect defaultInstance = new CCLCMsg_SplitPlayerConnect().MakeReadOnly();
  private static readonly string[] _cCLCMsgSplitPlayerConnectFieldNames = new string[] { "convars" };
  private static readonly uint[] _cCLCMsgSplitPlayerConnectFieldTags = new uint[] { 10 };
  public static CCLCMsg_SplitPlayerConnect DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CCLCMsg_SplitPlayerConnect DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CCLCMsg_SplitPlayerConnect ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CCLCMsg_SplitPlayerConnect__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CCLCMsg_SplitPlayerConnect, CCLCMsg_SplitPlayerConnect.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CCLCMsg_SplitPlayerConnect__FieldAccessorTable; }
  }
  
  public const int ConvarsFieldNumber = 1;
  private bool hasConvars;
  private global::CMsg_CVars convars_;
  public bool HasConvars {
    get { return hasConvars; }
  }
  public global::CMsg_CVars Convars {
    get { return convars_ ?? global::CMsg_CVars.DefaultInstance; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cCLCMsgSplitPlayerConnectFieldNames;
    if (hasConvars) {
      output.WriteMessage(1, field_names[0], Convars);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasConvars) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Convars);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CCLCMsg_SplitPlayerConnect ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_SplitPlayerConnect ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_SplitPlayerConnect ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_SplitPlayerConnect ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_SplitPlayerConnect ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_SplitPlayerConnect ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_SplitPlayerConnect ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CCLCMsg_SplitPlayerConnect ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CCLCMsg_SplitPlayerConnect ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_SplitPlayerConnect ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CCLCMsg_SplitPlayerConnect MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CCLCMsg_SplitPlayerConnect prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CCLCMsg_SplitPlayerConnect, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CCLCMsg_SplitPlayerConnect cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CCLCMsg_SplitPlayerConnect result;
    
    private CCLCMsg_SplitPlayerConnect PrepareBuilder() {
      if (resultIsReadOnly) {
        CCLCMsg_SplitPlayerConnect original = result;
        result = new CCLCMsg_SplitPlayerConnect();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CCLCMsg_SplitPlayerConnect MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CCLCMsg_SplitPlayerConnect.Descriptor; }
    }
    
    public override CCLCMsg_SplitPlayerConnect DefaultInstanceForType {
      get { return global::CCLCMsg_SplitPlayerConnect.DefaultInstance; }
    }
    
    public override CCLCMsg_SplitPlayerConnect BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CCLCMsg_SplitPlayerConnect) {
        return MergeFrom((CCLCMsg_SplitPlayerConnect) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CCLCMsg_SplitPlayerConnect other) {
      if (other == global::CCLCMsg_SplitPlayerConnect.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasConvars) {
        MergeConvars(other.Convars);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cCLCMsgSplitPlayerConnectFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cCLCMsgSplitPlayerConnectFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            global::CMsg_CVars.Builder subBuilder = global::CMsg_CVars.CreateBuilder();
            if (result.hasConvars) {
              subBuilder.MergeFrom(Convars);
            }
            input.ReadMessage(subBuilder, extensionRegistry);
            Convars = subBuilder.BuildPartial();
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasConvars {
     get { return result.hasConvars; }
    }
    public global::CMsg_CVars Convars {
      get { return result.Convars; }
      set { SetConvars(value); }
    }
    public Builder SetConvars(global::CMsg_CVars value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasConvars = true;
      result.convars_ = value;
      return this;
    }
    public Builder SetConvars(global::CMsg_CVars.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.hasConvars = true;
      result.convars_ = builderForValue.Build();
      return this;
    }
    public Builder MergeConvars(global::CMsg_CVars value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      if (result.hasConvars &&
          result.convars_ != global::CMsg_CVars.DefaultInstance) {
          result.convars_ = global::CMsg_CVars.CreateBuilder(result.convars_).MergeFrom(value).BuildPartial();
      } else {
        result.convars_ = value;
      }
      result.hasConvars = true;
      return this;
    }
    public Builder ClearConvars() {
      PrepareBuilder();
      result.hasConvars = false;
      result.convars_ = null;
      return this;
    }
  }
  static CCLCMsg_SplitPlayerConnect() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CCLCMsg_CmdKeyValues : pb::GeneratedMessage<CCLCMsg_CmdKeyValues, CCLCMsg_CmdKeyValues.Builder> {
  private CCLCMsg_CmdKeyValues() { }
  private static readonly CCLCMsg_CmdKeyValues defaultInstance = new CCLCMsg_CmdKeyValues().MakeReadOnly();
  private static readonly string[] _cCLCMsgCmdKeyValuesFieldNames = new string[] { "keyvalues" };
  private static readonly uint[] _cCLCMsgCmdKeyValuesFieldTags = new uint[] { 10 };
  public static CCLCMsg_CmdKeyValues DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CCLCMsg_CmdKeyValues DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CCLCMsg_CmdKeyValues ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CCLCMsg_CmdKeyValues__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CCLCMsg_CmdKeyValues, CCLCMsg_CmdKeyValues.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CCLCMsg_CmdKeyValues__FieldAccessorTable; }
  }
  
  public const int KeyvaluesFieldNumber = 1;
  private bool hasKeyvalues;
  private pb::ByteString keyvalues_ = pb::ByteString.Empty;
  public bool HasKeyvalues {
    get { return hasKeyvalues; }
  }
  public pb::ByteString Keyvalues {
    get { return keyvalues_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cCLCMsgCmdKeyValuesFieldNames;
    if (hasKeyvalues) {
      output.WriteBytes(1, field_names[0], Keyvalues);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasKeyvalues) {
        size += pb::CodedOutputStream.ComputeBytesSize(1, Keyvalues);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CCLCMsg_CmdKeyValues ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_CmdKeyValues ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_CmdKeyValues ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CCLCMsg_CmdKeyValues ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_CmdKeyValues ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_CmdKeyValues ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CCLCMsg_CmdKeyValues ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CCLCMsg_CmdKeyValues ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CCLCMsg_CmdKeyValues ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CCLCMsg_CmdKeyValues ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CCLCMsg_CmdKeyValues MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CCLCMsg_CmdKeyValues prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CCLCMsg_CmdKeyValues, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CCLCMsg_CmdKeyValues cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CCLCMsg_CmdKeyValues result;
    
    private CCLCMsg_CmdKeyValues PrepareBuilder() {
      if (resultIsReadOnly) {
        CCLCMsg_CmdKeyValues original = result;
        result = new CCLCMsg_CmdKeyValues();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CCLCMsg_CmdKeyValues MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CCLCMsg_CmdKeyValues.Descriptor; }
    }
    
    public override CCLCMsg_CmdKeyValues DefaultInstanceForType {
      get { return global::CCLCMsg_CmdKeyValues.DefaultInstance; }
    }
    
    public override CCLCMsg_CmdKeyValues BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CCLCMsg_CmdKeyValues) {
        return MergeFrom((CCLCMsg_CmdKeyValues) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CCLCMsg_CmdKeyValues other) {
      if (other == global::CCLCMsg_CmdKeyValues.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasKeyvalues) {
        Keyvalues = other.Keyvalues;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cCLCMsgCmdKeyValuesFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cCLCMsgCmdKeyValuesFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasKeyvalues = input.ReadBytes(ref result.keyvalues_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasKeyvalues {
      get { return result.hasKeyvalues; }
    }
    public pb::ByteString Keyvalues {
      get { return result.Keyvalues; }
      set { SetKeyvalues(value); }
    }
    public Builder SetKeyvalues(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasKeyvalues = true;
      result.keyvalues_ = value;
      return this;
    }
    public Builder ClearKeyvalues() {
      PrepareBuilder();
      result.hasKeyvalues = false;
      result.keyvalues_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CCLCMsg_CmdKeyValues() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_ServerInfo : pb::GeneratedMessage<CSVCMsg_ServerInfo, CSVCMsg_ServerInfo.Builder> {
  private CSVCMsg_ServerInfo() { }
  private static readonly CSVCMsg_ServerInfo defaultInstance = new CSVCMsg_ServerInfo().MakeReadOnly();
  private static readonly string[] _cSVCMsgServerInfoFieldNames = new string[] { "c_os", "client_crc", "game_dir", "host_name", "is_dedicated", "is_hltv", "is_official_valve_server", "is_redirecting_to_proxy_relay", "is_replay", "map_crc", "map_group_name", "map_name", "max_classes", "max_clients", "player_slot", "protocol", "public_ip", "server_count", "sky_name", "string_table_crc", "tick_interval", "ugc_map_id" };
  private static readonly uint[] _cSVCMsgServerInfoFieldTags = new uint[] { 56, 77, 122, 154, 24, 40, 32, 168, 48, 69, 138, 130, 96, 88, 104, 8, 160, 16, 146, 85, 117, 176 };
  public static CSVCMsg_ServerInfo DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_ServerInfo DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_ServerInfo ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_ServerInfo__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_ServerInfo, CSVCMsg_ServerInfo.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_ServerInfo__FieldAccessorTable; }
  }
  
  public const int ProtocolFieldNumber = 1;
  private bool hasProtocol;
  private int protocol_;
  public bool HasProtocol {
    get { return hasProtocol; }
  }
  public int Protocol {
    get { return protocol_; }
  }
  
  public const int ServerCountFieldNumber = 2;
  private bool hasServerCount;
  private int serverCount_;
  public bool HasServerCount {
    get { return hasServerCount; }
  }
  public int ServerCount {
    get { return serverCount_; }
  }
  
  public const int IsDedicatedFieldNumber = 3;
  private bool hasIsDedicated;
  private bool isDedicated_;
  public bool HasIsDedicated {
    get { return hasIsDedicated; }
  }
  public bool IsDedicated {
    get { return isDedicated_; }
  }
  
  public const int IsOfficialValveServerFieldNumber = 4;
  private bool hasIsOfficialValveServer;
  private bool isOfficialValveServer_;
  public bool HasIsOfficialValveServer {
    get { return hasIsOfficialValveServer; }
  }
  public bool IsOfficialValveServer {
    get { return isOfficialValveServer_; }
  }
  
  public const int IsHltvFieldNumber = 5;
  private bool hasIsHltv;
  private bool isHltv_;
  public bool HasIsHltv {
    get { return hasIsHltv; }
  }
  public bool IsHltv {
    get { return isHltv_; }
  }
  
  public const int IsReplayFieldNumber = 6;
  private bool hasIsReplay;
  private bool isReplay_;
  public bool HasIsReplay {
    get { return hasIsReplay; }
  }
  public bool IsReplay {
    get { return isReplay_; }
  }
  
  public const int IsRedirectingToProxyRelayFieldNumber = 21;
  private bool hasIsRedirectingToProxyRelay;
  private bool isRedirectingToProxyRelay_;
  public bool HasIsRedirectingToProxyRelay {
    get { return hasIsRedirectingToProxyRelay; }
  }
  public bool IsRedirectingToProxyRelay {
    get { return isRedirectingToProxyRelay_; }
  }
  
  public const int COsFieldNumber = 7;
  private bool hasCOs;
  private int cOs_;
  public bool HasCOs {
    get { return hasCOs; }
  }
  public int COs {
    get { return cOs_; }
  }
  
  public const int MapCrcFieldNumber = 8;
  private bool hasMapCrc;
  private uint mapCrc_;
  public bool HasMapCrc {
    get { return hasMapCrc; }
  }
  [global::System.CLSCompliant(false)]
  public uint MapCrc {
    get { return mapCrc_; }
  }
  
  public const int ClientCrcFieldNumber = 9;
  private bool hasClientCrc;
  private uint clientCrc_;
  public bool HasClientCrc {
    get { return hasClientCrc; }
  }
  [global::System.CLSCompliant(false)]
  public uint ClientCrc {
    get { return clientCrc_; }
  }
  
  public const int StringTableCrcFieldNumber = 10;
  private bool hasStringTableCrc;
  private uint stringTableCrc_;
  public bool HasStringTableCrc {
    get { return hasStringTableCrc; }
  }
  [global::System.CLSCompliant(false)]
  public uint StringTableCrc {
    get { return stringTableCrc_; }
  }
  
  public const int MaxClientsFieldNumber = 11;
  private bool hasMaxClients;
  private int maxClients_;
  public bool HasMaxClients {
    get { return hasMaxClients; }
  }
  public int MaxClients {
    get { return maxClients_; }
  }
  
  public const int MaxClassesFieldNumber = 12;
  private bool hasMaxClasses;
  private int maxClasses_;
  public bool HasMaxClasses {
    get { return hasMaxClasses; }
  }
  public int MaxClasses {
    get { return maxClasses_; }
  }
  
  public const int PlayerSlotFieldNumber = 13;
  private bool hasPlayerSlot;
  private int playerSlot_;
  public bool HasPlayerSlot {
    get { return hasPlayerSlot; }
  }
  public int PlayerSlot {
    get { return playerSlot_; }
  }
  
  public const int TickIntervalFieldNumber = 14;
  private bool hasTickInterval;
  private float tickInterval_;
  public bool HasTickInterval {
    get { return hasTickInterval; }
  }
  public float TickInterval {
    get { return tickInterval_; }
  }
  
  public const int GameDirFieldNumber = 15;
  private bool hasGameDir;
  private string gameDir_ = "";
  public bool HasGameDir {
    get { return hasGameDir; }
  }
  public string GameDir {
    get { return gameDir_; }
  }
  
  public const int MapNameFieldNumber = 16;
  private bool hasMapName;
  private string mapName_ = "";
  public bool HasMapName {
    get { return hasMapName; }
  }
  public string MapName {
    get { return mapName_; }
  }
  
  public const int MapGroupNameFieldNumber = 17;
  private bool hasMapGroupName;
  private string mapGroupName_ = "";
  public bool HasMapGroupName {
    get { return hasMapGroupName; }
  }
  public string MapGroupName {
    get { return mapGroupName_; }
  }
  
  public const int SkyNameFieldNumber = 18;
  private bool hasSkyName;
  private string skyName_ = "";
  public bool HasSkyName {
    get { return hasSkyName; }
  }
  public string SkyName {
    get { return skyName_; }
  }
  
  public const int HostNameFieldNumber = 19;
  private bool hasHostName;
  private string hostName_ = "";
  public bool HasHostName {
    get { return hasHostName; }
  }
  public string HostName {
    get { return hostName_; }
  }
  
  public const int PublicIpFieldNumber = 20;
  private bool hasPublicIp;
  private uint publicIp_;
  public bool HasPublicIp {
    get { return hasPublicIp; }
  }
  [global::System.CLSCompliant(false)]
  public uint PublicIp {
    get { return publicIp_; }
  }
  
  public const int UgcMapIdFieldNumber = 22;
  private bool hasUgcMapId;
  private ulong ugcMapId_;
  public bool HasUgcMapId {
    get { return hasUgcMapId; }
  }
  [global::System.CLSCompliant(false)]
  public ulong UgcMapId {
    get { return ugcMapId_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgServerInfoFieldNames;
    if (hasProtocol) {
      output.WriteInt32(1, field_names[15], Protocol);
    }
    if (hasServerCount) {
      output.WriteInt32(2, field_names[17], ServerCount);
    }
    if (hasIsDedicated) {
      output.WriteBool(3, field_names[4], IsDedicated);
    }
    if (hasIsOfficialValveServer) {
      output.WriteBool(4, field_names[6], IsOfficialValveServer);
    }
    if (hasIsHltv) {
      output.WriteBool(5, field_names[5], IsHltv);
    }
    if (hasIsReplay) {
      output.WriteBool(6, field_names[8], IsReplay);
    }
    if (hasCOs) {
      output.WriteInt32(7, field_names[0], COs);
    }
    if (hasMapCrc) {
      output.WriteFixed32(8, field_names[9], MapCrc);
    }
    if (hasClientCrc) {
      output.WriteFixed32(9, field_names[1], ClientCrc);
    }
    if (hasStringTableCrc) {
      output.WriteFixed32(10, field_names[19], StringTableCrc);
    }
    if (hasMaxClients) {
      output.WriteInt32(11, field_names[13], MaxClients);
    }
    if (hasMaxClasses) {
      output.WriteInt32(12, field_names[12], MaxClasses);
    }
    if (hasPlayerSlot) {
      output.WriteInt32(13, field_names[14], PlayerSlot);
    }
    if (hasTickInterval) {
      output.WriteFloat(14, field_names[20], TickInterval);
    }
    if (hasGameDir) {
      output.WriteString(15, field_names[2], GameDir);
    }
    if (hasMapName) {
      output.WriteString(16, field_names[11], MapName);
    }
    if (hasMapGroupName) {
      output.WriteString(17, field_names[10], MapGroupName);
    }
    if (hasSkyName) {
      output.WriteString(18, field_names[18], SkyName);
    }
    if (hasHostName) {
      output.WriteString(19, field_names[3], HostName);
    }
    if (hasPublicIp) {
      output.WriteUInt32(20, field_names[16], PublicIp);
    }
    if (hasIsRedirectingToProxyRelay) {
      output.WriteBool(21, field_names[7], IsRedirectingToProxyRelay);
    }
    if (hasUgcMapId) {
      output.WriteUInt64(22, field_names[21], UgcMapId);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasProtocol) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, Protocol);
      }
      if (hasServerCount) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, ServerCount);
      }
      if (hasIsDedicated) {
        size += pb::CodedOutputStream.ComputeBoolSize(3, IsDedicated);
      }
      if (hasIsOfficialValveServer) {
        size += pb::CodedOutputStream.ComputeBoolSize(4, IsOfficialValveServer);
      }
      if (hasIsHltv) {
        size += pb::CodedOutputStream.ComputeBoolSize(5, IsHltv);
      }
      if (hasIsReplay) {
        size += pb::CodedOutputStream.ComputeBoolSize(6, IsReplay);
      }
      if (hasIsRedirectingToProxyRelay) {
        size += pb::CodedOutputStream.ComputeBoolSize(21, IsRedirectingToProxyRelay);
      }
      if (hasCOs) {
        size += pb::CodedOutputStream.ComputeInt32Size(7, COs);
      }
      if (hasMapCrc) {
        size += pb::CodedOutputStream.ComputeFixed32Size(8, MapCrc);
      }
      if (hasClientCrc) {
        size += pb::CodedOutputStream.ComputeFixed32Size(9, ClientCrc);
      }
      if (hasStringTableCrc) {
        size += pb::CodedOutputStream.ComputeFixed32Size(10, StringTableCrc);
      }
      if (hasMaxClients) {
        size += pb::CodedOutputStream.ComputeInt32Size(11, MaxClients);
      }
      if (hasMaxClasses) {
        size += pb::CodedOutputStream.ComputeInt32Size(12, MaxClasses);
      }
      if (hasPlayerSlot) {
        size += pb::CodedOutputStream.ComputeInt32Size(13, PlayerSlot);
      }
      if (hasTickInterval) {
        size += pb::CodedOutputStream.ComputeFloatSize(14, TickInterval);
      }
      if (hasGameDir) {
        size += pb::CodedOutputStream.ComputeStringSize(15, GameDir);
      }
      if (hasMapName) {
        size += pb::CodedOutputStream.ComputeStringSize(16, MapName);
      }
      if (hasMapGroupName) {
        size += pb::CodedOutputStream.ComputeStringSize(17, MapGroupName);
      }
      if (hasSkyName) {
        size += pb::CodedOutputStream.ComputeStringSize(18, SkyName);
      }
      if (hasHostName) {
        size += pb::CodedOutputStream.ComputeStringSize(19, HostName);
      }
      if (hasPublicIp) {
        size += pb::CodedOutputStream.ComputeUInt32Size(20, PublicIp);
      }
      if (hasUgcMapId) {
        size += pb::CodedOutputStream.ComputeUInt64Size(22, UgcMapId);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_ServerInfo ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_ServerInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_ServerInfo ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_ServerInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_ServerInfo ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_ServerInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_ServerInfo ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_ServerInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_ServerInfo ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_ServerInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_ServerInfo MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_ServerInfo prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_ServerInfo, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_ServerInfo cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_ServerInfo result;
    
    private CSVCMsg_ServerInfo PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_ServerInfo original = result;
        result = new CSVCMsg_ServerInfo();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_ServerInfo MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_ServerInfo.Descriptor; }
    }
    
    public override CSVCMsg_ServerInfo DefaultInstanceForType {
      get { return global::CSVCMsg_ServerInfo.DefaultInstance; }
    }
    
    public override CSVCMsg_ServerInfo BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_ServerInfo) {
        return MergeFrom((CSVCMsg_ServerInfo) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_ServerInfo other) {
      if (other == global::CSVCMsg_ServerInfo.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasProtocol) {
        Protocol = other.Protocol;
      }
      if (other.HasServerCount) {
        ServerCount = other.ServerCount;
      }
      if (other.HasIsDedicated) {
        IsDedicated = other.IsDedicated;
      }
      if (other.HasIsOfficialValveServer) {
        IsOfficialValveServer = other.IsOfficialValveServer;
      }
      if (other.HasIsHltv) {
        IsHltv = other.IsHltv;
      }
      if (other.HasIsReplay) {
        IsReplay = other.IsReplay;
      }
      if (other.HasIsRedirectingToProxyRelay) {
        IsRedirectingToProxyRelay = other.IsRedirectingToProxyRelay;
      }
      if (other.HasCOs) {
        COs = other.COs;
      }
      if (other.HasMapCrc) {
        MapCrc = other.MapCrc;
      }
      if (other.HasClientCrc) {
        ClientCrc = other.ClientCrc;
      }
      if (other.HasStringTableCrc) {
        StringTableCrc = other.StringTableCrc;
      }
      if (other.HasMaxClients) {
        MaxClients = other.MaxClients;
      }
      if (other.HasMaxClasses) {
        MaxClasses = other.MaxClasses;
      }
      if (other.HasPlayerSlot) {
        PlayerSlot = other.PlayerSlot;
      }
      if (other.HasTickInterval) {
        TickInterval = other.TickInterval;
      }
      if (other.HasGameDir) {
        GameDir = other.GameDir;
      }
      if (other.HasMapName) {
        MapName = other.MapName;
      }
      if (other.HasMapGroupName) {
        MapGroupName = other.MapGroupName;
      }
      if (other.HasSkyName) {
        SkyName = other.SkyName;
      }
      if (other.HasHostName) {
        HostName = other.HostName;
      }
      if (other.HasPublicIp) {
        PublicIp = other.PublicIp;
      }
      if (other.HasUgcMapId) {
        UgcMapId = other.UgcMapId;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgServerInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgServerInfoFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasProtocol = input.ReadInt32(ref result.protocol_);
            break;
          }
          case 16: {
            result.hasServerCount = input.ReadInt32(ref result.serverCount_);
            break;
          }
          case 24: {
            result.hasIsDedicated = input.ReadBool(ref result.isDedicated_);
            break;
          }
          case 32: {
            result.hasIsOfficialValveServer = input.ReadBool(ref result.isOfficialValveServer_);
            break;
          }
          case 40: {
            result.hasIsHltv = input.ReadBool(ref result.isHltv_);
            break;
          }
          case 48: {
            result.hasIsReplay = input.ReadBool(ref result.isReplay_);
            break;
          }
          case 56: {
            result.hasCOs = input.ReadInt32(ref result.cOs_);
            break;
          }
          case 69: {
            result.hasMapCrc = input.ReadFixed32(ref result.mapCrc_);
            break;
          }
          case 77: {
            result.hasClientCrc = input.ReadFixed32(ref result.clientCrc_);
            break;
          }
          case 85: {
            result.hasStringTableCrc = input.ReadFixed32(ref result.stringTableCrc_);
            break;
          }
          case 88: {
            result.hasMaxClients = input.ReadInt32(ref result.maxClients_);
            break;
          }
          case 96: {
            result.hasMaxClasses = input.ReadInt32(ref result.maxClasses_);
            break;
          }
          case 104: {
            result.hasPlayerSlot = input.ReadInt32(ref result.playerSlot_);
            break;
          }
          case 117: {
            result.hasTickInterval = input.ReadFloat(ref result.tickInterval_);
            break;
          }
          case 122: {
            result.hasGameDir = input.ReadString(ref result.gameDir_);
            break;
          }
          case 130: {
            result.hasMapName = input.ReadString(ref result.mapName_);
            break;
          }
          case 138: {
            result.hasMapGroupName = input.ReadString(ref result.mapGroupName_);
            break;
          }
          case 146: {
            result.hasSkyName = input.ReadString(ref result.skyName_);
            break;
          }
          case 154: {
            result.hasHostName = input.ReadString(ref result.hostName_);
            break;
          }
          case 160: {
            result.hasPublicIp = input.ReadUInt32(ref result.publicIp_);
            break;
          }
          case 168: {
            result.hasIsRedirectingToProxyRelay = input.ReadBool(ref result.isRedirectingToProxyRelay_);
            break;
          }
          case 176: {
            result.hasUgcMapId = input.ReadUInt64(ref result.ugcMapId_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasProtocol {
      get { return result.hasProtocol; }
    }
    public int Protocol {
      get { return result.Protocol; }
      set { SetProtocol(value); }
    }
    public Builder SetProtocol(int value) {
      PrepareBuilder();
      result.hasProtocol = true;
      result.protocol_ = value;
      return this;
    }
    public Builder ClearProtocol() {
      PrepareBuilder();
      result.hasProtocol = false;
      result.protocol_ = 0;
      return this;
    }
    
    public bool HasServerCount {
      get { return result.hasServerCount; }
    }
    public int ServerCount {
      get { return result.ServerCount; }
      set { SetServerCount(value); }
    }
    public Builder SetServerCount(int value) {
      PrepareBuilder();
      result.hasServerCount = true;
      result.serverCount_ = value;
      return this;
    }
    public Builder ClearServerCount() {
      PrepareBuilder();
      result.hasServerCount = false;
      result.serverCount_ = 0;
      return this;
    }
    
    public bool HasIsDedicated {
      get { return result.hasIsDedicated; }
    }
    public bool IsDedicated {
      get { return result.IsDedicated; }
      set { SetIsDedicated(value); }
    }
    public Builder SetIsDedicated(bool value) {
      PrepareBuilder();
      result.hasIsDedicated = true;
      result.isDedicated_ = value;
      return this;
    }
    public Builder ClearIsDedicated() {
      PrepareBuilder();
      result.hasIsDedicated = false;
      result.isDedicated_ = false;
      return this;
    }
    
    public bool HasIsOfficialValveServer {
      get { return result.hasIsOfficialValveServer; }
    }
    public bool IsOfficialValveServer {
      get { return result.IsOfficialValveServer; }
      set { SetIsOfficialValveServer(value); }
    }
    public Builder SetIsOfficialValveServer(bool value) {
      PrepareBuilder();
      result.hasIsOfficialValveServer = true;
      result.isOfficialValveServer_ = value;
      return this;
    }
    public Builder ClearIsOfficialValveServer() {
      PrepareBuilder();
      result.hasIsOfficialValveServer = false;
      result.isOfficialValveServer_ = false;
      return this;
    }
    
    public bool HasIsHltv {
      get { return result.hasIsHltv; }
    }
    public bool IsHltv {
      get { return result.IsHltv; }
      set { SetIsHltv(value); }
    }
    public Builder SetIsHltv(bool value) {
      PrepareBuilder();
      result.hasIsHltv = true;
      result.isHltv_ = value;
      return this;
    }
    public Builder ClearIsHltv() {
      PrepareBuilder();
      result.hasIsHltv = false;
      result.isHltv_ = false;
      return this;
    }
    
    public bool HasIsReplay {
      get { return result.hasIsReplay; }
    }
    public bool IsReplay {
      get { return result.IsReplay; }
      set { SetIsReplay(value); }
    }
    public Builder SetIsReplay(bool value) {
      PrepareBuilder();
      result.hasIsReplay = true;
      result.isReplay_ = value;
      return this;
    }
    public Builder ClearIsReplay() {
      PrepareBuilder();
      result.hasIsReplay = false;
      result.isReplay_ = false;
      return this;
    }
    
    public bool HasIsRedirectingToProxyRelay {
      get { return result.hasIsRedirectingToProxyRelay; }
    }
    public bool IsRedirectingToProxyRelay {
      get { return result.IsRedirectingToProxyRelay; }
      set { SetIsRedirectingToProxyRelay(value); }
    }
    public Builder SetIsRedirectingToProxyRelay(bool value) {
      PrepareBuilder();
      result.hasIsRedirectingToProxyRelay = true;
      result.isRedirectingToProxyRelay_ = value;
      return this;
    }
    public Builder ClearIsRedirectingToProxyRelay() {
      PrepareBuilder();
      result.hasIsRedirectingToProxyRelay = false;
      result.isRedirectingToProxyRelay_ = false;
      return this;
    }
    
    public bool HasCOs {
      get { return result.hasCOs; }
    }
    public int COs {
      get { return result.COs; }
      set { SetCOs(value); }
    }
    public Builder SetCOs(int value) {
      PrepareBuilder();
      result.hasCOs = true;
      result.cOs_ = value;
      return this;
    }
    public Builder ClearCOs() {
      PrepareBuilder();
      result.hasCOs = false;
      result.cOs_ = 0;
      return this;
    }
    
    public bool HasMapCrc {
      get { return result.hasMapCrc; }
    }
    [global::System.CLSCompliant(false)]
    public uint MapCrc {
      get { return result.MapCrc; }
      set { SetMapCrc(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetMapCrc(uint value) {
      PrepareBuilder();
      result.hasMapCrc = true;
      result.mapCrc_ = value;
      return this;
    }
    public Builder ClearMapCrc() {
      PrepareBuilder();
      result.hasMapCrc = false;
      result.mapCrc_ = 0;
      return this;
    }
    
    public bool HasClientCrc {
      get { return result.hasClientCrc; }
    }
    [global::System.CLSCompliant(false)]
    public uint ClientCrc {
      get { return result.ClientCrc; }
      set { SetClientCrc(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetClientCrc(uint value) {
      PrepareBuilder();
      result.hasClientCrc = true;
      result.clientCrc_ = value;
      return this;
    }
    public Builder ClearClientCrc() {
      PrepareBuilder();
      result.hasClientCrc = false;
      result.clientCrc_ = 0;
      return this;
    }
    
    public bool HasStringTableCrc {
      get { return result.hasStringTableCrc; }
    }
    [global::System.CLSCompliant(false)]
    public uint StringTableCrc {
      get { return result.StringTableCrc; }
      set { SetStringTableCrc(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetStringTableCrc(uint value) {
      PrepareBuilder();
      result.hasStringTableCrc = true;
      result.stringTableCrc_ = value;
      return this;
    }
    public Builder ClearStringTableCrc() {
      PrepareBuilder();
      result.hasStringTableCrc = false;
      result.stringTableCrc_ = 0;
      return this;
    }
    
    public bool HasMaxClients {
      get { return result.hasMaxClients; }
    }
    public int MaxClients {
      get { return result.MaxClients; }
      set { SetMaxClients(value); }
    }
    public Builder SetMaxClients(int value) {
      PrepareBuilder();
      result.hasMaxClients = true;
      result.maxClients_ = value;
      return this;
    }
    public Builder ClearMaxClients() {
      PrepareBuilder();
      result.hasMaxClients = false;
      result.maxClients_ = 0;
      return this;
    }
    
    public bool HasMaxClasses {
      get { return result.hasMaxClasses; }
    }
    public int MaxClasses {
      get { return result.MaxClasses; }
      set { SetMaxClasses(value); }
    }
    public Builder SetMaxClasses(int value) {
      PrepareBuilder();
      result.hasMaxClasses = true;
      result.maxClasses_ = value;
      return this;
    }
    public Builder ClearMaxClasses() {
      PrepareBuilder();
      result.hasMaxClasses = false;
      result.maxClasses_ = 0;
      return this;
    }
    
    public bool HasPlayerSlot {
      get { return result.hasPlayerSlot; }
    }
    public int PlayerSlot {
      get { return result.PlayerSlot; }
      set { SetPlayerSlot(value); }
    }
    public Builder SetPlayerSlot(int value) {
      PrepareBuilder();
      result.hasPlayerSlot = true;
      result.playerSlot_ = value;
      return this;
    }
    public Builder ClearPlayerSlot() {
      PrepareBuilder();
      result.hasPlayerSlot = false;
      result.playerSlot_ = 0;
      return this;
    }
    
    public bool HasTickInterval {
      get { return result.hasTickInterval; }
    }
    public float TickInterval {
      get { return result.TickInterval; }
      set { SetTickInterval(value); }
    }
    public Builder SetTickInterval(float value) {
      PrepareBuilder();
      result.hasTickInterval = true;
      result.tickInterval_ = value;
      return this;
    }
    public Builder ClearTickInterval() {
      PrepareBuilder();
      result.hasTickInterval = false;
      result.tickInterval_ = 0F;
      return this;
    }
    
    public bool HasGameDir {
      get { return result.hasGameDir; }
    }
    public string GameDir {
      get { return result.GameDir; }
      set { SetGameDir(value); }
    }
    public Builder SetGameDir(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasGameDir = true;
      result.gameDir_ = value;
      return this;
    }
    public Builder ClearGameDir() {
      PrepareBuilder();
      result.hasGameDir = false;
      result.gameDir_ = "";
      return this;
    }
    
    public bool HasMapName {
      get { return result.hasMapName; }
    }
    public string MapName {
      get { return result.MapName; }
      set { SetMapName(value); }
    }
    public Builder SetMapName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasMapName = true;
      result.mapName_ = value;
      return this;
    }
    public Builder ClearMapName() {
      PrepareBuilder();
      result.hasMapName = false;
      result.mapName_ = "";
      return this;
    }
    
    public bool HasMapGroupName {
      get { return result.hasMapGroupName; }
    }
    public string MapGroupName {
      get { return result.MapGroupName; }
      set { SetMapGroupName(value); }
    }
    public Builder SetMapGroupName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasMapGroupName = true;
      result.mapGroupName_ = value;
      return this;
    }
    public Builder ClearMapGroupName() {
      PrepareBuilder();
      result.hasMapGroupName = false;
      result.mapGroupName_ = "";
      return this;
    }
    
    public bool HasSkyName {
      get { return result.hasSkyName; }
    }
    public string SkyName {
      get { return result.SkyName; }
      set { SetSkyName(value); }
    }
    public Builder SetSkyName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasSkyName = true;
      result.skyName_ = value;
      return this;
    }
    public Builder ClearSkyName() {
      PrepareBuilder();
      result.hasSkyName = false;
      result.skyName_ = "";
      return this;
    }
    
    public bool HasHostName {
      get { return result.hasHostName; }
    }
    public string HostName {
      get { return result.HostName; }
      set { SetHostName(value); }
    }
    public Builder SetHostName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasHostName = true;
      result.hostName_ = value;
      return this;
    }
    public Builder ClearHostName() {
      PrepareBuilder();
      result.hasHostName = false;
      result.hostName_ = "";
      return this;
    }
    
    public bool HasPublicIp {
      get { return result.hasPublicIp; }
    }
    [global::System.CLSCompliant(false)]
    public uint PublicIp {
      get { return result.PublicIp; }
      set { SetPublicIp(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetPublicIp(uint value) {
      PrepareBuilder();
      result.hasPublicIp = true;
      result.publicIp_ = value;
      return this;
    }
    public Builder ClearPublicIp() {
      PrepareBuilder();
      result.hasPublicIp = false;
      result.publicIp_ = 0;
      return this;
    }
    
    public bool HasUgcMapId {
      get { return result.hasUgcMapId; }
    }
    [global::System.CLSCompliant(false)]
    public ulong UgcMapId {
      get { return result.UgcMapId; }
      set { SetUgcMapId(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetUgcMapId(ulong value) {
      PrepareBuilder();
      result.hasUgcMapId = true;
      result.ugcMapId_ = value;
      return this;
    }
    public Builder ClearUgcMapId() {
      PrepareBuilder();
      result.hasUgcMapId = false;
      result.ugcMapId_ = 0UL;
      return this;
    }
  }
  static CSVCMsg_ServerInfo() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_ClassInfo : pb::GeneratedMessage<CSVCMsg_ClassInfo, CSVCMsg_ClassInfo.Builder> {
  private CSVCMsg_ClassInfo() { }
  private static readonly CSVCMsg_ClassInfo defaultInstance = new CSVCMsg_ClassInfo().MakeReadOnly();
  private static readonly string[] _cSVCMsgClassInfoFieldNames = new string[] { "classes", "create_on_client" };
  private static readonly uint[] _cSVCMsgClassInfoFieldTags = new uint[] { 18, 8 };
  public static CSVCMsg_ClassInfo DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_ClassInfo DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_ClassInfo ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_ClassInfo__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_ClassInfo, CSVCMsg_ClassInfo.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_ClassInfo__FieldAccessorTable; }
  }
  
  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class class_t : pb::GeneratedMessage<class_t, class_t.Builder> {
      private class_t() { }
      private static readonly class_t defaultInstance = new class_t().MakeReadOnly();
      private static readonly string[] _classTFieldNames = new string[] { "class_id", "class_name", "data_table_name" };
      private static readonly uint[] _classTFieldTags = new uint[] { 8, 26, 18 };
      public static class_t DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override class_t DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override class_t ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Netmessages.internal__static_CSVCMsg_ClassInfo_class_t__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<class_t, class_t.Builder> InternalFieldAccessors {
        get { return global::Netmessages.internal__static_CSVCMsg_ClassInfo_class_t__FieldAccessorTable; }
      }
      
      public const int ClassIdFieldNumber = 1;
      private bool hasClassId;
      private int classId_;
      public bool HasClassId {
        get { return hasClassId; }
      }
      public int ClassId {
        get { return classId_; }
      }
      
      public const int DataTableNameFieldNumber = 2;
      private bool hasDataTableName;
      private string dataTableName_ = "";
      public bool HasDataTableName {
        get { return hasDataTableName; }
      }
      public string DataTableName {
        get { return dataTableName_; }
      }
      
      public const int ClassNameFieldNumber = 3;
      private bool hasClassName;
      private string className_ = "";
      public bool HasClassName {
        get { return hasClassName; }
      }
      public string ClassName {
        get { return className_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _classTFieldNames;
        if (hasClassId) {
          output.WriteInt32(1, field_names[0], ClassId);
        }
        if (hasDataTableName) {
          output.WriteString(2, field_names[2], DataTableName);
        }
        if (hasClassName) {
          output.WriteString(3, field_names[1], ClassName);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasClassId) {
            size += pb::CodedOutputStream.ComputeInt32Size(1, ClassId);
          }
          if (hasDataTableName) {
            size += pb::CodedOutputStream.ComputeStringSize(2, DataTableName);
          }
          if (hasClassName) {
            size += pb::CodedOutputStream.ComputeStringSize(3, ClassName);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static class_t ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static class_t ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static class_t ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static class_t ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static class_t ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static class_t ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static class_t ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static class_t ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static class_t ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static class_t ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private class_t MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(class_t prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<class_t, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(class_t cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private class_t result;
        
        private class_t PrepareBuilder() {
          if (resultIsReadOnly) {
            class_t original = result;
            result = new class_t();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override class_t MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::CSVCMsg_ClassInfo.Types.class_t.Descriptor; }
        }
        
        public override class_t DefaultInstanceForType {
          get { return global::CSVCMsg_ClassInfo.Types.class_t.DefaultInstance; }
        }
        
        public override class_t BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is class_t) {
            return MergeFrom((class_t) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(class_t other) {
          if (other == global::CSVCMsg_ClassInfo.Types.class_t.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasClassId) {
            ClassId = other.ClassId;
          }
          if (other.HasDataTableName) {
            DataTableName = other.DataTableName;
          }
          if (other.HasClassName) {
            ClassName = other.ClassName;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_classTFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _classTFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasClassId = input.ReadInt32(ref result.classId_);
                break;
              }
              case 18: {
                result.hasDataTableName = input.ReadString(ref result.dataTableName_);
                break;
              }
              case 26: {
                result.hasClassName = input.ReadString(ref result.className_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasClassId {
          get { return result.hasClassId; }
        }
        public int ClassId {
          get { return result.ClassId; }
          set { SetClassId(value); }
        }
        public Builder SetClassId(int value) {
          PrepareBuilder();
          result.hasClassId = true;
          result.classId_ = value;
          return this;
        }
        public Builder ClearClassId() {
          PrepareBuilder();
          result.hasClassId = false;
          result.classId_ = 0;
          return this;
        }
        
        public bool HasDataTableName {
          get { return result.hasDataTableName; }
        }
        public string DataTableName {
          get { return result.DataTableName; }
          set { SetDataTableName(value); }
        }
        public Builder SetDataTableName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasDataTableName = true;
          result.dataTableName_ = value;
          return this;
        }
        public Builder ClearDataTableName() {
          PrepareBuilder();
          result.hasDataTableName = false;
          result.dataTableName_ = "";
          return this;
        }
        
        public bool HasClassName {
          get { return result.hasClassName; }
        }
        public string ClassName {
          get { return result.ClassName; }
          set { SetClassName(value); }
        }
        public Builder SetClassName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasClassName = true;
          result.className_ = value;
          return this;
        }
        public Builder ClearClassName() {
          PrepareBuilder();
          result.hasClassName = false;
          result.className_ = "";
          return this;
        }
      }
      static class_t() {
        object.ReferenceEquals(global::Netmessages.Descriptor, null);
      }
    }
    
  }
  #endregion
  
  public const int CreateOnClientFieldNumber = 1;
  private bool hasCreateOnClient;
  private bool createOnClient_;
  public bool HasCreateOnClient {
    get { return hasCreateOnClient; }
  }
  public bool CreateOnClient {
    get { return createOnClient_; }
  }
  
  public const int ClassesFieldNumber = 2;
  private pbc::PopsicleList<global::CSVCMsg_ClassInfo.Types.class_t> classes_ = new pbc::PopsicleList<global::CSVCMsg_ClassInfo.Types.class_t>();
  public scg::IList<global::CSVCMsg_ClassInfo.Types.class_t> ClassesList {
    get { return classes_; }
  }
  public int ClassesCount {
    get { return classes_.Count; }
  }
  public global::CSVCMsg_ClassInfo.Types.class_t GetClasses(int index) {
    return classes_[index];
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgClassInfoFieldNames;
    if (hasCreateOnClient) {
      output.WriteBool(1, field_names[1], CreateOnClient);
    }
    if (classes_.Count > 0) {
      output.WriteMessageArray(2, field_names[0], classes_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCreateOnClient) {
        size += pb::CodedOutputStream.ComputeBoolSize(1, CreateOnClient);
      }
      foreach (global::CSVCMsg_ClassInfo.Types.class_t element in ClassesList) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_ClassInfo ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_ClassInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_ClassInfo ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_ClassInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_ClassInfo ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_ClassInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_ClassInfo ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_ClassInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_ClassInfo ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_ClassInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_ClassInfo MakeReadOnly() {
    classes_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_ClassInfo prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_ClassInfo, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_ClassInfo cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_ClassInfo result;
    
    private CSVCMsg_ClassInfo PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_ClassInfo original = result;
        result = new CSVCMsg_ClassInfo();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_ClassInfo MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_ClassInfo.Descriptor; }
    }
    
    public override CSVCMsg_ClassInfo DefaultInstanceForType {
      get { return global::CSVCMsg_ClassInfo.DefaultInstance; }
    }
    
    public override CSVCMsg_ClassInfo BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_ClassInfo) {
        return MergeFrom((CSVCMsg_ClassInfo) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_ClassInfo other) {
      if (other == global::CSVCMsg_ClassInfo.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasCreateOnClient) {
        CreateOnClient = other.CreateOnClient;
      }
      if (other.classes_.Count != 0) {
        result.classes_.Add(other.classes_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgClassInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgClassInfoFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasCreateOnClient = input.ReadBool(ref result.createOnClient_);
            break;
          }
          case 18: {
            input.ReadMessageArray(tag, field_name, result.classes_, global::CSVCMsg_ClassInfo.Types.class_t.DefaultInstance, extensionRegistry);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasCreateOnClient {
      get { return result.hasCreateOnClient; }
    }
    public bool CreateOnClient {
      get { return result.CreateOnClient; }
      set { SetCreateOnClient(value); }
    }
    public Builder SetCreateOnClient(bool value) {
      PrepareBuilder();
      result.hasCreateOnClient = true;
      result.createOnClient_ = value;
      return this;
    }
    public Builder ClearCreateOnClient() {
      PrepareBuilder();
      result.hasCreateOnClient = false;
      result.createOnClient_ = false;
      return this;
    }
    
    public pbc::IPopsicleList<global::CSVCMsg_ClassInfo.Types.class_t> ClassesList {
      get { return PrepareBuilder().classes_; }
    }
    public int ClassesCount {
      get { return result.ClassesCount; }
    }
    public global::CSVCMsg_ClassInfo.Types.class_t GetClasses(int index) {
      return result.GetClasses(index);
    }
    public Builder SetClasses(int index, global::CSVCMsg_ClassInfo.Types.class_t value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.classes_[index] = value;
      return this;
    }
    public Builder SetClasses(int index, global::CSVCMsg_ClassInfo.Types.class_t.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.classes_[index] = builderForValue.Build();
      return this;
    }
    public Builder AddClasses(global::CSVCMsg_ClassInfo.Types.class_t value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.classes_.Add(value);
      return this;
    }
    public Builder AddClasses(global::CSVCMsg_ClassInfo.Types.class_t.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.classes_.Add(builderForValue.Build());
      return this;
    }
    public Builder AddRangeClasses(scg::IEnumerable<global::CSVCMsg_ClassInfo.Types.class_t> values) {
      PrepareBuilder();
      result.classes_.Add(values);
      return this;
    }
    public Builder ClearClasses() {
      PrepareBuilder();
      result.classes_.Clear();
      return this;
    }
  }
  static CSVCMsg_ClassInfo() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_SendTable : pb::GeneratedMessage<CSVCMsg_SendTable, CSVCMsg_SendTable.Builder> {
  private CSVCMsg_SendTable() { }
  private static readonly CSVCMsg_SendTable defaultInstance = new CSVCMsg_SendTable().MakeReadOnly();
  private static readonly string[] _cSVCMsgSendTableFieldNames = new string[] { "is_end", "needs_decoder", "net_table_name", "props" };
  private static readonly uint[] _cSVCMsgSendTableFieldTags = new uint[] { 8, 24, 18, 34 };
  public static CSVCMsg_SendTable DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_SendTable DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_SendTable ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_SendTable__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_SendTable, CSVCMsg_SendTable.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_SendTable__FieldAccessorTable; }
  }
  
  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class sendprop_t : pb::GeneratedMessage<sendprop_t, sendprop_t.Builder> {
      private sendprop_t() { }
      private static readonly sendprop_t defaultInstance = new sendprop_t().MakeReadOnly();
      private static readonly string[] _sendpropTFieldNames = new string[] { "dt_name", "flags", "high_value", "low_value", "num_bits", "num_elements", "priority", "type", "var_name" };
      private static readonly uint[] _sendpropTFieldTags = new uint[] { 42, 24, 69, 61, 72, 48, 32, 8, 18 };
      public static sendprop_t DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override sendprop_t DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override sendprop_t ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Netmessages.internal__static_CSVCMsg_SendTable_sendprop_t__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<sendprop_t, sendprop_t.Builder> InternalFieldAccessors {
        get { return global::Netmessages.internal__static_CSVCMsg_SendTable_sendprop_t__FieldAccessorTable; }
      }
      
      public const int TypeFieldNumber = 1;
      private bool hasType;
      private int type_;
      public bool HasType {
        get { return hasType; }
      }
      public int Type {
        get { return type_; }
      }
      
      public const int VarNameFieldNumber = 2;
      private bool hasVarName;
      private string varName_ = "";
      public bool HasVarName {
        get { return hasVarName; }
      }
      public string VarName {
        get { return varName_; }
      }
      
      public const int FlagsFieldNumber = 3;
      private bool hasFlags;
      private int flags_;
      public bool HasFlags {
        get { return hasFlags; }
      }
      public int Flags {
        get { return flags_; }
      }
      
      public const int PriorityFieldNumber = 4;
      private bool hasPriority;
      private int priority_;
      public bool HasPriority {
        get { return hasPriority; }
      }
      public int Priority {
        get { return priority_; }
      }
      
      public const int DtNameFieldNumber = 5;
      private bool hasDtName;
      private string dtName_ = "";
      public bool HasDtName {
        get { return hasDtName; }
      }
      public string DtName {
        get { return dtName_; }
      }
      
      public const int NumElementsFieldNumber = 6;
      private bool hasNumElements;
      private int numElements_;
      public bool HasNumElements {
        get { return hasNumElements; }
      }
      public int NumElements {
        get { return numElements_; }
      }
      
      public const int LowValueFieldNumber = 7;
      private bool hasLowValue;
      private float lowValue_;
      public bool HasLowValue {
        get { return hasLowValue; }
      }
      public float LowValue {
        get { return lowValue_; }
      }
      
      public const int HighValueFieldNumber = 8;
      private bool hasHighValue;
      private float highValue_;
      public bool HasHighValue {
        get { return hasHighValue; }
      }
      public float HighValue {
        get { return highValue_; }
      }
      
      public const int NumBitsFieldNumber = 9;
      private bool hasNumBits;
      private int numBits_;
      public bool HasNumBits {
        get { return hasNumBits; }
      }
      public int NumBits {
        get { return numBits_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _sendpropTFieldNames;
        if (hasType) {
          output.WriteInt32(1, field_names[7], Type);
        }
        if (hasVarName) {
          output.WriteString(2, field_names[8], VarName);
        }
        if (hasFlags) {
          output.WriteInt32(3, field_names[1], Flags);
        }
        if (hasPriority) {
          output.WriteInt32(4, field_names[6], Priority);
        }
        if (hasDtName) {
          output.WriteString(5, field_names[0], DtName);
        }
        if (hasNumElements) {
          output.WriteInt32(6, field_names[5], NumElements);
        }
        if (hasLowValue) {
          output.WriteFloat(7, field_names[3], LowValue);
        }
        if (hasHighValue) {
          output.WriteFloat(8, field_names[2], HighValue);
        }
        if (hasNumBits) {
          output.WriteInt32(9, field_names[4], NumBits);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasType) {
            size += pb::CodedOutputStream.ComputeInt32Size(1, Type);
          }
          if (hasVarName) {
            size += pb::CodedOutputStream.ComputeStringSize(2, VarName);
          }
          if (hasFlags) {
            size += pb::CodedOutputStream.ComputeInt32Size(3, Flags);
          }
          if (hasPriority) {
            size += pb::CodedOutputStream.ComputeInt32Size(4, Priority);
          }
          if (hasDtName) {
            size += pb::CodedOutputStream.ComputeStringSize(5, DtName);
          }
          if (hasNumElements) {
            size += pb::CodedOutputStream.ComputeInt32Size(6, NumElements);
          }
          if (hasLowValue) {
            size += pb::CodedOutputStream.ComputeFloatSize(7, LowValue);
          }
          if (hasHighValue) {
            size += pb::CodedOutputStream.ComputeFloatSize(8, HighValue);
          }
          if (hasNumBits) {
            size += pb::CodedOutputStream.ComputeInt32Size(9, NumBits);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static sendprop_t ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static sendprop_t ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static sendprop_t ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static sendprop_t ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static sendprop_t ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static sendprop_t ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static sendprop_t ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static sendprop_t ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static sendprop_t ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static sendprop_t ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private sendprop_t MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(sendprop_t prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<sendprop_t, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(sendprop_t cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private sendprop_t result;
        
        private sendprop_t PrepareBuilder() {
          if (resultIsReadOnly) {
            sendprop_t original = result;
            result = new sendprop_t();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override sendprop_t MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::CSVCMsg_SendTable.Types.sendprop_t.Descriptor; }
        }
        
        public override sendprop_t DefaultInstanceForType {
          get { return global::CSVCMsg_SendTable.Types.sendprop_t.DefaultInstance; }
        }
        
        public override sendprop_t BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is sendprop_t) {
            return MergeFrom((sendprop_t) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(sendprop_t other) {
          if (other == global::CSVCMsg_SendTable.Types.sendprop_t.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasType) {
            Type = other.Type;
          }
          if (other.HasVarName) {
            VarName = other.VarName;
          }
          if (other.HasFlags) {
            Flags = other.Flags;
          }
          if (other.HasPriority) {
            Priority = other.Priority;
          }
          if (other.HasDtName) {
            DtName = other.DtName;
          }
          if (other.HasNumElements) {
            NumElements = other.NumElements;
          }
          if (other.HasLowValue) {
            LowValue = other.LowValue;
          }
          if (other.HasHighValue) {
            HighValue = other.HighValue;
          }
          if (other.HasNumBits) {
            NumBits = other.NumBits;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_sendpropTFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _sendpropTFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasType = input.ReadInt32(ref result.type_);
                break;
              }
              case 18: {
                result.hasVarName = input.ReadString(ref result.varName_);
                break;
              }
              case 24: {
                result.hasFlags = input.ReadInt32(ref result.flags_);
                break;
              }
              case 32: {
                result.hasPriority = input.ReadInt32(ref result.priority_);
                break;
              }
              case 42: {
                result.hasDtName = input.ReadString(ref result.dtName_);
                break;
              }
              case 48: {
                result.hasNumElements = input.ReadInt32(ref result.numElements_);
                break;
              }
              case 61: {
                result.hasLowValue = input.ReadFloat(ref result.lowValue_);
                break;
              }
              case 69: {
                result.hasHighValue = input.ReadFloat(ref result.highValue_);
                break;
              }
              case 72: {
                result.hasNumBits = input.ReadInt32(ref result.numBits_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasType {
          get { return result.hasType; }
        }
        public int Type {
          get { return result.Type; }
          set { SetType(value); }
        }
        public Builder SetType(int value) {
          PrepareBuilder();
          result.hasType = true;
          result.type_ = value;
          return this;
        }
        public Builder ClearType() {
          PrepareBuilder();
          result.hasType = false;
          result.type_ = 0;
          return this;
        }
        
        public bool HasVarName {
          get { return result.hasVarName; }
        }
        public string VarName {
          get { return result.VarName; }
          set { SetVarName(value); }
        }
        public Builder SetVarName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasVarName = true;
          result.varName_ = value;
          return this;
        }
        public Builder ClearVarName() {
          PrepareBuilder();
          result.hasVarName = false;
          result.varName_ = "";
          return this;
        }
        
        public bool HasFlags {
          get { return result.hasFlags; }
        }
        public int Flags {
          get { return result.Flags; }
          set { SetFlags(value); }
        }
        public Builder SetFlags(int value) {
          PrepareBuilder();
          result.hasFlags = true;
          result.flags_ = value;
          return this;
        }
        public Builder ClearFlags() {
          PrepareBuilder();
          result.hasFlags = false;
          result.flags_ = 0;
          return this;
        }
        
        public bool HasPriority {
          get { return result.hasPriority; }
        }
        public int Priority {
          get { return result.Priority; }
          set { SetPriority(value); }
        }
        public Builder SetPriority(int value) {
          PrepareBuilder();
          result.hasPriority = true;
          result.priority_ = value;
          return this;
        }
        public Builder ClearPriority() {
          PrepareBuilder();
          result.hasPriority = false;
          result.priority_ = 0;
          return this;
        }
        
        public bool HasDtName {
          get { return result.hasDtName; }
        }
        public string DtName {
          get { return result.DtName; }
          set { SetDtName(value); }
        }
        public Builder SetDtName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasDtName = true;
          result.dtName_ = value;
          return this;
        }
        public Builder ClearDtName() {
          PrepareBuilder();
          result.hasDtName = false;
          result.dtName_ = "";
          return this;
        }
        
        public bool HasNumElements {
          get { return result.hasNumElements; }
        }
        public int NumElements {
          get { return result.NumElements; }
          set { SetNumElements(value); }
        }
        public Builder SetNumElements(int value) {
          PrepareBuilder();
          result.hasNumElements = true;
          result.numElements_ = value;
          return this;
        }
        public Builder ClearNumElements() {
          PrepareBuilder();
          result.hasNumElements = false;
          result.numElements_ = 0;
          return this;
        }
        
        public bool HasLowValue {
          get { return result.hasLowValue; }
        }
        public float LowValue {
          get { return result.LowValue; }
          set { SetLowValue(value); }
        }
        public Builder SetLowValue(float value) {
          PrepareBuilder();
          result.hasLowValue = true;
          result.lowValue_ = value;
          return this;
        }
        public Builder ClearLowValue() {
          PrepareBuilder();
          result.hasLowValue = false;
          result.lowValue_ = 0F;
          return this;
        }
        
        public bool HasHighValue {
          get { return result.hasHighValue; }
        }
        public float HighValue {
          get { return result.HighValue; }
          set { SetHighValue(value); }
        }
        public Builder SetHighValue(float value) {
          PrepareBuilder();
          result.hasHighValue = true;
          result.highValue_ = value;
          return this;
        }
        public Builder ClearHighValue() {
          PrepareBuilder();
          result.hasHighValue = false;
          result.highValue_ = 0F;
          return this;
        }
        
        public bool HasNumBits {
          get { return result.hasNumBits; }
        }
        public int NumBits {
          get { return result.NumBits; }
          set { SetNumBits(value); }
        }
        public Builder SetNumBits(int value) {
          PrepareBuilder();
          result.hasNumBits = true;
          result.numBits_ = value;
          return this;
        }
        public Builder ClearNumBits() {
          PrepareBuilder();
          result.hasNumBits = false;
          result.numBits_ = 0;
          return this;
        }
      }
      static sendprop_t() {
        object.ReferenceEquals(global::Netmessages.Descriptor, null);
      }
    }
    
  }
  #endregion
  
  public const int IsEndFieldNumber = 1;
  private bool hasIsEnd;
  private bool isEnd_;
  public bool HasIsEnd {
    get { return hasIsEnd; }
  }
  public bool IsEnd {
    get { return isEnd_; }
  }
  
  public const int NetTableNameFieldNumber = 2;
  private bool hasNetTableName;
  private string netTableName_ = "";
  public bool HasNetTableName {
    get { return hasNetTableName; }
  }
  public string NetTableName {
    get { return netTableName_; }
  }
  
  public const int NeedsDecoderFieldNumber = 3;
  private bool hasNeedsDecoder;
  private bool needsDecoder_;
  public bool HasNeedsDecoder {
    get { return hasNeedsDecoder; }
  }
  public bool NeedsDecoder {
    get { return needsDecoder_; }
  }
  
  public const int PropsFieldNumber = 4;
  private pbc::PopsicleList<global::CSVCMsg_SendTable.Types.sendprop_t> props_ = new pbc::PopsicleList<global::CSVCMsg_SendTable.Types.sendprop_t>();
  public scg::IList<global::CSVCMsg_SendTable.Types.sendprop_t> PropsList {
    get { return props_; }
  }
  public int PropsCount {
    get { return props_.Count; }
  }
  public global::CSVCMsg_SendTable.Types.sendprop_t GetProps(int index) {
    return props_[index];
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgSendTableFieldNames;
    if (hasIsEnd) {
      output.WriteBool(1, field_names[0], IsEnd);
    }
    if (hasNetTableName) {
      output.WriteString(2, field_names[2], NetTableName);
    }
    if (hasNeedsDecoder) {
      output.WriteBool(3, field_names[1], NeedsDecoder);
    }
    if (props_.Count > 0) {
      output.WriteMessageArray(4, field_names[3], props_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasIsEnd) {
        size += pb::CodedOutputStream.ComputeBoolSize(1, IsEnd);
      }
      if (hasNetTableName) {
        size += pb::CodedOutputStream.ComputeStringSize(2, NetTableName);
      }
      if (hasNeedsDecoder) {
        size += pb::CodedOutputStream.ComputeBoolSize(3, NeedsDecoder);
      }
      foreach (global::CSVCMsg_SendTable.Types.sendprop_t element in PropsList) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_SendTable ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_SendTable ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SendTable ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_SendTable ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SendTable ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_SendTable ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SendTable ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_SendTable ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_SendTable ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_SendTable ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_SendTable MakeReadOnly() {
    props_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_SendTable prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_SendTable, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_SendTable cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_SendTable result;
    
    private CSVCMsg_SendTable PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_SendTable original = result;
        result = new CSVCMsg_SendTable();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_SendTable MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_SendTable.Descriptor; }
    }
    
    public override CSVCMsg_SendTable DefaultInstanceForType {
      get { return global::CSVCMsg_SendTable.DefaultInstance; }
    }
    
    public override CSVCMsg_SendTable BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_SendTable) {
        return MergeFrom((CSVCMsg_SendTable) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_SendTable other) {
      if (other == global::CSVCMsg_SendTable.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasIsEnd) {
        IsEnd = other.IsEnd;
      }
      if (other.HasNetTableName) {
        NetTableName = other.NetTableName;
      }
      if (other.HasNeedsDecoder) {
        NeedsDecoder = other.NeedsDecoder;
      }
      if (other.props_.Count != 0) {
        result.props_.Add(other.props_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgSendTableFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgSendTableFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasIsEnd = input.ReadBool(ref result.isEnd_);
            break;
          }
          case 18: {
            result.hasNetTableName = input.ReadString(ref result.netTableName_);
            break;
          }
          case 24: {
            result.hasNeedsDecoder = input.ReadBool(ref result.needsDecoder_);
            break;
          }
          case 34: {
            input.ReadMessageArray(tag, field_name, result.props_, global::CSVCMsg_SendTable.Types.sendprop_t.DefaultInstance, extensionRegistry);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasIsEnd {
      get { return result.hasIsEnd; }
    }
    public bool IsEnd {
      get { return result.IsEnd; }
      set { SetIsEnd(value); }
    }
    public Builder SetIsEnd(bool value) {
      PrepareBuilder();
      result.hasIsEnd = true;
      result.isEnd_ = value;
      return this;
    }
    public Builder ClearIsEnd() {
      PrepareBuilder();
      result.hasIsEnd = false;
      result.isEnd_ = false;
      return this;
    }
    
    public bool HasNetTableName {
      get { return result.hasNetTableName; }
    }
    public string NetTableName {
      get { return result.NetTableName; }
      set { SetNetTableName(value); }
    }
    public Builder SetNetTableName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasNetTableName = true;
      result.netTableName_ = value;
      return this;
    }
    public Builder ClearNetTableName() {
      PrepareBuilder();
      result.hasNetTableName = false;
      result.netTableName_ = "";
      return this;
    }
    
    public bool HasNeedsDecoder {
      get { return result.hasNeedsDecoder; }
    }
    public bool NeedsDecoder {
      get { return result.NeedsDecoder; }
      set { SetNeedsDecoder(value); }
    }
    public Builder SetNeedsDecoder(bool value) {
      PrepareBuilder();
      result.hasNeedsDecoder = true;
      result.needsDecoder_ = value;
      return this;
    }
    public Builder ClearNeedsDecoder() {
      PrepareBuilder();
      result.hasNeedsDecoder = false;
      result.needsDecoder_ = false;
      return this;
    }
    
    public pbc::IPopsicleList<global::CSVCMsg_SendTable.Types.sendprop_t> PropsList {
      get { return PrepareBuilder().props_; }
    }
    public int PropsCount {
      get { return result.PropsCount; }
    }
    public global::CSVCMsg_SendTable.Types.sendprop_t GetProps(int index) {
      return result.GetProps(index);
    }
    public Builder SetProps(int index, global::CSVCMsg_SendTable.Types.sendprop_t value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.props_[index] = value;
      return this;
    }
    public Builder SetProps(int index, global::CSVCMsg_SendTable.Types.sendprop_t.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.props_[index] = builderForValue.Build();
      return this;
    }
    public Builder AddProps(global::CSVCMsg_SendTable.Types.sendprop_t value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.props_.Add(value);
      return this;
    }
    public Builder AddProps(global::CSVCMsg_SendTable.Types.sendprop_t.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.props_.Add(builderForValue.Build());
      return this;
    }
    public Builder AddRangeProps(scg::IEnumerable<global::CSVCMsg_SendTable.Types.sendprop_t> values) {
      PrepareBuilder();
      result.props_.Add(values);
      return this;
    }
    public Builder ClearProps() {
      PrepareBuilder();
      result.props_.Clear();
      return this;
    }
  }
  static CSVCMsg_SendTable() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_Print : pb::GeneratedMessage<CSVCMsg_Print, CSVCMsg_Print.Builder> {
  private CSVCMsg_Print() { }
  private static readonly CSVCMsg_Print defaultInstance = new CSVCMsg_Print().MakeReadOnly();
  private static readonly string[] _cSVCMsgPrintFieldNames = new string[] { "text" };
  private static readonly uint[] _cSVCMsgPrintFieldTags = new uint[] { 10 };
  public static CSVCMsg_Print DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_Print DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_Print ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_Print__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_Print, CSVCMsg_Print.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_Print__FieldAccessorTable; }
  }
  
  public const int TextFieldNumber = 1;
  private bool hasText;
  private string text_ = "";
  public bool HasText {
    get { return hasText; }
  }
  public string Text {
    get { return text_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgPrintFieldNames;
    if (hasText) {
      output.WriteString(1, field_names[0], Text);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasText) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Text);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_Print ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_Print ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Print ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_Print ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Print ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_Print ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Print ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_Print ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_Print ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_Print ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_Print MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_Print prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_Print, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_Print cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_Print result;
    
    private CSVCMsg_Print PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_Print original = result;
        result = new CSVCMsg_Print();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_Print MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_Print.Descriptor; }
    }
    
    public override CSVCMsg_Print DefaultInstanceForType {
      get { return global::CSVCMsg_Print.DefaultInstance; }
    }
    
    public override CSVCMsg_Print BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_Print) {
        return MergeFrom((CSVCMsg_Print) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_Print other) {
      if (other == global::CSVCMsg_Print.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasText) {
        Text = other.Text;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgPrintFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgPrintFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasText = input.ReadString(ref result.text_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasText {
      get { return result.hasText; }
    }
    public string Text {
      get { return result.Text; }
      set { SetText(value); }
    }
    public Builder SetText(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasText = true;
      result.text_ = value;
      return this;
    }
    public Builder ClearText() {
      PrepareBuilder();
      result.hasText = false;
      result.text_ = "";
      return this;
    }
  }
  static CSVCMsg_Print() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_SetPause : pb::GeneratedMessage<CSVCMsg_SetPause, CSVCMsg_SetPause.Builder> {
  private CSVCMsg_SetPause() { }
  private static readonly CSVCMsg_SetPause defaultInstance = new CSVCMsg_SetPause().MakeReadOnly();
  private static readonly string[] _cSVCMsgSetPauseFieldNames = new string[] { "paused" };
  private static readonly uint[] _cSVCMsgSetPauseFieldTags = new uint[] { 8 };
  public static CSVCMsg_SetPause DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_SetPause DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_SetPause ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_SetPause__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_SetPause, CSVCMsg_SetPause.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_SetPause__FieldAccessorTable; }
  }
  
  public const int PausedFieldNumber = 1;
  private bool hasPaused;
  private bool paused_;
  public bool HasPaused {
    get { return hasPaused; }
  }
  public bool Paused {
    get { return paused_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgSetPauseFieldNames;
    if (hasPaused) {
      output.WriteBool(1, field_names[0], Paused);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasPaused) {
        size += pb::CodedOutputStream.ComputeBoolSize(1, Paused);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_SetPause ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_SetPause ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SetPause ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_SetPause ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SetPause ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_SetPause ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SetPause ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_SetPause ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_SetPause ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_SetPause ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_SetPause MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_SetPause prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_SetPause, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_SetPause cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_SetPause result;
    
    private CSVCMsg_SetPause PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_SetPause original = result;
        result = new CSVCMsg_SetPause();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_SetPause MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_SetPause.Descriptor; }
    }
    
    public override CSVCMsg_SetPause DefaultInstanceForType {
      get { return global::CSVCMsg_SetPause.DefaultInstance; }
    }
    
    public override CSVCMsg_SetPause BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_SetPause) {
        return MergeFrom((CSVCMsg_SetPause) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_SetPause other) {
      if (other == global::CSVCMsg_SetPause.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasPaused) {
        Paused = other.Paused;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgSetPauseFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgSetPauseFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasPaused = input.ReadBool(ref result.paused_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasPaused {
      get { return result.hasPaused; }
    }
    public bool Paused {
      get { return result.Paused; }
      set { SetPaused(value); }
    }
    public Builder SetPaused(bool value) {
      PrepareBuilder();
      result.hasPaused = true;
      result.paused_ = value;
      return this;
    }
    public Builder ClearPaused() {
      PrepareBuilder();
      result.hasPaused = false;
      result.paused_ = false;
      return this;
    }
  }
  static CSVCMsg_SetPause() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_SetView : pb::GeneratedMessage<CSVCMsg_SetView, CSVCMsg_SetView.Builder> {
  private CSVCMsg_SetView() { }
  private static readonly CSVCMsg_SetView defaultInstance = new CSVCMsg_SetView().MakeReadOnly();
  private static readonly string[] _cSVCMsgSetViewFieldNames = new string[] { "entity_index" };
  private static readonly uint[] _cSVCMsgSetViewFieldTags = new uint[] { 8 };
  public static CSVCMsg_SetView DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_SetView DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_SetView ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_SetView__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_SetView, CSVCMsg_SetView.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_SetView__FieldAccessorTable; }
  }
  
  public const int EntityIndexFieldNumber = 1;
  private bool hasEntityIndex;
  private int entityIndex_;
  public bool HasEntityIndex {
    get { return hasEntityIndex; }
  }
  public int EntityIndex {
    get { return entityIndex_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgSetViewFieldNames;
    if (hasEntityIndex) {
      output.WriteInt32(1, field_names[0], EntityIndex);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasEntityIndex) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, EntityIndex);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_SetView ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_SetView ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SetView ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_SetView ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SetView ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_SetView ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SetView ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_SetView ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_SetView ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_SetView ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_SetView MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_SetView prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_SetView, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_SetView cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_SetView result;
    
    private CSVCMsg_SetView PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_SetView original = result;
        result = new CSVCMsg_SetView();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_SetView MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_SetView.Descriptor; }
    }
    
    public override CSVCMsg_SetView DefaultInstanceForType {
      get { return global::CSVCMsg_SetView.DefaultInstance; }
    }
    
    public override CSVCMsg_SetView BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_SetView) {
        return MergeFrom((CSVCMsg_SetView) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_SetView other) {
      if (other == global::CSVCMsg_SetView.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasEntityIndex) {
        EntityIndex = other.EntityIndex;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgSetViewFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgSetViewFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasEntityIndex = input.ReadInt32(ref result.entityIndex_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasEntityIndex {
      get { return result.hasEntityIndex; }
    }
    public int EntityIndex {
      get { return result.EntityIndex; }
      set { SetEntityIndex(value); }
    }
    public Builder SetEntityIndex(int value) {
      PrepareBuilder();
      result.hasEntityIndex = true;
      result.entityIndex_ = value;
      return this;
    }
    public Builder ClearEntityIndex() {
      PrepareBuilder();
      result.hasEntityIndex = false;
      result.entityIndex_ = 0;
      return this;
    }
  }
  static CSVCMsg_SetView() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_CreateStringTable : pb::GeneratedMessage<CSVCMsg_CreateStringTable, CSVCMsg_CreateStringTable.Builder> {
  private CSVCMsg_CreateStringTable() { }
  private static readonly CSVCMsg_CreateStringTable defaultInstance = new CSVCMsg_CreateStringTable().MakeReadOnly();
  private static readonly string[] _cSVCMsgCreateStringTableFieldNames = new string[] { "flags", "max_entries", "name", "num_entries", "string_data", "user_data_fixed_size", "user_data_size", "user_data_size_bits" };
  private static readonly uint[] _cSVCMsgCreateStringTableFieldTags = new uint[] { 56, 16, 10, 24, 66, 32, 40, 48 };
  public static CSVCMsg_CreateStringTable DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_CreateStringTable DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_CreateStringTable ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_CreateStringTable__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_CreateStringTable, CSVCMsg_CreateStringTable.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_CreateStringTable__FieldAccessorTable; }
  }
  
  public const int NameFieldNumber = 1;
  private bool hasName;
  private string name_ = "";
  public bool HasName {
    get { return hasName; }
  }
  public string Name {
    get { return name_; }
  }
  
  public const int MaxEntriesFieldNumber = 2;
  private bool hasMaxEntries;
  private int maxEntries_;
  public bool HasMaxEntries {
    get { return hasMaxEntries; }
  }
  public int MaxEntries {
    get { return maxEntries_; }
  }
  
  public const int NumEntriesFieldNumber = 3;
  private bool hasNumEntries;
  private int numEntries_;
  public bool HasNumEntries {
    get { return hasNumEntries; }
  }
  public int NumEntries {
    get { return numEntries_; }
  }
  
  public const int UserDataFixedSizeFieldNumber = 4;
  private bool hasUserDataFixedSize;
  private bool userDataFixedSize_;
  public bool HasUserDataFixedSize {
    get { return hasUserDataFixedSize; }
  }
  public bool UserDataFixedSize {
    get { return userDataFixedSize_; }
  }
  
  public const int UserDataSizeFieldNumber = 5;
  private bool hasUserDataSize;
  private int userDataSize_;
  public bool HasUserDataSize {
    get { return hasUserDataSize; }
  }
  public int UserDataSize {
    get { return userDataSize_; }
  }
  
  public const int UserDataSizeBitsFieldNumber = 6;
  private bool hasUserDataSizeBits;
  private int userDataSizeBits_;
  public bool HasUserDataSizeBits {
    get { return hasUserDataSizeBits; }
  }
  public int UserDataSizeBits {
    get { return userDataSizeBits_; }
  }
  
  public const int FlagsFieldNumber = 7;
  private bool hasFlags;
  private int flags_;
  public bool HasFlags {
    get { return hasFlags; }
  }
  public int Flags {
    get { return flags_; }
  }
  
  public const int StringDataFieldNumber = 8;
  private bool hasStringData;
  private pb::ByteString stringData_ = pb::ByteString.Empty;
  public bool HasStringData {
    get { return hasStringData; }
  }
  public pb::ByteString StringData {
    get { return stringData_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgCreateStringTableFieldNames;
    if (hasName) {
      output.WriteString(1, field_names[2], Name);
    }
    if (hasMaxEntries) {
      output.WriteInt32(2, field_names[1], MaxEntries);
    }
    if (hasNumEntries) {
      output.WriteInt32(3, field_names[3], NumEntries);
    }
    if (hasUserDataFixedSize) {
      output.WriteBool(4, field_names[5], UserDataFixedSize);
    }
    if (hasUserDataSize) {
      output.WriteInt32(5, field_names[6], UserDataSize);
    }
    if (hasUserDataSizeBits) {
      output.WriteInt32(6, field_names[7], UserDataSizeBits);
    }
    if (hasFlags) {
      output.WriteInt32(7, field_names[0], Flags);
    }
    if (hasStringData) {
      output.WriteBytes(8, field_names[4], StringData);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasName) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Name);
      }
      if (hasMaxEntries) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, MaxEntries);
      }
      if (hasNumEntries) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, NumEntries);
      }
      if (hasUserDataFixedSize) {
        size += pb::CodedOutputStream.ComputeBoolSize(4, UserDataFixedSize);
      }
      if (hasUserDataSize) {
        size += pb::CodedOutputStream.ComputeInt32Size(5, UserDataSize);
      }
      if (hasUserDataSizeBits) {
        size += pb::CodedOutputStream.ComputeInt32Size(6, UserDataSizeBits);
      }
      if (hasFlags) {
        size += pb::CodedOutputStream.ComputeInt32Size(7, Flags);
      }
      if (hasStringData) {
        size += pb::CodedOutputStream.ComputeBytesSize(8, StringData);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_CreateStringTable ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_CreateStringTable ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_CreateStringTable ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_CreateStringTable ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_CreateStringTable ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_CreateStringTable ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_CreateStringTable ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_CreateStringTable ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_CreateStringTable ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_CreateStringTable ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_CreateStringTable MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_CreateStringTable prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_CreateStringTable, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_CreateStringTable cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_CreateStringTable result;
    
    private CSVCMsg_CreateStringTable PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_CreateStringTable original = result;
        result = new CSVCMsg_CreateStringTable();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_CreateStringTable MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_CreateStringTable.Descriptor; }
    }
    
    public override CSVCMsg_CreateStringTable DefaultInstanceForType {
      get { return global::CSVCMsg_CreateStringTable.DefaultInstance; }
    }
    
    public override CSVCMsg_CreateStringTable BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_CreateStringTable) {
        return MergeFrom((CSVCMsg_CreateStringTable) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_CreateStringTable other) {
      if (other == global::CSVCMsg_CreateStringTable.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasName) {
        Name = other.Name;
      }
      if (other.HasMaxEntries) {
        MaxEntries = other.MaxEntries;
      }
      if (other.HasNumEntries) {
        NumEntries = other.NumEntries;
      }
      if (other.HasUserDataFixedSize) {
        UserDataFixedSize = other.UserDataFixedSize;
      }
      if (other.HasUserDataSize) {
        UserDataSize = other.UserDataSize;
      }
      if (other.HasUserDataSizeBits) {
        UserDataSizeBits = other.UserDataSizeBits;
      }
      if (other.HasFlags) {
        Flags = other.Flags;
      }
      if (other.HasStringData) {
        StringData = other.StringData;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgCreateStringTableFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgCreateStringTableFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasName = input.ReadString(ref result.name_);
            break;
          }
          case 16: {
            result.hasMaxEntries = input.ReadInt32(ref result.maxEntries_);
            break;
          }
          case 24: {
            result.hasNumEntries = input.ReadInt32(ref result.numEntries_);
            break;
          }
          case 32: {
            result.hasUserDataFixedSize = input.ReadBool(ref result.userDataFixedSize_);
            break;
          }
          case 40: {
            result.hasUserDataSize = input.ReadInt32(ref result.userDataSize_);
            break;
          }
          case 48: {
            result.hasUserDataSizeBits = input.ReadInt32(ref result.userDataSizeBits_);
            break;
          }
          case 56: {
            result.hasFlags = input.ReadInt32(ref result.flags_);
            break;
          }
          case 66: {
            result.hasStringData = input.ReadBytes(ref result.stringData_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasName {
      get { return result.hasName; }
    }
    public string Name {
      get { return result.Name; }
      set { SetName(value); }
    }
    public Builder SetName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasName = true;
      result.name_ = value;
      return this;
    }
    public Builder ClearName() {
      PrepareBuilder();
      result.hasName = false;
      result.name_ = "";
      return this;
    }
    
    public bool HasMaxEntries {
      get { return result.hasMaxEntries; }
    }
    public int MaxEntries {
      get { return result.MaxEntries; }
      set { SetMaxEntries(value); }
    }
    public Builder SetMaxEntries(int value) {
      PrepareBuilder();
      result.hasMaxEntries = true;
      result.maxEntries_ = value;
      return this;
    }
    public Builder ClearMaxEntries() {
      PrepareBuilder();
      result.hasMaxEntries = false;
      result.maxEntries_ = 0;
      return this;
    }
    
    public bool HasNumEntries {
      get { return result.hasNumEntries; }
    }
    public int NumEntries {
      get { return result.NumEntries; }
      set { SetNumEntries(value); }
    }
    public Builder SetNumEntries(int value) {
      PrepareBuilder();
      result.hasNumEntries = true;
      result.numEntries_ = value;
      return this;
    }
    public Builder ClearNumEntries() {
      PrepareBuilder();
      result.hasNumEntries = false;
      result.numEntries_ = 0;
      return this;
    }
    
    public bool HasUserDataFixedSize {
      get { return result.hasUserDataFixedSize; }
    }
    public bool UserDataFixedSize {
      get { return result.UserDataFixedSize; }
      set { SetUserDataFixedSize(value); }
    }
    public Builder SetUserDataFixedSize(bool value) {
      PrepareBuilder();
      result.hasUserDataFixedSize = true;
      result.userDataFixedSize_ = value;
      return this;
    }
    public Builder ClearUserDataFixedSize() {
      PrepareBuilder();
      result.hasUserDataFixedSize = false;
      result.userDataFixedSize_ = false;
      return this;
    }
    
    public bool HasUserDataSize {
      get { return result.hasUserDataSize; }
    }
    public int UserDataSize {
      get { return result.UserDataSize; }
      set { SetUserDataSize(value); }
    }
    public Builder SetUserDataSize(int value) {
      PrepareBuilder();
      result.hasUserDataSize = true;
      result.userDataSize_ = value;
      return this;
    }
    public Builder ClearUserDataSize() {
      PrepareBuilder();
      result.hasUserDataSize = false;
      result.userDataSize_ = 0;
      return this;
    }
    
    public bool HasUserDataSizeBits {
      get { return result.hasUserDataSizeBits; }
    }
    public int UserDataSizeBits {
      get { return result.UserDataSizeBits; }
      set { SetUserDataSizeBits(value); }
    }
    public Builder SetUserDataSizeBits(int value) {
      PrepareBuilder();
      result.hasUserDataSizeBits = true;
      result.userDataSizeBits_ = value;
      return this;
    }
    public Builder ClearUserDataSizeBits() {
      PrepareBuilder();
      result.hasUserDataSizeBits = false;
      result.userDataSizeBits_ = 0;
      return this;
    }
    
    public bool HasFlags {
      get { return result.hasFlags; }
    }
    public int Flags {
      get { return result.Flags; }
      set { SetFlags(value); }
    }
    public Builder SetFlags(int value) {
      PrepareBuilder();
      result.hasFlags = true;
      result.flags_ = value;
      return this;
    }
    public Builder ClearFlags() {
      PrepareBuilder();
      result.hasFlags = false;
      result.flags_ = 0;
      return this;
    }
    
    public bool HasStringData {
      get { return result.hasStringData; }
    }
    public pb::ByteString StringData {
      get { return result.StringData; }
      set { SetStringData(value); }
    }
    public Builder SetStringData(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasStringData = true;
      result.stringData_ = value;
      return this;
    }
    public Builder ClearStringData() {
      PrepareBuilder();
      result.hasStringData = false;
      result.stringData_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CSVCMsg_CreateStringTable() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_UpdateStringTable : pb::GeneratedMessage<CSVCMsg_UpdateStringTable, CSVCMsg_UpdateStringTable.Builder> {
  private CSVCMsg_UpdateStringTable() { }
  private static readonly CSVCMsg_UpdateStringTable defaultInstance = new CSVCMsg_UpdateStringTable().MakeReadOnly();
  private static readonly string[] _cSVCMsgUpdateStringTableFieldNames = new string[] { "num_changed_entries", "string_data", "table_id" };
  private static readonly uint[] _cSVCMsgUpdateStringTableFieldTags = new uint[] { 16, 26, 8 };
  public static CSVCMsg_UpdateStringTable DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_UpdateStringTable DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_UpdateStringTable ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_UpdateStringTable__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_UpdateStringTable, CSVCMsg_UpdateStringTable.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_UpdateStringTable__FieldAccessorTable; }
  }
  
  public const int TableIdFieldNumber = 1;
  private bool hasTableId;
  private int tableId_;
  public bool HasTableId {
    get { return hasTableId; }
  }
  public int TableId {
    get { return tableId_; }
  }
  
  public const int NumChangedEntriesFieldNumber = 2;
  private bool hasNumChangedEntries;
  private int numChangedEntries_;
  public bool HasNumChangedEntries {
    get { return hasNumChangedEntries; }
  }
  public int NumChangedEntries {
    get { return numChangedEntries_; }
  }
  
  public const int StringDataFieldNumber = 3;
  private bool hasStringData;
  private pb::ByteString stringData_ = pb::ByteString.Empty;
  public bool HasStringData {
    get { return hasStringData; }
  }
  public pb::ByteString StringData {
    get { return stringData_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgUpdateStringTableFieldNames;
    if (hasTableId) {
      output.WriteInt32(1, field_names[2], TableId);
    }
    if (hasNumChangedEntries) {
      output.WriteInt32(2, field_names[0], NumChangedEntries);
    }
    if (hasStringData) {
      output.WriteBytes(3, field_names[1], StringData);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasTableId) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, TableId);
      }
      if (hasNumChangedEntries) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, NumChangedEntries);
      }
      if (hasStringData) {
        size += pb::CodedOutputStream.ComputeBytesSize(3, StringData);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_UpdateStringTable ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_UpdateStringTable ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_UpdateStringTable ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_UpdateStringTable ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_UpdateStringTable ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_UpdateStringTable ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_UpdateStringTable ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_UpdateStringTable ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_UpdateStringTable ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_UpdateStringTable ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_UpdateStringTable MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_UpdateStringTable prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_UpdateStringTable, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_UpdateStringTable cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_UpdateStringTable result;
    
    private CSVCMsg_UpdateStringTable PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_UpdateStringTable original = result;
        result = new CSVCMsg_UpdateStringTable();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_UpdateStringTable MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_UpdateStringTable.Descriptor; }
    }
    
    public override CSVCMsg_UpdateStringTable DefaultInstanceForType {
      get { return global::CSVCMsg_UpdateStringTable.DefaultInstance; }
    }
    
    public override CSVCMsg_UpdateStringTable BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_UpdateStringTable) {
        return MergeFrom((CSVCMsg_UpdateStringTable) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_UpdateStringTable other) {
      if (other == global::CSVCMsg_UpdateStringTable.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasTableId) {
        TableId = other.TableId;
      }
      if (other.HasNumChangedEntries) {
        NumChangedEntries = other.NumChangedEntries;
      }
      if (other.HasStringData) {
        StringData = other.StringData;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgUpdateStringTableFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgUpdateStringTableFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasTableId = input.ReadInt32(ref result.tableId_);
            break;
          }
          case 16: {
            result.hasNumChangedEntries = input.ReadInt32(ref result.numChangedEntries_);
            break;
          }
          case 26: {
            result.hasStringData = input.ReadBytes(ref result.stringData_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasTableId {
      get { return result.hasTableId; }
    }
    public int TableId {
      get { return result.TableId; }
      set { SetTableId(value); }
    }
    public Builder SetTableId(int value) {
      PrepareBuilder();
      result.hasTableId = true;
      result.tableId_ = value;
      return this;
    }
    public Builder ClearTableId() {
      PrepareBuilder();
      result.hasTableId = false;
      result.tableId_ = 0;
      return this;
    }
    
    public bool HasNumChangedEntries {
      get { return result.hasNumChangedEntries; }
    }
    public int NumChangedEntries {
      get { return result.NumChangedEntries; }
      set { SetNumChangedEntries(value); }
    }
    public Builder SetNumChangedEntries(int value) {
      PrepareBuilder();
      result.hasNumChangedEntries = true;
      result.numChangedEntries_ = value;
      return this;
    }
    public Builder ClearNumChangedEntries() {
      PrepareBuilder();
      result.hasNumChangedEntries = false;
      result.numChangedEntries_ = 0;
      return this;
    }
    
    public bool HasStringData {
      get { return result.hasStringData; }
    }
    public pb::ByteString StringData {
      get { return result.StringData; }
      set { SetStringData(value); }
    }
    public Builder SetStringData(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasStringData = true;
      result.stringData_ = value;
      return this;
    }
    public Builder ClearStringData() {
      PrepareBuilder();
      result.hasStringData = false;
      result.stringData_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CSVCMsg_UpdateStringTable() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_VoiceInit : pb::GeneratedMessage<CSVCMsg_VoiceInit, CSVCMsg_VoiceInit.Builder> {
  private CSVCMsg_VoiceInit() { }
  private static readonly CSVCMsg_VoiceInit defaultInstance = new CSVCMsg_VoiceInit().MakeReadOnly();
  private static readonly string[] _cSVCMsgVoiceInitFieldNames = new string[] { "codec", "quality" };
  private static readonly uint[] _cSVCMsgVoiceInitFieldTags = new uint[] { 18, 8 };
  public static CSVCMsg_VoiceInit DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_VoiceInit DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_VoiceInit ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_VoiceInit__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_VoiceInit, CSVCMsg_VoiceInit.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_VoiceInit__FieldAccessorTable; }
  }
  
  public const int QualityFieldNumber = 1;
  private bool hasQuality;
  private int quality_;
  public bool HasQuality {
    get { return hasQuality; }
  }
  public int Quality {
    get { return quality_; }
  }
  
  public const int CodecFieldNumber = 2;
  private bool hasCodec;
  private string codec_ = "";
  public bool HasCodec {
    get { return hasCodec; }
  }
  public string Codec {
    get { return codec_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgVoiceInitFieldNames;
    if (hasQuality) {
      output.WriteInt32(1, field_names[1], Quality);
    }
    if (hasCodec) {
      output.WriteString(2, field_names[0], Codec);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasQuality) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, Quality);
      }
      if (hasCodec) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Codec);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_VoiceInit ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_VoiceInit ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_VoiceInit ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_VoiceInit ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_VoiceInit ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_VoiceInit ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_VoiceInit ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_VoiceInit ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_VoiceInit ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_VoiceInit ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_VoiceInit MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_VoiceInit prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_VoiceInit, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_VoiceInit cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_VoiceInit result;
    
    private CSVCMsg_VoiceInit PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_VoiceInit original = result;
        result = new CSVCMsg_VoiceInit();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_VoiceInit MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_VoiceInit.Descriptor; }
    }
    
    public override CSVCMsg_VoiceInit DefaultInstanceForType {
      get { return global::CSVCMsg_VoiceInit.DefaultInstance; }
    }
    
    public override CSVCMsg_VoiceInit BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_VoiceInit) {
        return MergeFrom((CSVCMsg_VoiceInit) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_VoiceInit other) {
      if (other == global::CSVCMsg_VoiceInit.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasQuality) {
        Quality = other.Quality;
      }
      if (other.HasCodec) {
        Codec = other.Codec;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgVoiceInitFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgVoiceInitFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasQuality = input.ReadInt32(ref result.quality_);
            break;
          }
          case 18: {
            result.hasCodec = input.ReadString(ref result.codec_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasQuality {
      get { return result.hasQuality; }
    }
    public int Quality {
      get { return result.Quality; }
      set { SetQuality(value); }
    }
    public Builder SetQuality(int value) {
      PrepareBuilder();
      result.hasQuality = true;
      result.quality_ = value;
      return this;
    }
    public Builder ClearQuality() {
      PrepareBuilder();
      result.hasQuality = false;
      result.quality_ = 0;
      return this;
    }
    
    public bool HasCodec {
      get { return result.hasCodec; }
    }
    public string Codec {
      get { return result.Codec; }
      set { SetCodec(value); }
    }
    public Builder SetCodec(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasCodec = true;
      result.codec_ = value;
      return this;
    }
    public Builder ClearCodec() {
      PrepareBuilder();
      result.hasCodec = false;
      result.codec_ = "";
      return this;
    }
  }
  static CSVCMsg_VoiceInit() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_VoiceData : pb::GeneratedMessage<CSVCMsg_VoiceData, CSVCMsg_VoiceData.Builder> {
  private CSVCMsg_VoiceData() { }
  private static readonly CSVCMsg_VoiceData defaultInstance = new CSVCMsg_VoiceData().MakeReadOnly();
  private static readonly string[] _cSVCMsgVoiceDataFieldNames = new string[] { "audible_mask", "caster", "client", "proximity", "voice_data", "xuid" };
  private static readonly uint[] _cSVCMsgVoiceDataFieldTags = new uint[] { 32, 48, 8, 16, 42, 25 };
  public static CSVCMsg_VoiceData DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_VoiceData DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_VoiceData ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_VoiceData__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_VoiceData, CSVCMsg_VoiceData.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_VoiceData__FieldAccessorTable; }
  }
  
  public const int ClientFieldNumber = 1;
  private bool hasClient;
  private int client_;
  public bool HasClient {
    get { return hasClient; }
  }
  public int Client {
    get { return client_; }
  }
  
  public const int ProximityFieldNumber = 2;
  private bool hasProximity;
  private bool proximity_;
  public bool HasProximity {
    get { return hasProximity; }
  }
  public bool Proximity {
    get { return proximity_; }
  }
  
  public const int XuidFieldNumber = 3;
  private bool hasXuid;
  private ulong xuid_;
  public bool HasXuid {
    get { return hasXuid; }
  }
  [global::System.CLSCompliant(false)]
  public ulong Xuid {
    get { return xuid_; }
  }
  
  public const int AudibleMaskFieldNumber = 4;
  private bool hasAudibleMask;
  private int audibleMask_;
  public bool HasAudibleMask {
    get { return hasAudibleMask; }
  }
  public int AudibleMask {
    get { return audibleMask_; }
  }
  
  public const int VoiceDataFieldNumber = 5;
  private bool hasVoiceData;
  private pb::ByteString voiceData_ = pb::ByteString.Empty;
  public bool HasVoiceData {
    get { return hasVoiceData; }
  }
  public pb::ByteString VoiceData {
    get { return voiceData_; }
  }
  
  public const int CasterFieldNumber = 6;
  private bool hasCaster;
  private bool caster_;
  public bool HasCaster {
    get { return hasCaster; }
  }
  public bool Caster {
    get { return caster_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgVoiceDataFieldNames;
    if (hasClient) {
      output.WriteInt32(1, field_names[2], Client);
    }
    if (hasProximity) {
      output.WriteBool(2, field_names[3], Proximity);
    }
    if (hasXuid) {
      output.WriteFixed64(3, field_names[5], Xuid);
    }
    if (hasAudibleMask) {
      output.WriteInt32(4, field_names[0], AudibleMask);
    }
    if (hasVoiceData) {
      output.WriteBytes(5, field_names[4], VoiceData);
    }
    if (hasCaster) {
      output.WriteBool(6, field_names[1], Caster);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasClient) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, Client);
      }
      if (hasProximity) {
        size += pb::CodedOutputStream.ComputeBoolSize(2, Proximity);
      }
      if (hasXuid) {
        size += pb::CodedOutputStream.ComputeFixed64Size(3, Xuid);
      }
      if (hasAudibleMask) {
        size += pb::CodedOutputStream.ComputeInt32Size(4, AudibleMask);
      }
      if (hasVoiceData) {
        size += pb::CodedOutputStream.ComputeBytesSize(5, VoiceData);
      }
      if (hasCaster) {
        size += pb::CodedOutputStream.ComputeBoolSize(6, Caster);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_VoiceData ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_VoiceData ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_VoiceData ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_VoiceData ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_VoiceData ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_VoiceData ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_VoiceData ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_VoiceData ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_VoiceData ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_VoiceData ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_VoiceData MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_VoiceData prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_VoiceData, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_VoiceData cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_VoiceData result;
    
    private CSVCMsg_VoiceData PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_VoiceData original = result;
        result = new CSVCMsg_VoiceData();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_VoiceData MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_VoiceData.Descriptor; }
    }
    
    public override CSVCMsg_VoiceData DefaultInstanceForType {
      get { return global::CSVCMsg_VoiceData.DefaultInstance; }
    }
    
    public override CSVCMsg_VoiceData BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_VoiceData) {
        return MergeFrom((CSVCMsg_VoiceData) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_VoiceData other) {
      if (other == global::CSVCMsg_VoiceData.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasClient) {
        Client = other.Client;
      }
      if (other.HasProximity) {
        Proximity = other.Proximity;
      }
      if (other.HasXuid) {
        Xuid = other.Xuid;
      }
      if (other.HasAudibleMask) {
        AudibleMask = other.AudibleMask;
      }
      if (other.HasVoiceData) {
        VoiceData = other.VoiceData;
      }
      if (other.HasCaster) {
        Caster = other.Caster;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgVoiceDataFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgVoiceDataFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasClient = input.ReadInt32(ref result.client_);
            break;
          }
          case 16: {
            result.hasProximity = input.ReadBool(ref result.proximity_);
            break;
          }
          case 25: {
            result.hasXuid = input.ReadFixed64(ref result.xuid_);
            break;
          }
          case 32: {
            result.hasAudibleMask = input.ReadInt32(ref result.audibleMask_);
            break;
          }
          case 42: {
            result.hasVoiceData = input.ReadBytes(ref result.voiceData_);
            break;
          }
          case 48: {
            result.hasCaster = input.ReadBool(ref result.caster_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasClient {
      get { return result.hasClient; }
    }
    public int Client {
      get { return result.Client; }
      set { SetClient(value); }
    }
    public Builder SetClient(int value) {
      PrepareBuilder();
      result.hasClient = true;
      result.client_ = value;
      return this;
    }
    public Builder ClearClient() {
      PrepareBuilder();
      result.hasClient = false;
      result.client_ = 0;
      return this;
    }
    
    public bool HasProximity {
      get { return result.hasProximity; }
    }
    public bool Proximity {
      get { return result.Proximity; }
      set { SetProximity(value); }
    }
    public Builder SetProximity(bool value) {
      PrepareBuilder();
      result.hasProximity = true;
      result.proximity_ = value;
      return this;
    }
    public Builder ClearProximity() {
      PrepareBuilder();
      result.hasProximity = false;
      result.proximity_ = false;
      return this;
    }
    
    public bool HasXuid {
      get { return result.hasXuid; }
    }
    [global::System.CLSCompliant(false)]
    public ulong Xuid {
      get { return result.Xuid; }
      set { SetXuid(value); }
    }
    [global::System.CLSCompliant(false)]
    public Builder SetXuid(ulong value) {
      PrepareBuilder();
      result.hasXuid = true;
      result.xuid_ = value;
      return this;
    }
    public Builder ClearXuid() {
      PrepareBuilder();
      result.hasXuid = false;
      result.xuid_ = 0;
      return this;
    }
    
    public bool HasAudibleMask {
      get { return result.hasAudibleMask; }
    }
    public int AudibleMask {
      get { return result.AudibleMask; }
      set { SetAudibleMask(value); }
    }
    public Builder SetAudibleMask(int value) {
      PrepareBuilder();
      result.hasAudibleMask = true;
      result.audibleMask_ = value;
      return this;
    }
    public Builder ClearAudibleMask() {
      PrepareBuilder();
      result.hasAudibleMask = false;
      result.audibleMask_ = 0;
      return this;
    }
    
    public bool HasVoiceData {
      get { return result.hasVoiceData; }
    }
    public pb::ByteString VoiceData {
      get { return result.VoiceData; }
      set { SetVoiceData(value); }
    }
    public Builder SetVoiceData(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasVoiceData = true;
      result.voiceData_ = value;
      return this;
    }
    public Builder ClearVoiceData() {
      PrepareBuilder();
      result.hasVoiceData = false;
      result.voiceData_ = pb::ByteString.Empty;
      return this;
    }
    
    public bool HasCaster {
      get { return result.hasCaster; }
    }
    public bool Caster {
      get { return result.Caster; }
      set { SetCaster(value); }
    }
    public Builder SetCaster(bool value) {
      PrepareBuilder();
      result.hasCaster = true;
      result.caster_ = value;
      return this;
    }
    public Builder ClearCaster() {
      PrepareBuilder();
      result.hasCaster = false;
      result.caster_ = false;
      return this;
    }
  }
  static CSVCMsg_VoiceData() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_FixAngle : pb::GeneratedMessage<CSVCMsg_FixAngle, CSVCMsg_FixAngle.Builder> {
  private CSVCMsg_FixAngle() { }
  private static readonly CSVCMsg_FixAngle defaultInstance = new CSVCMsg_FixAngle().MakeReadOnly();
  private static readonly string[] _cSVCMsgFixAngleFieldNames = new string[] { "angle", "relative" };
  private static readonly uint[] _cSVCMsgFixAngleFieldTags = new uint[] { 18, 8 };
  public static CSVCMsg_FixAngle DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_FixAngle DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_FixAngle ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_FixAngle__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_FixAngle, CSVCMsg_FixAngle.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_FixAngle__FieldAccessorTable; }
  }
  
  public const int RelativeFieldNumber = 1;
  private bool hasRelative;
  private bool relative_;
  public bool HasRelative {
    get { return hasRelative; }
  }
  public bool Relative {
    get { return relative_; }
  }
  
  public const int AngleFieldNumber = 2;
  private bool hasAngle;
  private global::CMsgQAngle angle_;
  public bool HasAngle {
    get { return hasAngle; }
  }
  public global::CMsgQAngle Angle {
    get { return angle_ ?? global::CMsgQAngle.DefaultInstance; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgFixAngleFieldNames;
    if (hasRelative) {
      output.WriteBool(1, field_names[1], Relative);
    }
    if (hasAngle) {
      output.WriteMessage(2, field_names[0], Angle);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasRelative) {
        size += pb::CodedOutputStream.ComputeBoolSize(1, Relative);
      }
      if (hasAngle) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, Angle);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_FixAngle ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_FixAngle ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_FixAngle ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_FixAngle ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_FixAngle ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_FixAngle ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_FixAngle ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_FixAngle ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_FixAngle ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_FixAngle ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_FixAngle MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_FixAngle prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_FixAngle, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_FixAngle cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_FixAngle result;
    
    private CSVCMsg_FixAngle PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_FixAngle original = result;
        result = new CSVCMsg_FixAngle();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_FixAngle MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_FixAngle.Descriptor; }
    }
    
    public override CSVCMsg_FixAngle DefaultInstanceForType {
      get { return global::CSVCMsg_FixAngle.DefaultInstance; }
    }
    
    public override CSVCMsg_FixAngle BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_FixAngle) {
        return MergeFrom((CSVCMsg_FixAngle) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_FixAngle other) {
      if (other == global::CSVCMsg_FixAngle.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasRelative) {
        Relative = other.Relative;
      }
      if (other.HasAngle) {
        MergeAngle(other.Angle);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgFixAngleFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgFixAngleFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasRelative = input.ReadBool(ref result.relative_);
            break;
          }
          case 18: {
            global::CMsgQAngle.Builder subBuilder = global::CMsgQAngle.CreateBuilder();
            if (result.hasAngle) {
              subBuilder.MergeFrom(Angle);
            }
            input.ReadMessage(subBuilder, extensionRegistry);
            Angle = subBuilder.BuildPartial();
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasRelative {
      get { return result.hasRelative; }
    }
    public bool Relative {
      get { return result.Relative; }
      set { SetRelative(value); }
    }
    public Builder SetRelative(bool value) {
      PrepareBuilder();
      result.hasRelative = true;
      result.relative_ = value;
      return this;
    }
    public Builder ClearRelative() {
      PrepareBuilder();
      result.hasRelative = false;
      result.relative_ = false;
      return this;
    }
    
    public bool HasAngle {
     get { return result.hasAngle; }
    }
    public global::CMsgQAngle Angle {
      get { return result.Angle; }
      set { SetAngle(value); }
    }
    public Builder SetAngle(global::CMsgQAngle value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasAngle = true;
      result.angle_ = value;
      return this;
    }
    public Builder SetAngle(global::CMsgQAngle.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.hasAngle = true;
      result.angle_ = builderForValue.Build();
      return this;
    }
    public Builder MergeAngle(global::CMsgQAngle value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      if (result.hasAngle &&
          result.angle_ != global::CMsgQAngle.DefaultInstance) {
          result.angle_ = global::CMsgQAngle.CreateBuilder(result.angle_).MergeFrom(value).BuildPartial();
      } else {
        result.angle_ = value;
      }
      result.hasAngle = true;
      return this;
    }
    public Builder ClearAngle() {
      PrepareBuilder();
      result.hasAngle = false;
      result.angle_ = null;
      return this;
    }
  }
  static CSVCMsg_FixAngle() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_CrosshairAngle : pb::GeneratedMessage<CSVCMsg_CrosshairAngle, CSVCMsg_CrosshairAngle.Builder> {
  private CSVCMsg_CrosshairAngle() { }
  private static readonly CSVCMsg_CrosshairAngle defaultInstance = new CSVCMsg_CrosshairAngle().MakeReadOnly();
  private static readonly string[] _cSVCMsgCrosshairAngleFieldNames = new string[] { "angle" };
  private static readonly uint[] _cSVCMsgCrosshairAngleFieldTags = new uint[] { 10 };
  public static CSVCMsg_CrosshairAngle DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_CrosshairAngle DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_CrosshairAngle ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_CrosshairAngle__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_CrosshairAngle, CSVCMsg_CrosshairAngle.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_CrosshairAngle__FieldAccessorTable; }
  }
  
  public const int AngleFieldNumber = 1;
  private bool hasAngle;
  private global::CMsgQAngle angle_;
  public bool HasAngle {
    get { return hasAngle; }
  }
  public global::CMsgQAngle Angle {
    get { return angle_ ?? global::CMsgQAngle.DefaultInstance; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgCrosshairAngleFieldNames;
    if (hasAngle) {
      output.WriteMessage(1, field_names[0], Angle);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasAngle) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Angle);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_CrosshairAngle ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_CrosshairAngle ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_CrosshairAngle ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_CrosshairAngle ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_CrosshairAngle ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_CrosshairAngle ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_CrosshairAngle ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_CrosshairAngle ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_CrosshairAngle ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_CrosshairAngle ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_CrosshairAngle MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_CrosshairAngle prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_CrosshairAngle, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_CrosshairAngle cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_CrosshairAngle result;
    
    private CSVCMsg_CrosshairAngle PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_CrosshairAngle original = result;
        result = new CSVCMsg_CrosshairAngle();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_CrosshairAngle MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_CrosshairAngle.Descriptor; }
    }
    
    public override CSVCMsg_CrosshairAngle DefaultInstanceForType {
      get { return global::CSVCMsg_CrosshairAngle.DefaultInstance; }
    }
    
    public override CSVCMsg_CrosshairAngle BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_CrosshairAngle) {
        return MergeFrom((CSVCMsg_CrosshairAngle) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_CrosshairAngle other) {
      if (other == global::CSVCMsg_CrosshairAngle.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasAngle) {
        MergeAngle(other.Angle);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgCrosshairAngleFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgCrosshairAngleFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            global::CMsgQAngle.Builder subBuilder = global::CMsgQAngle.CreateBuilder();
            if (result.hasAngle) {
              subBuilder.MergeFrom(Angle);
            }
            input.ReadMessage(subBuilder, extensionRegistry);
            Angle = subBuilder.BuildPartial();
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasAngle {
     get { return result.hasAngle; }
    }
    public global::CMsgQAngle Angle {
      get { return result.Angle; }
      set { SetAngle(value); }
    }
    public Builder SetAngle(global::CMsgQAngle value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasAngle = true;
      result.angle_ = value;
      return this;
    }
    public Builder SetAngle(global::CMsgQAngle.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.hasAngle = true;
      result.angle_ = builderForValue.Build();
      return this;
    }
    public Builder MergeAngle(global::CMsgQAngle value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      if (result.hasAngle &&
          result.angle_ != global::CMsgQAngle.DefaultInstance) {
          result.angle_ = global::CMsgQAngle.CreateBuilder(result.angle_).MergeFrom(value).BuildPartial();
      } else {
        result.angle_ = value;
      }
      result.hasAngle = true;
      return this;
    }
    public Builder ClearAngle() {
      PrepareBuilder();
      result.hasAngle = false;
      result.angle_ = null;
      return this;
    }
  }
  static CSVCMsg_CrosshairAngle() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_Prefetch : pb::GeneratedMessage<CSVCMsg_Prefetch, CSVCMsg_Prefetch.Builder> {
  private CSVCMsg_Prefetch() { }
  private static readonly CSVCMsg_Prefetch defaultInstance = new CSVCMsg_Prefetch().MakeReadOnly();
  private static readonly string[] _cSVCMsgPrefetchFieldNames = new string[] { "sound_index" };
  private static readonly uint[] _cSVCMsgPrefetchFieldTags = new uint[] { 8 };
  public static CSVCMsg_Prefetch DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_Prefetch DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_Prefetch ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_Prefetch__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_Prefetch, CSVCMsg_Prefetch.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_Prefetch__FieldAccessorTable; }
  }
  
  public const int SoundIndexFieldNumber = 1;
  private bool hasSoundIndex;
  private int soundIndex_;
  public bool HasSoundIndex {
    get { return hasSoundIndex; }
  }
  public int SoundIndex {
    get { return soundIndex_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgPrefetchFieldNames;
    if (hasSoundIndex) {
      output.WriteInt32(1, field_names[0], SoundIndex);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSoundIndex) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, SoundIndex);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_Prefetch ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_Prefetch ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Prefetch ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_Prefetch ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Prefetch ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_Prefetch ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Prefetch ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_Prefetch ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_Prefetch ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_Prefetch ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_Prefetch MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_Prefetch prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_Prefetch, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_Prefetch cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_Prefetch result;
    
    private CSVCMsg_Prefetch PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_Prefetch original = result;
        result = new CSVCMsg_Prefetch();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_Prefetch MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_Prefetch.Descriptor; }
    }
    
    public override CSVCMsg_Prefetch DefaultInstanceForType {
      get { return global::CSVCMsg_Prefetch.DefaultInstance; }
    }
    
    public override CSVCMsg_Prefetch BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_Prefetch) {
        return MergeFrom((CSVCMsg_Prefetch) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_Prefetch other) {
      if (other == global::CSVCMsg_Prefetch.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasSoundIndex) {
        SoundIndex = other.SoundIndex;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgPrefetchFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgPrefetchFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasSoundIndex = input.ReadInt32(ref result.soundIndex_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasSoundIndex {
      get { return result.hasSoundIndex; }
    }
    public int SoundIndex {
      get { return result.SoundIndex; }
      set { SetSoundIndex(value); }
    }
    public Builder SetSoundIndex(int value) {
      PrepareBuilder();
      result.hasSoundIndex = true;
      result.soundIndex_ = value;
      return this;
    }
    public Builder ClearSoundIndex() {
      PrepareBuilder();
      result.hasSoundIndex = false;
      result.soundIndex_ = 0;
      return this;
    }
  }
  static CSVCMsg_Prefetch() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_BSPDecal : pb::GeneratedMessage<CSVCMsg_BSPDecal, CSVCMsg_BSPDecal.Builder> {
  private CSVCMsg_BSPDecal() { }
  private static readonly CSVCMsg_BSPDecal defaultInstance = new CSVCMsg_BSPDecal().MakeReadOnly();
  private static readonly string[] _cSVCMsgBSPDecalFieldNames = new string[] { "decal_texture_index", "entity_index", "low_priority", "model_index", "pos" };
  private static readonly uint[] _cSVCMsgBSPDecalFieldTags = new uint[] { 16, 24, 40, 32, 10 };
  public static CSVCMsg_BSPDecal DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_BSPDecal DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_BSPDecal ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_BSPDecal__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_BSPDecal, CSVCMsg_BSPDecal.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_BSPDecal__FieldAccessorTable; }
  }
  
  public const int PosFieldNumber = 1;
  private bool hasPos;
  private global::CMsgVector pos_;
  public bool HasPos {
    get { return hasPos; }
  }
  public global::CMsgVector Pos {
    get { return pos_ ?? global::CMsgVector.DefaultInstance; }
  }
  
  public const int DecalTextureIndexFieldNumber = 2;
  private bool hasDecalTextureIndex;
  private int decalTextureIndex_;
  public bool HasDecalTextureIndex {
    get { return hasDecalTextureIndex; }
  }
  public int DecalTextureIndex {
    get { return decalTextureIndex_; }
  }
  
  public const int EntityIndexFieldNumber = 3;
  private bool hasEntityIndex;
  private int entityIndex_;
  public bool HasEntityIndex {
    get { return hasEntityIndex; }
  }
  public int EntityIndex {
    get { return entityIndex_; }
  }
  
  public const int ModelIndexFieldNumber = 4;
  private bool hasModelIndex;
  private int modelIndex_;
  public bool HasModelIndex {
    get { return hasModelIndex; }
  }
  public int ModelIndex {
    get { return modelIndex_; }
  }
  
  public const int LowPriorityFieldNumber = 5;
  private bool hasLowPriority;
  private bool lowPriority_;
  public bool HasLowPriority {
    get { return hasLowPriority; }
  }
  public bool LowPriority {
    get { return lowPriority_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgBSPDecalFieldNames;
    if (hasPos) {
      output.WriteMessage(1, field_names[4], Pos);
    }
    if (hasDecalTextureIndex) {
      output.WriteInt32(2, field_names[0], DecalTextureIndex);
    }
    if (hasEntityIndex) {
      output.WriteInt32(3, field_names[1], EntityIndex);
    }
    if (hasModelIndex) {
      output.WriteInt32(4, field_names[3], ModelIndex);
    }
    if (hasLowPriority) {
      output.WriteBool(5, field_names[2], LowPriority);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasPos) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, Pos);
      }
      if (hasDecalTextureIndex) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, DecalTextureIndex);
      }
      if (hasEntityIndex) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, EntityIndex);
      }
      if (hasModelIndex) {
        size += pb::CodedOutputStream.ComputeInt32Size(4, ModelIndex);
      }
      if (hasLowPriority) {
        size += pb::CodedOutputStream.ComputeBoolSize(5, LowPriority);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_BSPDecal ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_BSPDecal ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_BSPDecal ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_BSPDecal ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_BSPDecal ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_BSPDecal ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_BSPDecal ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_BSPDecal ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_BSPDecal ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_BSPDecal ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_BSPDecal MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_BSPDecal prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_BSPDecal, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_BSPDecal cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_BSPDecal result;
    
    private CSVCMsg_BSPDecal PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_BSPDecal original = result;
        result = new CSVCMsg_BSPDecal();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_BSPDecal MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_BSPDecal.Descriptor; }
    }
    
    public override CSVCMsg_BSPDecal DefaultInstanceForType {
      get { return global::CSVCMsg_BSPDecal.DefaultInstance; }
    }
    
    public override CSVCMsg_BSPDecal BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_BSPDecal) {
        return MergeFrom((CSVCMsg_BSPDecal) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_BSPDecal other) {
      if (other == global::CSVCMsg_BSPDecal.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasPos) {
        MergePos(other.Pos);
      }
      if (other.HasDecalTextureIndex) {
        DecalTextureIndex = other.DecalTextureIndex;
      }
      if (other.HasEntityIndex) {
        EntityIndex = other.EntityIndex;
      }
      if (other.HasModelIndex) {
        ModelIndex = other.ModelIndex;
      }
      if (other.HasLowPriority) {
        LowPriority = other.LowPriority;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgBSPDecalFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgBSPDecalFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            global::CMsgVector.Builder subBuilder = global::CMsgVector.CreateBuilder();
            if (result.hasPos) {
              subBuilder.MergeFrom(Pos);
            }
            input.ReadMessage(subBuilder, extensionRegistry);
            Pos = subBuilder.BuildPartial();
            break;
          }
          case 16: {
            result.hasDecalTextureIndex = input.ReadInt32(ref result.decalTextureIndex_);
            break;
          }
          case 24: {
            result.hasEntityIndex = input.ReadInt32(ref result.entityIndex_);
            break;
          }
          case 32: {
            result.hasModelIndex = input.ReadInt32(ref result.modelIndex_);
            break;
          }
          case 40: {
            result.hasLowPriority = input.ReadBool(ref result.lowPriority_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasPos {
     get { return result.hasPos; }
    }
    public global::CMsgVector Pos {
      get { return result.Pos; }
      set { SetPos(value); }
    }
    public Builder SetPos(global::CMsgVector value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasPos = true;
      result.pos_ = value;
      return this;
    }
    public Builder SetPos(global::CMsgVector.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.hasPos = true;
      result.pos_ = builderForValue.Build();
      return this;
    }
    public Builder MergePos(global::CMsgVector value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      if (result.hasPos &&
          result.pos_ != global::CMsgVector.DefaultInstance) {
          result.pos_ = global::CMsgVector.CreateBuilder(result.pos_).MergeFrom(value).BuildPartial();
      } else {
        result.pos_ = value;
      }
      result.hasPos = true;
      return this;
    }
    public Builder ClearPos() {
      PrepareBuilder();
      result.hasPos = false;
      result.pos_ = null;
      return this;
    }
    
    public bool HasDecalTextureIndex {
      get { return result.hasDecalTextureIndex; }
    }
    public int DecalTextureIndex {
      get { return result.DecalTextureIndex; }
      set { SetDecalTextureIndex(value); }
    }
    public Builder SetDecalTextureIndex(int value) {
      PrepareBuilder();
      result.hasDecalTextureIndex = true;
      result.decalTextureIndex_ = value;
      return this;
    }
    public Builder ClearDecalTextureIndex() {
      PrepareBuilder();
      result.hasDecalTextureIndex = false;
      result.decalTextureIndex_ = 0;
      return this;
    }
    
    public bool HasEntityIndex {
      get { return result.hasEntityIndex; }
    }
    public int EntityIndex {
      get { return result.EntityIndex; }
      set { SetEntityIndex(value); }
    }
    public Builder SetEntityIndex(int value) {
      PrepareBuilder();
      result.hasEntityIndex = true;
      result.entityIndex_ = value;
      return this;
    }
    public Builder ClearEntityIndex() {
      PrepareBuilder();
      result.hasEntityIndex = false;
      result.entityIndex_ = 0;
      return this;
    }
    
    public bool HasModelIndex {
      get { return result.hasModelIndex; }
    }
    public int ModelIndex {
      get { return result.ModelIndex; }
      set { SetModelIndex(value); }
    }
    public Builder SetModelIndex(int value) {
      PrepareBuilder();
      result.hasModelIndex = true;
      result.modelIndex_ = value;
      return this;
    }
    public Builder ClearModelIndex() {
      PrepareBuilder();
      result.hasModelIndex = false;
      result.modelIndex_ = 0;
      return this;
    }
    
    public bool HasLowPriority {
      get { return result.hasLowPriority; }
    }
    public bool LowPriority {
      get { return result.LowPriority; }
      set { SetLowPriority(value); }
    }
    public Builder SetLowPriority(bool value) {
      PrepareBuilder();
      result.hasLowPriority = true;
      result.lowPriority_ = value;
      return this;
    }
    public Builder ClearLowPriority() {
      PrepareBuilder();
      result.hasLowPriority = false;
      result.lowPriority_ = false;
      return this;
    }
  }
  static CSVCMsg_BSPDecal() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_SplitScreen : pb::GeneratedMessage<CSVCMsg_SplitScreen, CSVCMsg_SplitScreen.Builder> {
  private CSVCMsg_SplitScreen() { }
  private static readonly CSVCMsg_SplitScreen defaultInstance = new CSVCMsg_SplitScreen().MakeReadOnly();
  private static readonly string[] _cSVCMsgSplitScreenFieldNames = new string[] { "player_index", "slot", "type" };
  private static readonly uint[] _cSVCMsgSplitScreenFieldTags = new uint[] { 24, 16, 8 };
  public static CSVCMsg_SplitScreen DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_SplitScreen DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_SplitScreen ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_SplitScreen__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_SplitScreen, CSVCMsg_SplitScreen.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_SplitScreen__FieldAccessorTable; }
  }
  
  public const int TypeFieldNumber = 1;
  private bool hasType;
  private global::ESplitScreenMessageType type_ = global::ESplitScreenMessageType.MSG_SPLITSCREEN_ADDUSER;
  public bool HasType {
    get { return hasType; }
  }
  public global::ESplitScreenMessageType Type {
    get { return type_; }
  }
  
  public const int SlotFieldNumber = 2;
  private bool hasSlot;
  private int slot_;
  public bool HasSlot {
    get { return hasSlot; }
  }
  public int Slot {
    get { return slot_; }
  }
  
  public const int PlayerIndexFieldNumber = 3;
  private bool hasPlayerIndex;
  private int playerIndex_;
  public bool HasPlayerIndex {
    get { return hasPlayerIndex; }
  }
  public int PlayerIndex {
    get { return playerIndex_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgSplitScreenFieldNames;
    if (hasType) {
      output.WriteEnum(1, field_names[2], (int) Type, Type);
    }
    if (hasSlot) {
      output.WriteInt32(2, field_names[1], Slot);
    }
    if (hasPlayerIndex) {
      output.WriteInt32(3, field_names[0], PlayerIndex);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasType) {
        size += pb::CodedOutputStream.ComputeEnumSize(1, (int) Type);
      }
      if (hasSlot) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, Slot);
      }
      if (hasPlayerIndex) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, PlayerIndex);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_SplitScreen ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_SplitScreen ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SplitScreen ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_SplitScreen ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SplitScreen ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_SplitScreen ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_SplitScreen ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_SplitScreen ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_SplitScreen ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_SplitScreen ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_SplitScreen MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_SplitScreen prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_SplitScreen, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_SplitScreen cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_SplitScreen result;
    
    private CSVCMsg_SplitScreen PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_SplitScreen original = result;
        result = new CSVCMsg_SplitScreen();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_SplitScreen MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_SplitScreen.Descriptor; }
    }
    
    public override CSVCMsg_SplitScreen DefaultInstanceForType {
      get { return global::CSVCMsg_SplitScreen.DefaultInstance; }
    }
    
    public override CSVCMsg_SplitScreen BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_SplitScreen) {
        return MergeFrom((CSVCMsg_SplitScreen) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_SplitScreen other) {
      if (other == global::CSVCMsg_SplitScreen.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasType) {
        Type = other.Type;
      }
      if (other.HasSlot) {
        Slot = other.Slot;
      }
      if (other.HasPlayerIndex) {
        PlayerIndex = other.PlayerIndex;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgSplitScreenFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgSplitScreenFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            object unknown;
            if(input.ReadEnum(ref result.type_, out unknown)) {
              result.hasType = true;
            } else if(unknown is int) {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              unknownFields.MergeVarintField(1, (ulong)(int)unknown);
            }
            break;
          }
          case 16: {
            result.hasSlot = input.ReadInt32(ref result.slot_);
            break;
          }
          case 24: {
            result.hasPlayerIndex = input.ReadInt32(ref result.playerIndex_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasType {
     get { return result.hasType; }
    }
    public global::ESplitScreenMessageType Type {
      get { return result.Type; }
      set { SetType(value); }
    }
    public Builder SetType(global::ESplitScreenMessageType value) {
      PrepareBuilder();
      result.hasType = true;
      result.type_ = value;
      return this;
    }
    public Builder ClearType() {
      PrepareBuilder();
      result.hasType = false;
      result.type_ = global::ESplitScreenMessageType.MSG_SPLITSCREEN_ADDUSER;
      return this;
    }
    
    public bool HasSlot {
      get { return result.hasSlot; }
    }
    public int Slot {
      get { return result.Slot; }
      set { SetSlot(value); }
    }
    public Builder SetSlot(int value) {
      PrepareBuilder();
      result.hasSlot = true;
      result.slot_ = value;
      return this;
    }
    public Builder ClearSlot() {
      PrepareBuilder();
      result.hasSlot = false;
      result.slot_ = 0;
      return this;
    }
    
    public bool HasPlayerIndex {
      get { return result.hasPlayerIndex; }
    }
    public int PlayerIndex {
      get { return result.PlayerIndex; }
      set { SetPlayerIndex(value); }
    }
    public Builder SetPlayerIndex(int value) {
      PrepareBuilder();
      result.hasPlayerIndex = true;
      result.playerIndex_ = value;
      return this;
    }
    public Builder ClearPlayerIndex() {
      PrepareBuilder();
      result.hasPlayerIndex = false;
      result.playerIndex_ = 0;
      return this;
    }
  }
  static CSVCMsg_SplitScreen() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_GetCvarValue : pb::GeneratedMessage<CSVCMsg_GetCvarValue, CSVCMsg_GetCvarValue.Builder> {
  private CSVCMsg_GetCvarValue() { }
  private static readonly CSVCMsg_GetCvarValue defaultInstance = new CSVCMsg_GetCvarValue().MakeReadOnly();
  private static readonly string[] _cSVCMsgGetCvarValueFieldNames = new string[] { "cookie", "cvar_name" };
  private static readonly uint[] _cSVCMsgGetCvarValueFieldTags = new uint[] { 8, 18 };
  public static CSVCMsg_GetCvarValue DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_GetCvarValue DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_GetCvarValue ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_GetCvarValue__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_GetCvarValue, CSVCMsg_GetCvarValue.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_GetCvarValue__FieldAccessorTable; }
  }
  
  public const int CookieFieldNumber = 1;
  private bool hasCookie;
  private int cookie_;
  public bool HasCookie {
    get { return hasCookie; }
  }
  public int Cookie {
    get { return cookie_; }
  }
  
  public const int CvarNameFieldNumber = 2;
  private bool hasCvarName;
  private string cvarName_ = "";
  public bool HasCvarName {
    get { return hasCvarName; }
  }
  public string CvarName {
    get { return cvarName_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgGetCvarValueFieldNames;
    if (hasCookie) {
      output.WriteInt32(1, field_names[0], Cookie);
    }
    if (hasCvarName) {
      output.WriteString(2, field_names[1], CvarName);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasCookie) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, Cookie);
      }
      if (hasCvarName) {
        size += pb::CodedOutputStream.ComputeStringSize(2, CvarName);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_GetCvarValue ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_GetCvarValue ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_GetCvarValue ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_GetCvarValue ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_GetCvarValue ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_GetCvarValue ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_GetCvarValue ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_GetCvarValue ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_GetCvarValue ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_GetCvarValue ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_GetCvarValue MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_GetCvarValue prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_GetCvarValue, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_GetCvarValue cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_GetCvarValue result;
    
    private CSVCMsg_GetCvarValue PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_GetCvarValue original = result;
        result = new CSVCMsg_GetCvarValue();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_GetCvarValue MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_GetCvarValue.Descriptor; }
    }
    
    public override CSVCMsg_GetCvarValue DefaultInstanceForType {
      get { return global::CSVCMsg_GetCvarValue.DefaultInstance; }
    }
    
    public override CSVCMsg_GetCvarValue BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_GetCvarValue) {
        return MergeFrom((CSVCMsg_GetCvarValue) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_GetCvarValue other) {
      if (other == global::CSVCMsg_GetCvarValue.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasCookie) {
        Cookie = other.Cookie;
      }
      if (other.HasCvarName) {
        CvarName = other.CvarName;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgGetCvarValueFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgGetCvarValueFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasCookie = input.ReadInt32(ref result.cookie_);
            break;
          }
          case 18: {
            result.hasCvarName = input.ReadString(ref result.cvarName_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasCookie {
      get { return result.hasCookie; }
    }
    public int Cookie {
      get { return result.Cookie; }
      set { SetCookie(value); }
    }
    public Builder SetCookie(int value) {
      PrepareBuilder();
      result.hasCookie = true;
      result.cookie_ = value;
      return this;
    }
    public Builder ClearCookie() {
      PrepareBuilder();
      result.hasCookie = false;
      result.cookie_ = 0;
      return this;
    }
    
    public bool HasCvarName {
      get { return result.hasCvarName; }
    }
    public string CvarName {
      get { return result.CvarName; }
      set { SetCvarName(value); }
    }
    public Builder SetCvarName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasCvarName = true;
      result.cvarName_ = value;
      return this;
    }
    public Builder ClearCvarName() {
      PrepareBuilder();
      result.hasCvarName = false;
      result.cvarName_ = "";
      return this;
    }
  }
  static CSVCMsg_GetCvarValue() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_Menu : pb::GeneratedMessage<CSVCMsg_Menu, CSVCMsg_Menu.Builder> {
  private CSVCMsg_Menu() { }
  private static readonly CSVCMsg_Menu defaultInstance = new CSVCMsg_Menu().MakeReadOnly();
  private static readonly string[] _cSVCMsgMenuFieldNames = new string[] { "dialog_type", "menu_key_values" };
  private static readonly uint[] _cSVCMsgMenuFieldTags = new uint[] { 8, 18 };
  public static CSVCMsg_Menu DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_Menu DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_Menu ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_Menu__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_Menu, CSVCMsg_Menu.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_Menu__FieldAccessorTable; }
  }
  
  public const int DialogTypeFieldNumber = 1;
  private bool hasDialogType;
  private int dialogType_;
  public bool HasDialogType {
    get { return hasDialogType; }
  }
  public int DialogType {
    get { return dialogType_; }
  }
  
  public const int MenuKeyValuesFieldNumber = 2;
  private bool hasMenuKeyValues;
  private pb::ByteString menuKeyValues_ = pb::ByteString.Empty;
  public bool HasMenuKeyValues {
    get { return hasMenuKeyValues; }
  }
  public pb::ByteString MenuKeyValues {
    get { return menuKeyValues_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgMenuFieldNames;
    if (hasDialogType) {
      output.WriteInt32(1, field_names[0], DialogType);
    }
    if (hasMenuKeyValues) {
      output.WriteBytes(2, field_names[1], MenuKeyValues);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasDialogType) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, DialogType);
      }
      if (hasMenuKeyValues) {
        size += pb::CodedOutputStream.ComputeBytesSize(2, MenuKeyValues);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_Menu ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_Menu ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Menu ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_Menu ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Menu ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_Menu ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Menu ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_Menu ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_Menu ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_Menu ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_Menu MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_Menu prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_Menu, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_Menu cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_Menu result;
    
    private CSVCMsg_Menu PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_Menu original = result;
        result = new CSVCMsg_Menu();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_Menu MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_Menu.Descriptor; }
    }
    
    public override CSVCMsg_Menu DefaultInstanceForType {
      get { return global::CSVCMsg_Menu.DefaultInstance; }
    }
    
    public override CSVCMsg_Menu BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_Menu) {
        return MergeFrom((CSVCMsg_Menu) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_Menu other) {
      if (other == global::CSVCMsg_Menu.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasDialogType) {
        DialogType = other.DialogType;
      }
      if (other.HasMenuKeyValues) {
        MenuKeyValues = other.MenuKeyValues;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgMenuFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgMenuFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasDialogType = input.ReadInt32(ref result.dialogType_);
            break;
          }
          case 18: {
            result.hasMenuKeyValues = input.ReadBytes(ref result.menuKeyValues_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasDialogType {
      get { return result.hasDialogType; }
    }
    public int DialogType {
      get { return result.DialogType; }
      set { SetDialogType(value); }
    }
    public Builder SetDialogType(int value) {
      PrepareBuilder();
      result.hasDialogType = true;
      result.dialogType_ = value;
      return this;
    }
    public Builder ClearDialogType() {
      PrepareBuilder();
      result.hasDialogType = false;
      result.dialogType_ = 0;
      return this;
    }
    
    public bool HasMenuKeyValues {
      get { return result.hasMenuKeyValues; }
    }
    public pb::ByteString MenuKeyValues {
      get { return result.MenuKeyValues; }
      set { SetMenuKeyValues(value); }
    }
    public Builder SetMenuKeyValues(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasMenuKeyValues = true;
      result.menuKeyValues_ = value;
      return this;
    }
    public Builder ClearMenuKeyValues() {
      PrepareBuilder();
      result.hasMenuKeyValues = false;
      result.menuKeyValues_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CSVCMsg_Menu() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_UserMessage : pb::GeneratedMessage<CSVCMsg_UserMessage, CSVCMsg_UserMessage.Builder> {
  private CSVCMsg_UserMessage() { }
  private static readonly CSVCMsg_UserMessage defaultInstance = new CSVCMsg_UserMessage().MakeReadOnly();
  private static readonly string[] _cSVCMsgUserMessageFieldNames = new string[] { "msg_data", "msg_type" };
  private static readonly uint[] _cSVCMsgUserMessageFieldTags = new uint[] { 18, 8 };
  public static CSVCMsg_UserMessage DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_UserMessage DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_UserMessage ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_UserMessage__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_UserMessage, CSVCMsg_UserMessage.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_UserMessage__FieldAccessorTable; }
  }
  
  public const int MsgTypeFieldNumber = 1;
  private bool hasMsgType;
  private int msgType_;
  public bool HasMsgType {
    get { return hasMsgType; }
  }
  public int MsgType {
    get { return msgType_; }
  }
  
  public const int MsgDataFieldNumber = 2;
  private bool hasMsgData;
  private pb::ByteString msgData_ = pb::ByteString.Empty;
  public bool HasMsgData {
    get { return hasMsgData; }
  }
  public pb::ByteString MsgData {
    get { return msgData_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgUserMessageFieldNames;
    if (hasMsgType) {
      output.WriteInt32(1, field_names[1], MsgType);
    }
    if (hasMsgData) {
      output.WriteBytes(2, field_names[0], MsgData);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasMsgType) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, MsgType);
      }
      if (hasMsgData) {
        size += pb::CodedOutputStream.ComputeBytesSize(2, MsgData);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_UserMessage ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_UserMessage ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_UserMessage ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_UserMessage ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_UserMessage ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_UserMessage ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_UserMessage ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_UserMessage ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_UserMessage ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_UserMessage ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_UserMessage MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_UserMessage prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_UserMessage, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_UserMessage cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_UserMessage result;
    
    private CSVCMsg_UserMessage PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_UserMessage original = result;
        result = new CSVCMsg_UserMessage();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_UserMessage MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_UserMessage.Descriptor; }
    }
    
    public override CSVCMsg_UserMessage DefaultInstanceForType {
      get { return global::CSVCMsg_UserMessage.DefaultInstance; }
    }
    
    public override CSVCMsg_UserMessage BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_UserMessage) {
        return MergeFrom((CSVCMsg_UserMessage) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_UserMessage other) {
      if (other == global::CSVCMsg_UserMessage.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasMsgType) {
        MsgType = other.MsgType;
      }
      if (other.HasMsgData) {
        MsgData = other.MsgData;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgUserMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgUserMessageFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasMsgType = input.ReadInt32(ref result.msgType_);
            break;
          }
          case 18: {
            result.hasMsgData = input.ReadBytes(ref result.msgData_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasMsgType {
      get { return result.hasMsgType; }
    }
    public int MsgType {
      get { return result.MsgType; }
      set { SetMsgType(value); }
    }
    public Builder SetMsgType(int value) {
      PrepareBuilder();
      result.hasMsgType = true;
      result.msgType_ = value;
      return this;
    }
    public Builder ClearMsgType() {
      PrepareBuilder();
      result.hasMsgType = false;
      result.msgType_ = 0;
      return this;
    }
    
    public bool HasMsgData {
      get { return result.hasMsgData; }
    }
    public pb::ByteString MsgData {
      get { return result.MsgData; }
      set { SetMsgData(value); }
    }
    public Builder SetMsgData(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasMsgData = true;
      result.msgData_ = value;
      return this;
    }
    public Builder ClearMsgData() {
      PrepareBuilder();
      result.hasMsgData = false;
      result.msgData_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CSVCMsg_UserMessage() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_PaintmapData : pb::GeneratedMessage<CSVCMsg_PaintmapData, CSVCMsg_PaintmapData.Builder> {
  private CSVCMsg_PaintmapData() { }
  private static readonly CSVCMsg_PaintmapData defaultInstance = new CSVCMsg_PaintmapData().MakeReadOnly();
  private static readonly string[] _cSVCMsgPaintmapDataFieldNames = new string[] { "paintmap" };
  private static readonly uint[] _cSVCMsgPaintmapDataFieldTags = new uint[] { 10 };
  public static CSVCMsg_PaintmapData DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_PaintmapData DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_PaintmapData ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_PaintmapData__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_PaintmapData, CSVCMsg_PaintmapData.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_PaintmapData__FieldAccessorTable; }
  }
  
  public const int PaintmapFieldNumber = 1;
  private bool hasPaintmap;
  private pb::ByteString paintmap_ = pb::ByteString.Empty;
  public bool HasPaintmap {
    get { return hasPaintmap; }
  }
  public pb::ByteString Paintmap {
    get { return paintmap_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgPaintmapDataFieldNames;
    if (hasPaintmap) {
      output.WriteBytes(1, field_names[0], Paintmap);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasPaintmap) {
        size += pb::CodedOutputStream.ComputeBytesSize(1, Paintmap);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_PaintmapData ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_PaintmapData ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_PaintmapData ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_PaintmapData ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_PaintmapData ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_PaintmapData ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_PaintmapData ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_PaintmapData ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_PaintmapData ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_PaintmapData ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_PaintmapData MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_PaintmapData prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_PaintmapData, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_PaintmapData cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_PaintmapData result;
    
    private CSVCMsg_PaintmapData PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_PaintmapData original = result;
        result = new CSVCMsg_PaintmapData();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_PaintmapData MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_PaintmapData.Descriptor; }
    }
    
    public override CSVCMsg_PaintmapData DefaultInstanceForType {
      get { return global::CSVCMsg_PaintmapData.DefaultInstance; }
    }
    
    public override CSVCMsg_PaintmapData BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_PaintmapData) {
        return MergeFrom((CSVCMsg_PaintmapData) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_PaintmapData other) {
      if (other == global::CSVCMsg_PaintmapData.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasPaintmap) {
        Paintmap = other.Paintmap;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgPaintmapDataFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgPaintmapDataFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasPaintmap = input.ReadBytes(ref result.paintmap_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasPaintmap {
      get { return result.hasPaintmap; }
    }
    public pb::ByteString Paintmap {
      get { return result.Paintmap; }
      set { SetPaintmap(value); }
    }
    public Builder SetPaintmap(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasPaintmap = true;
      result.paintmap_ = value;
      return this;
    }
    public Builder ClearPaintmap() {
      PrepareBuilder();
      result.hasPaintmap = false;
      result.paintmap_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CSVCMsg_PaintmapData() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_GameEvent : pb::GeneratedMessage<CSVCMsg_GameEvent, CSVCMsg_GameEvent.Builder> {
  private CSVCMsg_GameEvent() { }
  private static readonly CSVCMsg_GameEvent defaultInstance = new CSVCMsg_GameEvent().MakeReadOnly();
  private static readonly string[] _cSVCMsgGameEventFieldNames = new string[] { "event_name", "eventid", "keys" };
  private static readonly uint[] _cSVCMsgGameEventFieldTags = new uint[] { 10, 16, 26 };
  public static CSVCMsg_GameEvent DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_GameEvent DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_GameEvent ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_GameEvent__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_GameEvent, CSVCMsg_GameEvent.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_GameEvent__FieldAccessorTable; }
  }
  
  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class key_t : pb::GeneratedMessage<key_t, key_t.Builder> {
      private key_t() { }
      private static readonly key_t defaultInstance = new key_t().MakeReadOnly();
      private static readonly string[] _keyTFieldNames = new string[] { "type", "val_bool", "val_byte", "val_float", "val_long", "val_short", "val_string", "val_uint64", "val_wstring" };
      private static readonly uint[] _keyTFieldTags = new uint[] { 8, 56, 48, 29, 32, 40, 18, 64, 74 };
      public static key_t DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override key_t DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override key_t ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Netmessages.internal__static_CSVCMsg_GameEvent_key_t__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<key_t, key_t.Builder> InternalFieldAccessors {
        get { return global::Netmessages.internal__static_CSVCMsg_GameEvent_key_t__FieldAccessorTable; }
      }
      
      public const int TypeFieldNumber = 1;
      private bool hasType;
      private int type_;
      public bool HasType {
        get { return hasType; }
      }
      public int Type {
        get { return type_; }
      }
      
      public const int ValStringFieldNumber = 2;
      private bool hasValString;
      private string valString_ = "";
      public bool HasValString {
        get { return hasValString; }
      }
      public string ValString {
        get { return valString_; }
      }
      
      public const int ValFloatFieldNumber = 3;
      private bool hasValFloat;
      private float valFloat_;
      public bool HasValFloat {
        get { return hasValFloat; }
      }
      public float ValFloat {
        get { return valFloat_; }
      }
      
      public const int ValLongFieldNumber = 4;
      private bool hasValLong;
      private int valLong_;
      public bool HasValLong {
        get { return hasValLong; }
      }
      public int ValLong {
        get { return valLong_; }
      }
      
      public const int ValShortFieldNumber = 5;
      private bool hasValShort;
      private int valShort_;
      public bool HasValShort {
        get { return hasValShort; }
      }
      public int ValShort {
        get { return valShort_; }
      }
      
      public const int ValByteFieldNumber = 6;
      private bool hasValByte;
      private int valByte_;
      public bool HasValByte {
        get { return hasValByte; }
      }
      public int ValByte {
        get { return valByte_; }
      }
      
      public const int ValBoolFieldNumber = 7;
      private bool hasValBool;
      private bool valBool_;
      public bool HasValBool {
        get { return hasValBool; }
      }
      public bool ValBool {
        get { return valBool_; }
      }
      
      public const int ValUint64FieldNumber = 8;
      private bool hasValUint64;
      private ulong valUint64_;
      public bool HasValUint64 {
        get { return hasValUint64; }
      }
      [global::System.CLSCompliant(false)]
      public ulong ValUint64 {
        get { return valUint64_; }
      }
      
      public const int ValWstringFieldNumber = 9;
      private bool hasValWstring;
      private pb::ByteString valWstring_ = pb::ByteString.Empty;
      public bool HasValWstring {
        get { return hasValWstring; }
      }
      public pb::ByteString ValWstring {
        get { return valWstring_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _keyTFieldNames;
        if (hasType) {
          output.WriteInt32(1, field_names[0], Type);
        }
        if (hasValString) {
          output.WriteString(2, field_names[6], ValString);
        }
        if (hasValFloat) {
          output.WriteFloat(3, field_names[3], ValFloat);
        }
        if (hasValLong) {
          output.WriteInt32(4, field_names[4], ValLong);
        }
        if (hasValShort) {
          output.WriteInt32(5, field_names[5], ValShort);
        }
        if (hasValByte) {
          output.WriteInt32(6, field_names[2], ValByte);
        }
        if (hasValBool) {
          output.WriteBool(7, field_names[1], ValBool);
        }
        if (hasValUint64) {
          output.WriteUInt64(8, field_names[7], ValUint64);
        }
        if (hasValWstring) {
          output.WriteBytes(9, field_names[8], ValWstring);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasType) {
            size += pb::CodedOutputStream.ComputeInt32Size(1, Type);
          }
          if (hasValString) {
            size += pb::CodedOutputStream.ComputeStringSize(2, ValString);
          }
          if (hasValFloat) {
            size += pb::CodedOutputStream.ComputeFloatSize(3, ValFloat);
          }
          if (hasValLong) {
            size += pb::CodedOutputStream.ComputeInt32Size(4, ValLong);
          }
          if (hasValShort) {
            size += pb::CodedOutputStream.ComputeInt32Size(5, ValShort);
          }
          if (hasValByte) {
            size += pb::CodedOutputStream.ComputeInt32Size(6, ValByte);
          }
          if (hasValBool) {
            size += pb::CodedOutputStream.ComputeBoolSize(7, ValBool);
          }
          if (hasValUint64) {
            size += pb::CodedOutputStream.ComputeUInt64Size(8, ValUint64);
          }
          if (hasValWstring) {
            size += pb::CodedOutputStream.ComputeBytesSize(9, ValWstring);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static key_t ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static key_t ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static key_t ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static key_t ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static key_t ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static key_t ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static key_t ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static key_t ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static key_t ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static key_t ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private key_t MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(key_t prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<key_t, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(key_t cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private key_t result;
        
        private key_t PrepareBuilder() {
          if (resultIsReadOnly) {
            key_t original = result;
            result = new key_t();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override key_t MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::CSVCMsg_GameEvent.Types.key_t.Descriptor; }
        }
        
        public override key_t DefaultInstanceForType {
          get { return global::CSVCMsg_GameEvent.Types.key_t.DefaultInstance; }
        }
        
        public override key_t BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is key_t) {
            return MergeFrom((key_t) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(key_t other) {
          if (other == global::CSVCMsg_GameEvent.Types.key_t.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasType) {
            Type = other.Type;
          }
          if (other.HasValString) {
            ValString = other.ValString;
          }
          if (other.HasValFloat) {
            ValFloat = other.ValFloat;
          }
          if (other.HasValLong) {
            ValLong = other.ValLong;
          }
          if (other.HasValShort) {
            ValShort = other.ValShort;
          }
          if (other.HasValByte) {
            ValByte = other.ValByte;
          }
          if (other.HasValBool) {
            ValBool = other.ValBool;
          }
          if (other.HasValUint64) {
            ValUint64 = other.ValUint64;
          }
          if (other.HasValWstring) {
            ValWstring = other.ValWstring;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_keyTFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _keyTFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasType = input.ReadInt32(ref result.type_);
                break;
              }
              case 18: {
                result.hasValString = input.ReadString(ref result.valString_);
                break;
              }
              case 29: {
                result.hasValFloat = input.ReadFloat(ref result.valFloat_);
                break;
              }
              case 32: {
                result.hasValLong = input.ReadInt32(ref result.valLong_);
                break;
              }
              case 40: {
                result.hasValShort = input.ReadInt32(ref result.valShort_);
                break;
              }
              case 48: {
                result.hasValByte = input.ReadInt32(ref result.valByte_);
                break;
              }
              case 56: {
                result.hasValBool = input.ReadBool(ref result.valBool_);
                break;
              }
              case 64: {
                result.hasValUint64 = input.ReadUInt64(ref result.valUint64_);
                break;
              }
              case 74: {
                result.hasValWstring = input.ReadBytes(ref result.valWstring_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasType {
          get { return result.hasType; }
        }
        public int Type {
          get { return result.Type; }
          set { SetType(value); }
        }
        public Builder SetType(int value) {
          PrepareBuilder();
          result.hasType = true;
          result.type_ = value;
          return this;
        }
        public Builder ClearType() {
          PrepareBuilder();
          result.hasType = false;
          result.type_ = 0;
          return this;
        }
        
        public bool HasValString {
          get { return result.hasValString; }
        }
        public string ValString {
          get { return result.ValString; }
          set { SetValString(value); }
        }
        public Builder SetValString(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasValString = true;
          result.valString_ = value;
          return this;
        }
        public Builder ClearValString() {
          PrepareBuilder();
          result.hasValString = false;
          result.valString_ = "";
          return this;
        }
        
        public bool HasValFloat {
          get { return result.hasValFloat; }
        }
        public float ValFloat {
          get { return result.ValFloat; }
          set { SetValFloat(value); }
        }
        public Builder SetValFloat(float value) {
          PrepareBuilder();
          result.hasValFloat = true;
          result.valFloat_ = value;
          return this;
        }
        public Builder ClearValFloat() {
          PrepareBuilder();
          result.hasValFloat = false;
          result.valFloat_ = 0F;
          return this;
        }
        
        public bool HasValLong {
          get { return result.hasValLong; }
        }
        public int ValLong {
          get { return result.ValLong; }
          set { SetValLong(value); }
        }
        public Builder SetValLong(int value) {
          PrepareBuilder();
          result.hasValLong = true;
          result.valLong_ = value;
          return this;
        }
        public Builder ClearValLong() {
          PrepareBuilder();
          result.hasValLong = false;
          result.valLong_ = 0;
          return this;
        }
        
        public bool HasValShort {
          get { return result.hasValShort; }
        }
        public int ValShort {
          get { return result.ValShort; }
          set { SetValShort(value); }
        }
        public Builder SetValShort(int value) {
          PrepareBuilder();
          result.hasValShort = true;
          result.valShort_ = value;
          return this;
        }
        public Builder ClearValShort() {
          PrepareBuilder();
          result.hasValShort = false;
          result.valShort_ = 0;
          return this;
        }
        
        public bool HasValByte {
          get { return result.hasValByte; }
        }
        public int ValByte {
          get { return result.ValByte; }
          set { SetValByte(value); }
        }
        public Builder SetValByte(int value) {
          PrepareBuilder();
          result.hasValByte = true;
          result.valByte_ = value;
          return this;
        }
        public Builder ClearValByte() {
          PrepareBuilder();
          result.hasValByte = false;
          result.valByte_ = 0;
          return this;
        }
        
        public bool HasValBool {
          get { return result.hasValBool; }
        }
        public bool ValBool {
          get { return result.ValBool; }
          set { SetValBool(value); }
        }
        public Builder SetValBool(bool value) {
          PrepareBuilder();
          result.hasValBool = true;
          result.valBool_ = value;
          return this;
        }
        public Builder ClearValBool() {
          PrepareBuilder();
          result.hasValBool = false;
          result.valBool_ = false;
          return this;
        }
        
        public bool HasValUint64 {
          get { return result.hasValUint64; }
        }
        [global::System.CLSCompliant(false)]
        public ulong ValUint64 {
          get { return result.ValUint64; }
          set { SetValUint64(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetValUint64(ulong value) {
          PrepareBuilder();
          result.hasValUint64 = true;
          result.valUint64_ = value;
          return this;
        }
        public Builder ClearValUint64() {
          PrepareBuilder();
          result.hasValUint64 = false;
          result.valUint64_ = 0UL;
          return this;
        }
        
        public bool HasValWstring {
          get { return result.hasValWstring; }
        }
        public pb::ByteString ValWstring {
          get { return result.ValWstring; }
          set { SetValWstring(value); }
        }
        public Builder SetValWstring(pb::ByteString value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasValWstring = true;
          result.valWstring_ = value;
          return this;
        }
        public Builder ClearValWstring() {
          PrepareBuilder();
          result.hasValWstring = false;
          result.valWstring_ = pb::ByteString.Empty;
          return this;
        }
      }
      static key_t() {
        object.ReferenceEquals(global::Netmessages.Descriptor, null);
      }
    }
    
  }
  #endregion
  
  public const int EventNameFieldNumber = 1;
  private bool hasEventName;
  private string eventName_ = "";
  public bool HasEventName {
    get { return hasEventName; }
  }
  public string EventName {
    get { return eventName_; }
  }
  
  public const int EventidFieldNumber = 2;
  private bool hasEventid;
  private int eventid_;
  public bool HasEventid {
    get { return hasEventid; }
  }
  public int Eventid {
    get { return eventid_; }
  }
  
  public const int KeysFieldNumber = 3;
  private pbc::PopsicleList<global::CSVCMsg_GameEvent.Types.key_t> keys_ = new pbc::PopsicleList<global::CSVCMsg_GameEvent.Types.key_t>();
  public scg::IList<global::CSVCMsg_GameEvent.Types.key_t> KeysList {
    get { return keys_; }
  }
  public int KeysCount {
    get { return keys_.Count; }
  }
  public global::CSVCMsg_GameEvent.Types.key_t GetKeys(int index) {
    return keys_[index];
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgGameEventFieldNames;
    if (hasEventName) {
      output.WriteString(1, field_names[0], EventName);
    }
    if (hasEventid) {
      output.WriteInt32(2, field_names[1], Eventid);
    }
    if (keys_.Count > 0) {
      output.WriteMessageArray(3, field_names[2], keys_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasEventName) {
        size += pb::CodedOutputStream.ComputeStringSize(1, EventName);
      }
      if (hasEventid) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, Eventid);
      }
      foreach (global::CSVCMsg_GameEvent.Types.key_t element in KeysList) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_GameEvent ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_GameEvent ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_GameEvent ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_GameEvent ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_GameEvent ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_GameEvent ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_GameEvent ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_GameEvent ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_GameEvent ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_GameEvent ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_GameEvent MakeReadOnly() {
    keys_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_GameEvent prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_GameEvent, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_GameEvent cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_GameEvent result;
    
    private CSVCMsg_GameEvent PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_GameEvent original = result;
        result = new CSVCMsg_GameEvent();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_GameEvent MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_GameEvent.Descriptor; }
    }
    
    public override CSVCMsg_GameEvent DefaultInstanceForType {
      get { return global::CSVCMsg_GameEvent.DefaultInstance; }
    }
    
    public override CSVCMsg_GameEvent BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_GameEvent) {
        return MergeFrom((CSVCMsg_GameEvent) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_GameEvent other) {
      if (other == global::CSVCMsg_GameEvent.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasEventName) {
        EventName = other.EventName;
      }
      if (other.HasEventid) {
        Eventid = other.Eventid;
      }
      if (other.keys_.Count != 0) {
        result.keys_.Add(other.keys_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgGameEventFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgGameEventFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasEventName = input.ReadString(ref result.eventName_);
            break;
          }
          case 16: {
            result.hasEventid = input.ReadInt32(ref result.eventid_);
            break;
          }
          case 26: {
            input.ReadMessageArray(tag, field_name, result.keys_, global::CSVCMsg_GameEvent.Types.key_t.DefaultInstance, extensionRegistry);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasEventName {
      get { return result.hasEventName; }
    }
    public string EventName {
      get { return result.EventName; }
      set { SetEventName(value); }
    }
    public Builder SetEventName(string value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasEventName = true;
      result.eventName_ = value;
      return this;
    }
    public Builder ClearEventName() {
      PrepareBuilder();
      result.hasEventName = false;
      result.eventName_ = "";
      return this;
    }
    
    public bool HasEventid {
      get { return result.hasEventid; }
    }
    public int Eventid {
      get { return result.Eventid; }
      set { SetEventid(value); }
    }
    public Builder SetEventid(int value) {
      PrepareBuilder();
      result.hasEventid = true;
      result.eventid_ = value;
      return this;
    }
    public Builder ClearEventid() {
      PrepareBuilder();
      result.hasEventid = false;
      result.eventid_ = 0;
      return this;
    }
    
    public pbc::IPopsicleList<global::CSVCMsg_GameEvent.Types.key_t> KeysList {
      get { return PrepareBuilder().keys_; }
    }
    public int KeysCount {
      get { return result.KeysCount; }
    }
    public global::CSVCMsg_GameEvent.Types.key_t GetKeys(int index) {
      return result.GetKeys(index);
    }
    public Builder SetKeys(int index, global::CSVCMsg_GameEvent.Types.key_t value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.keys_[index] = value;
      return this;
    }
    public Builder SetKeys(int index, global::CSVCMsg_GameEvent.Types.key_t.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.keys_[index] = builderForValue.Build();
      return this;
    }
    public Builder AddKeys(global::CSVCMsg_GameEvent.Types.key_t value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.keys_.Add(value);
      return this;
    }
    public Builder AddKeys(global::CSVCMsg_GameEvent.Types.key_t.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.keys_.Add(builderForValue.Build());
      return this;
    }
    public Builder AddRangeKeys(scg::IEnumerable<global::CSVCMsg_GameEvent.Types.key_t> values) {
      PrepareBuilder();
      result.keys_.Add(values);
      return this;
    }
    public Builder ClearKeys() {
      PrepareBuilder();
      result.keys_.Clear();
      return this;
    }
  }
  static CSVCMsg_GameEvent() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_GameEventList : pb::GeneratedMessage<CSVCMsg_GameEventList, CSVCMsg_GameEventList.Builder> {
  private CSVCMsg_GameEventList() { }
  private static readonly CSVCMsg_GameEventList defaultInstance = new CSVCMsg_GameEventList().MakeReadOnly();
  private static readonly string[] _cSVCMsgGameEventListFieldNames = new string[] { "descriptors" };
  private static readonly uint[] _cSVCMsgGameEventListFieldTags = new uint[] { 10 };
  public static CSVCMsg_GameEventList DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_GameEventList DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_GameEventList ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_GameEventList__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_GameEventList, CSVCMsg_GameEventList.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_GameEventList__FieldAccessorTable; }
  }
  
  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class key_t : pb::GeneratedMessage<key_t, key_t.Builder> {
      private key_t() { }
      private static readonly key_t defaultInstance = new key_t().MakeReadOnly();
      private static readonly string[] _keyTFieldNames = new string[] { "name", "type" };
      private static readonly uint[] _keyTFieldTags = new uint[] { 18, 8 };
      public static key_t DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override key_t DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override key_t ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Netmessages.internal__static_CSVCMsg_GameEventList_key_t__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<key_t, key_t.Builder> InternalFieldAccessors {
        get { return global::Netmessages.internal__static_CSVCMsg_GameEventList_key_t__FieldAccessorTable; }
      }
      
      public const int TypeFieldNumber = 1;
      private bool hasType;
      private int type_;
      public bool HasType {
        get { return hasType; }
      }
      public int Type {
        get { return type_; }
      }
      
      public const int NameFieldNumber = 2;
      private bool hasName;
      private string name_ = "";
      public bool HasName {
        get { return hasName; }
      }
      public string Name {
        get { return name_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _keyTFieldNames;
        if (hasType) {
          output.WriteInt32(1, field_names[1], Type);
        }
        if (hasName) {
          output.WriteString(2, field_names[0], Name);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasType) {
            size += pb::CodedOutputStream.ComputeInt32Size(1, Type);
          }
          if (hasName) {
            size += pb::CodedOutputStream.ComputeStringSize(2, Name);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static key_t ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static key_t ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static key_t ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static key_t ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static key_t ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static key_t ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static key_t ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static key_t ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static key_t ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static key_t ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private key_t MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(key_t prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<key_t, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(key_t cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private key_t result;
        
        private key_t PrepareBuilder() {
          if (resultIsReadOnly) {
            key_t original = result;
            result = new key_t();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override key_t MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::CSVCMsg_GameEventList.Types.key_t.Descriptor; }
        }
        
        public override key_t DefaultInstanceForType {
          get { return global::CSVCMsg_GameEventList.Types.key_t.DefaultInstance; }
        }
        
        public override key_t BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is key_t) {
            return MergeFrom((key_t) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(key_t other) {
          if (other == global::CSVCMsg_GameEventList.Types.key_t.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasType) {
            Type = other.Type;
          }
          if (other.HasName) {
            Name = other.Name;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_keyTFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _keyTFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasType = input.ReadInt32(ref result.type_);
                break;
              }
              case 18: {
                result.hasName = input.ReadString(ref result.name_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasType {
          get { return result.hasType; }
        }
        public int Type {
          get { return result.Type; }
          set { SetType(value); }
        }
        public Builder SetType(int value) {
          PrepareBuilder();
          result.hasType = true;
          result.type_ = value;
          return this;
        }
        public Builder ClearType() {
          PrepareBuilder();
          result.hasType = false;
          result.type_ = 0;
          return this;
        }
        
        public bool HasName {
          get { return result.hasName; }
        }
        public string Name {
          get { return result.Name; }
          set { SetName(value); }
        }
        public Builder SetName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasName = true;
          result.name_ = value;
          return this;
        }
        public Builder ClearName() {
          PrepareBuilder();
          result.hasName = false;
          result.name_ = "";
          return this;
        }
      }
      static key_t() {
        object.ReferenceEquals(global::Netmessages.Descriptor, null);
      }
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class descriptor_t : pb::GeneratedMessage<descriptor_t, descriptor_t.Builder> {
      private descriptor_t() { }
      private static readonly descriptor_t defaultInstance = new descriptor_t().MakeReadOnly();
      private static readonly string[] _descriptorTFieldNames = new string[] { "eventid", "keys", "name" };
      private static readonly uint[] _descriptorTFieldTags = new uint[] { 8, 26, 18 };
      public static descriptor_t DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override descriptor_t DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override descriptor_t ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Netmessages.internal__static_CSVCMsg_GameEventList_descriptor_t__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<descriptor_t, descriptor_t.Builder> InternalFieldAccessors {
        get { return global::Netmessages.internal__static_CSVCMsg_GameEventList_descriptor_t__FieldAccessorTable; }
      }
      
      public const int EventidFieldNumber = 1;
      private bool hasEventid;
      private int eventid_;
      public bool HasEventid {
        get { return hasEventid; }
      }
      public int Eventid {
        get { return eventid_; }
      }
      
      public const int NameFieldNumber = 2;
      private bool hasName;
      private string name_ = "";
      public bool HasName {
        get { return hasName; }
      }
      public string Name {
        get { return name_; }
      }
      
      public const int KeysFieldNumber = 3;
      private pbc::PopsicleList<global::CSVCMsg_GameEventList.Types.key_t> keys_ = new pbc::PopsicleList<global::CSVCMsg_GameEventList.Types.key_t>();
      public scg::IList<global::CSVCMsg_GameEventList.Types.key_t> KeysList {
        get { return keys_; }
      }
      public int KeysCount {
        get { return keys_.Count; }
      }
      public global::CSVCMsg_GameEventList.Types.key_t GetKeys(int index) {
        return keys_[index];
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _descriptorTFieldNames;
        if (hasEventid) {
          output.WriteInt32(1, field_names[0], Eventid);
        }
        if (hasName) {
          output.WriteString(2, field_names[2], Name);
        }
        if (keys_.Count > 0) {
          output.WriteMessageArray(3, field_names[1], keys_);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasEventid) {
            size += pb::CodedOutputStream.ComputeInt32Size(1, Eventid);
          }
          if (hasName) {
            size += pb::CodedOutputStream.ComputeStringSize(2, Name);
          }
          foreach (global::CSVCMsg_GameEventList.Types.key_t element in KeysList) {
            size += pb::CodedOutputStream.ComputeMessageSize(3, element);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static descriptor_t ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static descriptor_t ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static descriptor_t ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static descriptor_t ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static descriptor_t ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static descriptor_t ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static descriptor_t ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static descriptor_t ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static descriptor_t ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static descriptor_t ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private descriptor_t MakeReadOnly() {
        keys_.MakeReadOnly();
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(descriptor_t prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<descriptor_t, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(descriptor_t cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private descriptor_t result;
        
        private descriptor_t PrepareBuilder() {
          if (resultIsReadOnly) {
            descriptor_t original = result;
            result = new descriptor_t();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override descriptor_t MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::CSVCMsg_GameEventList.Types.descriptor_t.Descriptor; }
        }
        
        public override descriptor_t DefaultInstanceForType {
          get { return global::CSVCMsg_GameEventList.Types.descriptor_t.DefaultInstance; }
        }
        
        public override descriptor_t BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is descriptor_t) {
            return MergeFrom((descriptor_t) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(descriptor_t other) {
          if (other == global::CSVCMsg_GameEventList.Types.descriptor_t.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasEventid) {
            Eventid = other.Eventid;
          }
          if (other.HasName) {
            Name = other.Name;
          }
          if (other.keys_.Count != 0) {
            result.keys_.Add(other.keys_);
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_descriptorTFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _descriptorTFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasEventid = input.ReadInt32(ref result.eventid_);
                break;
              }
              case 18: {
                result.hasName = input.ReadString(ref result.name_);
                break;
              }
              case 26: {
                input.ReadMessageArray(tag, field_name, result.keys_, global::CSVCMsg_GameEventList.Types.key_t.DefaultInstance, extensionRegistry);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasEventid {
          get { return result.hasEventid; }
        }
        public int Eventid {
          get { return result.Eventid; }
          set { SetEventid(value); }
        }
        public Builder SetEventid(int value) {
          PrepareBuilder();
          result.hasEventid = true;
          result.eventid_ = value;
          return this;
        }
        public Builder ClearEventid() {
          PrepareBuilder();
          result.hasEventid = false;
          result.eventid_ = 0;
          return this;
        }
        
        public bool HasName {
          get { return result.hasName; }
        }
        public string Name {
          get { return result.Name; }
          set { SetName(value); }
        }
        public Builder SetName(string value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.hasName = true;
          result.name_ = value;
          return this;
        }
        public Builder ClearName() {
          PrepareBuilder();
          result.hasName = false;
          result.name_ = "";
          return this;
        }
        
        public pbc::IPopsicleList<global::CSVCMsg_GameEventList.Types.key_t> KeysList {
          get { return PrepareBuilder().keys_; }
        }
        public int KeysCount {
          get { return result.KeysCount; }
        }
        public global::CSVCMsg_GameEventList.Types.key_t GetKeys(int index) {
          return result.GetKeys(index);
        }
        public Builder SetKeys(int index, global::CSVCMsg_GameEventList.Types.key_t value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.keys_[index] = value;
          return this;
        }
        public Builder SetKeys(int index, global::CSVCMsg_GameEventList.Types.key_t.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.keys_[index] = builderForValue.Build();
          return this;
        }
        public Builder AddKeys(global::CSVCMsg_GameEventList.Types.key_t value) {
          pb::ThrowHelper.ThrowIfNull(value, "value");
          PrepareBuilder();
          result.keys_.Add(value);
          return this;
        }
        public Builder AddKeys(global::CSVCMsg_GameEventList.Types.key_t.Builder builderForValue) {
          pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
          PrepareBuilder();
          result.keys_.Add(builderForValue.Build());
          return this;
        }
        public Builder AddRangeKeys(scg::IEnumerable<global::CSVCMsg_GameEventList.Types.key_t> values) {
          PrepareBuilder();
          result.keys_.Add(values);
          return this;
        }
        public Builder ClearKeys() {
          PrepareBuilder();
          result.keys_.Clear();
          return this;
        }
      }
      static descriptor_t() {
        object.ReferenceEquals(global::Netmessages.Descriptor, null);
      }
    }
    
  }
  #endregion
  
  public const int DescriptorsFieldNumber = 1;
  private pbc::PopsicleList<global::CSVCMsg_GameEventList.Types.descriptor_t> descriptors_ = new pbc::PopsicleList<global::CSVCMsg_GameEventList.Types.descriptor_t>();
  public scg::IList<global::CSVCMsg_GameEventList.Types.descriptor_t> DescriptorsList {
    get { return descriptors_; }
  }
  public int DescriptorsCount {
    get { return descriptors_.Count; }
  }
  public global::CSVCMsg_GameEventList.Types.descriptor_t GetDescriptors(int index) {
    return descriptors_[index];
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgGameEventListFieldNames;
    if (descriptors_.Count > 0) {
      output.WriteMessageArray(1, field_names[0], descriptors_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::CSVCMsg_GameEventList.Types.descriptor_t element in DescriptorsList) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_GameEventList ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_GameEventList ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_GameEventList ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_GameEventList ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_GameEventList ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_GameEventList ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_GameEventList ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_GameEventList ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_GameEventList ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_GameEventList ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_GameEventList MakeReadOnly() {
    descriptors_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_GameEventList prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_GameEventList, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_GameEventList cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_GameEventList result;
    
    private CSVCMsg_GameEventList PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_GameEventList original = result;
        result = new CSVCMsg_GameEventList();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_GameEventList MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_GameEventList.Descriptor; }
    }
    
    public override CSVCMsg_GameEventList DefaultInstanceForType {
      get { return global::CSVCMsg_GameEventList.DefaultInstance; }
    }
    
    public override CSVCMsg_GameEventList BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_GameEventList) {
        return MergeFrom((CSVCMsg_GameEventList) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_GameEventList other) {
      if (other == global::CSVCMsg_GameEventList.DefaultInstance) return this;
      PrepareBuilder();
      if (other.descriptors_.Count != 0) {
        result.descriptors_.Add(other.descriptors_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgGameEventListFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgGameEventListFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            input.ReadMessageArray(tag, field_name, result.descriptors_, global::CSVCMsg_GameEventList.Types.descriptor_t.DefaultInstance, extensionRegistry);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public pbc::IPopsicleList<global::CSVCMsg_GameEventList.Types.descriptor_t> DescriptorsList {
      get { return PrepareBuilder().descriptors_; }
    }
    public int DescriptorsCount {
      get { return result.DescriptorsCount; }
    }
    public global::CSVCMsg_GameEventList.Types.descriptor_t GetDescriptors(int index) {
      return result.GetDescriptors(index);
    }
    public Builder SetDescriptors(int index, global::CSVCMsg_GameEventList.Types.descriptor_t value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.descriptors_[index] = value;
      return this;
    }
    public Builder SetDescriptors(int index, global::CSVCMsg_GameEventList.Types.descriptor_t.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.descriptors_[index] = builderForValue.Build();
      return this;
    }
    public Builder AddDescriptors(global::CSVCMsg_GameEventList.Types.descriptor_t value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.descriptors_.Add(value);
      return this;
    }
    public Builder AddDescriptors(global::CSVCMsg_GameEventList.Types.descriptor_t.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.descriptors_.Add(builderForValue.Build());
      return this;
    }
    public Builder AddRangeDescriptors(scg::IEnumerable<global::CSVCMsg_GameEventList.Types.descriptor_t> values) {
      PrepareBuilder();
      result.descriptors_.Add(values);
      return this;
    }
    public Builder ClearDescriptors() {
      PrepareBuilder();
      result.descriptors_.Clear();
      return this;
    }
  }
  static CSVCMsg_GameEventList() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_TempEntities : pb::GeneratedMessage<CSVCMsg_TempEntities, CSVCMsg_TempEntities.Builder> {
  private CSVCMsg_TempEntities() { }
  private static readonly CSVCMsg_TempEntities defaultInstance = new CSVCMsg_TempEntities().MakeReadOnly();
  private static readonly string[] _cSVCMsgTempEntitiesFieldNames = new string[] { "entity_data", "num_entries", "reliable" };
  private static readonly uint[] _cSVCMsgTempEntitiesFieldTags = new uint[] { 26, 16, 8 };
  public static CSVCMsg_TempEntities DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_TempEntities DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_TempEntities ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_TempEntities__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_TempEntities, CSVCMsg_TempEntities.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_TempEntities__FieldAccessorTable; }
  }
  
  public const int ReliableFieldNumber = 1;
  private bool hasReliable;
  private bool reliable_;
  public bool HasReliable {
    get { return hasReliable; }
  }
  public bool Reliable {
    get { return reliable_; }
  }
  
  public const int NumEntriesFieldNumber = 2;
  private bool hasNumEntries;
  private int numEntries_;
  public bool HasNumEntries {
    get { return hasNumEntries; }
  }
  public int NumEntries {
    get { return numEntries_; }
  }
  
  public const int EntityDataFieldNumber = 3;
  private bool hasEntityData;
  private pb::ByteString entityData_ = pb::ByteString.Empty;
  public bool HasEntityData {
    get { return hasEntityData; }
  }
  public pb::ByteString EntityData {
    get { return entityData_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgTempEntitiesFieldNames;
    if (hasReliable) {
      output.WriteBool(1, field_names[2], Reliable);
    }
    if (hasNumEntries) {
      output.WriteInt32(2, field_names[1], NumEntries);
    }
    if (hasEntityData) {
      output.WriteBytes(3, field_names[0], EntityData);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasReliable) {
        size += pb::CodedOutputStream.ComputeBoolSize(1, Reliable);
      }
      if (hasNumEntries) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, NumEntries);
      }
      if (hasEntityData) {
        size += pb::CodedOutputStream.ComputeBytesSize(3, EntityData);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_TempEntities ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_TempEntities ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_TempEntities ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_TempEntities ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_TempEntities ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_TempEntities ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_TempEntities ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_TempEntities ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_TempEntities ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_TempEntities ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_TempEntities MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_TempEntities prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_TempEntities, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_TempEntities cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_TempEntities result;
    
    private CSVCMsg_TempEntities PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_TempEntities original = result;
        result = new CSVCMsg_TempEntities();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_TempEntities MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_TempEntities.Descriptor; }
    }
    
    public override CSVCMsg_TempEntities DefaultInstanceForType {
      get { return global::CSVCMsg_TempEntities.DefaultInstance; }
    }
    
    public override CSVCMsg_TempEntities BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_TempEntities) {
        return MergeFrom((CSVCMsg_TempEntities) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_TempEntities other) {
      if (other == global::CSVCMsg_TempEntities.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasReliable) {
        Reliable = other.Reliable;
      }
      if (other.HasNumEntries) {
        NumEntries = other.NumEntries;
      }
      if (other.HasEntityData) {
        EntityData = other.EntityData;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgTempEntitiesFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgTempEntitiesFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasReliable = input.ReadBool(ref result.reliable_);
            break;
          }
          case 16: {
            result.hasNumEntries = input.ReadInt32(ref result.numEntries_);
            break;
          }
          case 26: {
            result.hasEntityData = input.ReadBytes(ref result.entityData_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasReliable {
      get { return result.hasReliable; }
    }
    public bool Reliable {
      get { return result.Reliable; }
      set { SetReliable(value); }
    }
    public Builder SetReliable(bool value) {
      PrepareBuilder();
      result.hasReliable = true;
      result.reliable_ = value;
      return this;
    }
    public Builder ClearReliable() {
      PrepareBuilder();
      result.hasReliable = false;
      result.reliable_ = false;
      return this;
    }
    
    public bool HasNumEntries {
      get { return result.hasNumEntries; }
    }
    public int NumEntries {
      get { return result.NumEntries; }
      set { SetNumEntries(value); }
    }
    public Builder SetNumEntries(int value) {
      PrepareBuilder();
      result.hasNumEntries = true;
      result.numEntries_ = value;
      return this;
    }
    public Builder ClearNumEntries() {
      PrepareBuilder();
      result.hasNumEntries = false;
      result.numEntries_ = 0;
      return this;
    }
    
    public bool HasEntityData {
      get { return result.hasEntityData; }
    }
    public pb::ByteString EntityData {
      get { return result.EntityData; }
      set { SetEntityData(value); }
    }
    public Builder SetEntityData(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasEntityData = true;
      result.entityData_ = value;
      return this;
    }
    public Builder ClearEntityData() {
      PrepareBuilder();
      result.hasEntityData = false;
      result.entityData_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CSVCMsg_TempEntities() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_PacketEntities : pb::GeneratedMessage<CSVCMsg_PacketEntities, CSVCMsg_PacketEntities.Builder> {
  private CSVCMsg_PacketEntities() { }
  private static readonly CSVCMsg_PacketEntities defaultInstance = new CSVCMsg_PacketEntities().MakeReadOnly();
  private static readonly string[] _cSVCMsgPacketEntitiesFieldNames = new string[] { "baseline", "delta_from", "entity_data", "is_delta", "max_entries", "update_baseline", "updated_entries" };
  private static readonly uint[] _cSVCMsgPacketEntitiesFieldTags = new uint[] { 40, 48, 58, 24, 8, 32, 16 };
  public static CSVCMsg_PacketEntities DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_PacketEntities DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_PacketEntities ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_PacketEntities__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_PacketEntities, CSVCMsg_PacketEntities.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_PacketEntities__FieldAccessorTable; }
  }
  
  public const int MaxEntriesFieldNumber = 1;
  private bool hasMaxEntries;
  private int maxEntries_;
  public bool HasMaxEntries {
    get { return hasMaxEntries; }
  }
  public int MaxEntries {
    get { return maxEntries_; }
  }
  
  public const int UpdatedEntriesFieldNumber = 2;
  private bool hasUpdatedEntries;
  private int updatedEntries_;
  public bool HasUpdatedEntries {
    get { return hasUpdatedEntries; }
  }
  public int UpdatedEntries {
    get { return updatedEntries_; }
  }
  
  public const int IsDeltaFieldNumber = 3;
  private bool hasIsDelta;
  private bool isDelta_;
  public bool HasIsDelta {
    get { return hasIsDelta; }
  }
  public bool IsDelta {
    get { return isDelta_; }
  }
  
  public const int UpdateBaselineFieldNumber = 4;
  private bool hasUpdateBaseline;
  private bool updateBaseline_;
  public bool HasUpdateBaseline {
    get { return hasUpdateBaseline; }
  }
  public bool UpdateBaseline {
    get { return updateBaseline_; }
  }
  
  public const int BaselineFieldNumber = 5;
  private bool hasBaseline;
  private int baseline_;
  public bool HasBaseline {
    get { return hasBaseline; }
  }
  public int Baseline {
    get { return baseline_; }
  }
  
  public const int DeltaFromFieldNumber = 6;
  private bool hasDeltaFrom;
  private int deltaFrom_;
  public bool HasDeltaFrom {
    get { return hasDeltaFrom; }
  }
  public int DeltaFrom {
    get { return deltaFrom_; }
  }
  
  public const int EntityDataFieldNumber = 7;
  private bool hasEntityData;
  private pb::ByteString entityData_ = pb::ByteString.Empty;
  public bool HasEntityData {
    get { return hasEntityData; }
  }
  public pb::ByteString EntityData {
    get { return entityData_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgPacketEntitiesFieldNames;
    if (hasMaxEntries) {
      output.WriteInt32(1, field_names[4], MaxEntries);
    }
    if (hasUpdatedEntries) {
      output.WriteInt32(2, field_names[6], UpdatedEntries);
    }
    if (hasIsDelta) {
      output.WriteBool(3, field_names[3], IsDelta);
    }
    if (hasUpdateBaseline) {
      output.WriteBool(4, field_names[5], UpdateBaseline);
    }
    if (hasBaseline) {
      output.WriteInt32(5, field_names[0], Baseline);
    }
    if (hasDeltaFrom) {
      output.WriteInt32(6, field_names[1], DeltaFrom);
    }
    if (hasEntityData) {
      output.WriteBytes(7, field_names[2], EntityData);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasMaxEntries) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, MaxEntries);
      }
      if (hasUpdatedEntries) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, UpdatedEntries);
      }
      if (hasIsDelta) {
        size += pb::CodedOutputStream.ComputeBoolSize(3, IsDelta);
      }
      if (hasUpdateBaseline) {
        size += pb::CodedOutputStream.ComputeBoolSize(4, UpdateBaseline);
      }
      if (hasBaseline) {
        size += pb::CodedOutputStream.ComputeInt32Size(5, Baseline);
      }
      if (hasDeltaFrom) {
        size += pb::CodedOutputStream.ComputeInt32Size(6, DeltaFrom);
      }
      if (hasEntityData) {
        size += pb::CodedOutputStream.ComputeBytesSize(7, EntityData);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_PacketEntities ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_PacketEntities ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_PacketEntities ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_PacketEntities ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_PacketEntities ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_PacketEntities ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_PacketEntities ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_PacketEntities ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_PacketEntities ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_PacketEntities ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_PacketEntities MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_PacketEntities prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_PacketEntities, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_PacketEntities cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_PacketEntities result;
    
    private CSVCMsg_PacketEntities PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_PacketEntities original = result;
        result = new CSVCMsg_PacketEntities();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_PacketEntities MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_PacketEntities.Descriptor; }
    }
    
    public override CSVCMsg_PacketEntities DefaultInstanceForType {
      get { return global::CSVCMsg_PacketEntities.DefaultInstance; }
    }
    
    public override CSVCMsg_PacketEntities BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_PacketEntities) {
        return MergeFrom((CSVCMsg_PacketEntities) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_PacketEntities other) {
      if (other == global::CSVCMsg_PacketEntities.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasMaxEntries) {
        MaxEntries = other.MaxEntries;
      }
      if (other.HasUpdatedEntries) {
        UpdatedEntries = other.UpdatedEntries;
      }
      if (other.HasIsDelta) {
        IsDelta = other.IsDelta;
      }
      if (other.HasUpdateBaseline) {
        UpdateBaseline = other.UpdateBaseline;
      }
      if (other.HasBaseline) {
        Baseline = other.Baseline;
      }
      if (other.HasDeltaFrom) {
        DeltaFrom = other.DeltaFrom;
      }
      if (other.HasEntityData) {
        EntityData = other.EntityData;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgPacketEntitiesFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgPacketEntitiesFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasMaxEntries = input.ReadInt32(ref result.maxEntries_);
            break;
          }
          case 16: {
            result.hasUpdatedEntries = input.ReadInt32(ref result.updatedEntries_);
            break;
          }
          case 24: {
            result.hasIsDelta = input.ReadBool(ref result.isDelta_);
            break;
          }
          case 32: {
            result.hasUpdateBaseline = input.ReadBool(ref result.updateBaseline_);
            break;
          }
          case 40: {
            result.hasBaseline = input.ReadInt32(ref result.baseline_);
            break;
          }
          case 48: {
            result.hasDeltaFrom = input.ReadInt32(ref result.deltaFrom_);
            break;
          }
          case 58: {
            result.hasEntityData = input.ReadBytes(ref result.entityData_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasMaxEntries {
      get { return result.hasMaxEntries; }
    }
    public int MaxEntries {
      get { return result.MaxEntries; }
      set { SetMaxEntries(value); }
    }
    public Builder SetMaxEntries(int value) {
      PrepareBuilder();
      result.hasMaxEntries = true;
      result.maxEntries_ = value;
      return this;
    }
    public Builder ClearMaxEntries() {
      PrepareBuilder();
      result.hasMaxEntries = false;
      result.maxEntries_ = 0;
      return this;
    }
    
    public bool HasUpdatedEntries {
      get { return result.hasUpdatedEntries; }
    }
    public int UpdatedEntries {
      get { return result.UpdatedEntries; }
      set { SetUpdatedEntries(value); }
    }
    public Builder SetUpdatedEntries(int value) {
      PrepareBuilder();
      result.hasUpdatedEntries = true;
      result.updatedEntries_ = value;
      return this;
    }
    public Builder ClearUpdatedEntries() {
      PrepareBuilder();
      result.hasUpdatedEntries = false;
      result.updatedEntries_ = 0;
      return this;
    }
    
    public bool HasIsDelta {
      get { return result.hasIsDelta; }
    }
    public bool IsDelta {
      get { return result.IsDelta; }
      set { SetIsDelta(value); }
    }
    public Builder SetIsDelta(bool value) {
      PrepareBuilder();
      result.hasIsDelta = true;
      result.isDelta_ = value;
      return this;
    }
    public Builder ClearIsDelta() {
      PrepareBuilder();
      result.hasIsDelta = false;
      result.isDelta_ = false;
      return this;
    }
    
    public bool HasUpdateBaseline {
      get { return result.hasUpdateBaseline; }
    }
    public bool UpdateBaseline {
      get { return result.UpdateBaseline; }
      set { SetUpdateBaseline(value); }
    }
    public Builder SetUpdateBaseline(bool value) {
      PrepareBuilder();
      result.hasUpdateBaseline = true;
      result.updateBaseline_ = value;
      return this;
    }
    public Builder ClearUpdateBaseline() {
      PrepareBuilder();
      result.hasUpdateBaseline = false;
      result.updateBaseline_ = false;
      return this;
    }
    
    public bool HasBaseline {
      get { return result.hasBaseline; }
    }
    public int Baseline {
      get { return result.Baseline; }
      set { SetBaseline(value); }
    }
    public Builder SetBaseline(int value) {
      PrepareBuilder();
      result.hasBaseline = true;
      result.baseline_ = value;
      return this;
    }
    public Builder ClearBaseline() {
      PrepareBuilder();
      result.hasBaseline = false;
      result.baseline_ = 0;
      return this;
    }
    
    public bool HasDeltaFrom {
      get { return result.hasDeltaFrom; }
    }
    public int DeltaFrom {
      get { return result.DeltaFrom; }
      set { SetDeltaFrom(value); }
    }
    public Builder SetDeltaFrom(int value) {
      PrepareBuilder();
      result.hasDeltaFrom = true;
      result.deltaFrom_ = value;
      return this;
    }
    public Builder ClearDeltaFrom() {
      PrepareBuilder();
      result.hasDeltaFrom = false;
      result.deltaFrom_ = 0;
      return this;
    }
    
    public bool HasEntityData {
      get { return result.hasEntityData; }
    }
    public pb::ByteString EntityData {
      get { return result.EntityData; }
      set { SetEntityData(value); }
    }
    public Builder SetEntityData(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasEntityData = true;
      result.entityData_ = value;
      return this;
    }
    public Builder ClearEntityData() {
      PrepareBuilder();
      result.hasEntityData = false;
      result.entityData_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CSVCMsg_PacketEntities() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_Sounds : pb::GeneratedMessage<CSVCMsg_Sounds, CSVCMsg_Sounds.Builder> {
  private CSVCMsg_Sounds() { }
  private static readonly CSVCMsg_Sounds defaultInstance = new CSVCMsg_Sounds().MakeReadOnly();
  private static readonly string[] _cSVCMsgSoundsFieldNames = new string[] { "reliable_sound", "sounds" };
  private static readonly uint[] _cSVCMsgSoundsFieldTags = new uint[] { 8, 18 };
  public static CSVCMsg_Sounds DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_Sounds DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_Sounds ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_Sounds__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_Sounds, CSVCMsg_Sounds.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_Sounds__FieldAccessorTable; }
  }
  
  #region Nested types
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Types {
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class sounddata_t : pb::GeneratedMessage<sounddata_t, sounddata_t.Builder> {
      private sounddata_t() { }
      private static readonly sounddata_t defaultInstance = new sounddata_t().MakeReadOnly();
      private static readonly string[] _sounddataTFieldNames = new string[] { "channel", "delay_value", "entity_index", "flags", "is_ambient", "is_sentence", "origin_x", "origin_y", "origin_z", "pitch", "random_seed", "sequence_number", "sound_level", "sound_num", "sound_num_handle", "speaker_entity", "volume" };
      private static readonly uint[] _sounddataTFieldTags = new uint[] { 64, 45, 56, 80, 136, 128, 8, 16, 24, 72, 112, 48, 120, 88, 101, 104, 32 };
      public static sounddata_t DefaultInstance {
        get { return defaultInstance; }
      }
      
      public override sounddata_t DefaultInstanceForType {
        get { return DefaultInstance; }
      }
      
      protected override sounddata_t ThisMessage {
        get { return this; }
      }
      
      public static pbd::MessageDescriptor Descriptor {
        get { return global::Netmessages.internal__static_CSVCMsg_Sounds_sounddata_t__Descriptor; }
      }
      
      protected override pb::FieldAccess.FieldAccessorTable<sounddata_t, sounddata_t.Builder> InternalFieldAccessors {
        get { return global::Netmessages.internal__static_CSVCMsg_Sounds_sounddata_t__FieldAccessorTable; }
      }
      
      public const int OriginXFieldNumber = 1;
      private bool hasOriginX;
      private int originX_;
      public bool HasOriginX {
        get { return hasOriginX; }
      }
      public int OriginX {
        get { return originX_; }
      }
      
      public const int OriginYFieldNumber = 2;
      private bool hasOriginY;
      private int originY_;
      public bool HasOriginY {
        get { return hasOriginY; }
      }
      public int OriginY {
        get { return originY_; }
      }
      
      public const int OriginZFieldNumber = 3;
      private bool hasOriginZ;
      private int originZ_;
      public bool HasOriginZ {
        get { return hasOriginZ; }
      }
      public int OriginZ {
        get { return originZ_; }
      }
      
      public const int VolumeFieldNumber = 4;
      private bool hasVolume;
      private uint volume_;
      public bool HasVolume {
        get { return hasVolume; }
      }
      [global::System.CLSCompliant(false)]
      public uint Volume {
        get { return volume_; }
      }
      
      public const int DelayValueFieldNumber = 5;
      private bool hasDelayValue;
      private float delayValue_;
      public bool HasDelayValue {
        get { return hasDelayValue; }
      }
      public float DelayValue {
        get { return delayValue_; }
      }
      
      public const int SequenceNumberFieldNumber = 6;
      private bool hasSequenceNumber;
      private int sequenceNumber_;
      public bool HasSequenceNumber {
        get { return hasSequenceNumber; }
      }
      public int SequenceNumber {
        get { return sequenceNumber_; }
      }
      
      public const int EntityIndexFieldNumber = 7;
      private bool hasEntityIndex;
      private int entityIndex_;
      public bool HasEntityIndex {
        get { return hasEntityIndex; }
      }
      public int EntityIndex {
        get { return entityIndex_; }
      }
      
      public const int ChannelFieldNumber = 8;
      private bool hasChannel;
      private int channel_;
      public bool HasChannel {
        get { return hasChannel; }
      }
      public int Channel {
        get { return channel_; }
      }
      
      public const int PitchFieldNumber = 9;
      private bool hasPitch;
      private int pitch_;
      public bool HasPitch {
        get { return hasPitch; }
      }
      public int Pitch {
        get { return pitch_; }
      }
      
      public const int FlagsFieldNumber = 10;
      private bool hasFlags;
      private int flags_;
      public bool HasFlags {
        get { return hasFlags; }
      }
      public int Flags {
        get { return flags_; }
      }
      
      public const int SoundNumFieldNumber = 11;
      private bool hasSoundNum;
      private uint soundNum_;
      public bool HasSoundNum {
        get { return hasSoundNum; }
      }
      [global::System.CLSCompliant(false)]
      public uint SoundNum {
        get { return soundNum_; }
      }
      
      public const int SoundNumHandleFieldNumber = 12;
      private bool hasSoundNumHandle;
      private uint soundNumHandle_;
      public bool HasSoundNumHandle {
        get { return hasSoundNumHandle; }
      }
      [global::System.CLSCompliant(false)]
      public uint SoundNumHandle {
        get { return soundNumHandle_; }
      }
      
      public const int SpeakerEntityFieldNumber = 13;
      private bool hasSpeakerEntity;
      private int speakerEntity_;
      public bool HasSpeakerEntity {
        get { return hasSpeakerEntity; }
      }
      public int SpeakerEntity {
        get { return speakerEntity_; }
      }
      
      public const int RandomSeedFieldNumber = 14;
      private bool hasRandomSeed;
      private int randomSeed_;
      public bool HasRandomSeed {
        get { return hasRandomSeed; }
      }
      public int RandomSeed {
        get { return randomSeed_; }
      }
      
      public const int SoundLevelFieldNumber = 15;
      private bool hasSoundLevel;
      private int soundLevel_;
      public bool HasSoundLevel {
        get { return hasSoundLevel; }
      }
      public int SoundLevel {
        get { return soundLevel_; }
      }
      
      public const int IsSentenceFieldNumber = 16;
      private bool hasIsSentence;
      private bool isSentence_;
      public bool HasIsSentence {
        get { return hasIsSentence; }
      }
      public bool IsSentence {
        get { return isSentence_; }
      }
      
      public const int IsAmbientFieldNumber = 17;
      private bool hasIsAmbient;
      private bool isAmbient_;
      public bool HasIsAmbient {
        get { return hasIsAmbient; }
      }
      public bool IsAmbient {
        get { return isAmbient_; }
      }
      
      public override bool IsInitialized {
        get {
          return true;
        }
      }
      
      public override void WriteTo(pb::ICodedOutputStream output) {
        int size = SerializedSize;
        string[] field_names = _sounddataTFieldNames;
        if (hasOriginX) {
          output.WriteSInt32(1, field_names[6], OriginX);
        }
        if (hasOriginY) {
          output.WriteSInt32(2, field_names[7], OriginY);
        }
        if (hasOriginZ) {
          output.WriteSInt32(3, field_names[8], OriginZ);
        }
        if (hasVolume) {
          output.WriteUInt32(4, field_names[16], Volume);
        }
        if (hasDelayValue) {
          output.WriteFloat(5, field_names[1], DelayValue);
        }
        if (hasSequenceNumber) {
          output.WriteInt32(6, field_names[11], SequenceNumber);
        }
        if (hasEntityIndex) {
          output.WriteInt32(7, field_names[2], EntityIndex);
        }
        if (hasChannel) {
          output.WriteInt32(8, field_names[0], Channel);
        }
        if (hasPitch) {
          output.WriteInt32(9, field_names[9], Pitch);
        }
        if (hasFlags) {
          output.WriteInt32(10, field_names[3], Flags);
        }
        if (hasSoundNum) {
          output.WriteUInt32(11, field_names[13], SoundNum);
        }
        if (hasSoundNumHandle) {
          output.WriteFixed32(12, field_names[14], SoundNumHandle);
        }
        if (hasSpeakerEntity) {
          output.WriteInt32(13, field_names[15], SpeakerEntity);
        }
        if (hasRandomSeed) {
          output.WriteInt32(14, field_names[10], RandomSeed);
        }
        if (hasSoundLevel) {
          output.WriteInt32(15, field_names[12], SoundLevel);
        }
        if (hasIsSentence) {
          output.WriteBool(16, field_names[5], IsSentence);
        }
        if (hasIsAmbient) {
          output.WriteBool(17, field_names[4], IsAmbient);
        }
        UnknownFields.WriteTo(output);
      }
      
      private int memoizedSerializedSize = -1;
      public override int SerializedSize {
        get {
          int size = memoizedSerializedSize;
          if (size != -1) return size;
          
          size = 0;
          if (hasOriginX) {
            size += pb::CodedOutputStream.ComputeSInt32Size(1, OriginX);
          }
          if (hasOriginY) {
            size += pb::CodedOutputStream.ComputeSInt32Size(2, OriginY);
          }
          if (hasOriginZ) {
            size += pb::CodedOutputStream.ComputeSInt32Size(3, OriginZ);
          }
          if (hasVolume) {
            size += pb::CodedOutputStream.ComputeUInt32Size(4, Volume);
          }
          if (hasDelayValue) {
            size += pb::CodedOutputStream.ComputeFloatSize(5, DelayValue);
          }
          if (hasSequenceNumber) {
            size += pb::CodedOutputStream.ComputeInt32Size(6, SequenceNumber);
          }
          if (hasEntityIndex) {
            size += pb::CodedOutputStream.ComputeInt32Size(7, EntityIndex);
          }
          if (hasChannel) {
            size += pb::CodedOutputStream.ComputeInt32Size(8, Channel);
          }
          if (hasPitch) {
            size += pb::CodedOutputStream.ComputeInt32Size(9, Pitch);
          }
          if (hasFlags) {
            size += pb::CodedOutputStream.ComputeInt32Size(10, Flags);
          }
          if (hasSoundNum) {
            size += pb::CodedOutputStream.ComputeUInt32Size(11, SoundNum);
          }
          if (hasSoundNumHandle) {
            size += pb::CodedOutputStream.ComputeFixed32Size(12, SoundNumHandle);
          }
          if (hasSpeakerEntity) {
            size += pb::CodedOutputStream.ComputeInt32Size(13, SpeakerEntity);
          }
          if (hasRandomSeed) {
            size += pb::CodedOutputStream.ComputeInt32Size(14, RandomSeed);
          }
          if (hasSoundLevel) {
            size += pb::CodedOutputStream.ComputeInt32Size(15, SoundLevel);
          }
          if (hasIsSentence) {
            size += pb::CodedOutputStream.ComputeBoolSize(16, IsSentence);
          }
          if (hasIsAmbient) {
            size += pb::CodedOutputStream.ComputeBoolSize(17, IsAmbient);
          }
          size += UnknownFields.SerializedSize;
          memoizedSerializedSize = size;
          return size;
        }
      }
      
      public static sounddata_t ParseFrom(pb::ByteString data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static sounddata_t ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static sounddata_t ParseFrom(byte[] data) {
        return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
      }
      public static sounddata_t ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
      }
      public static sounddata_t ParseFrom(global::System.IO.Stream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static sounddata_t ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      public static sounddata_t ParseDelimitedFrom(global::System.IO.Stream input) {
        return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
      }
      public static sounddata_t ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
        return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
      }
      public static sounddata_t ParseFrom(pb::ICodedInputStream input) {
        return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
      }
      public static sounddata_t ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
      }
      private sounddata_t MakeReadOnly() {
        return this;
      }
      
      public static Builder CreateBuilder() { return new Builder(); }
      public override Builder ToBuilder() { return CreateBuilder(this); }
      public override Builder CreateBuilderForType() { return new Builder(); }
      public static Builder CreateBuilder(sounddata_t prototype) {
        return new Builder(prototype);
      }
      
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Builder : pb::GeneratedBuilder<sounddata_t, Builder> {
        protected override Builder ThisBuilder {
          get { return this; }
        }
        public Builder() {
          result = DefaultInstance;
          resultIsReadOnly = true;
        }
        internal Builder(sounddata_t cloneFrom) {
          result = cloneFrom;
          resultIsReadOnly = true;
        }
        
        private bool resultIsReadOnly;
        private sounddata_t result;
        
        private sounddata_t PrepareBuilder() {
          if (resultIsReadOnly) {
            sounddata_t original = result;
            result = new sounddata_t();
            resultIsReadOnly = false;
            MergeFrom(original);
          }
          return result;
        }
        
        public override bool IsInitialized {
          get { return result.IsInitialized; }
        }
        
        protected override sounddata_t MessageBeingBuilt {
          get { return PrepareBuilder(); }
        }
        
        public override Builder Clear() {
          result = DefaultInstance;
          resultIsReadOnly = true;
          return this;
        }
        
        public override Builder Clone() {
          if (resultIsReadOnly) {
            return new Builder(result);
          } else {
            return new Builder().MergeFrom(result);
          }
        }
        
        public override pbd::MessageDescriptor DescriptorForType {
          get { return global::CSVCMsg_Sounds.Types.sounddata_t.Descriptor; }
        }
        
        public override sounddata_t DefaultInstanceForType {
          get { return global::CSVCMsg_Sounds.Types.sounddata_t.DefaultInstance; }
        }
        
        public override sounddata_t BuildPartial() {
          if (resultIsReadOnly) {
            return result;
          }
          resultIsReadOnly = true;
          return result.MakeReadOnly();
        }
        
        public override Builder MergeFrom(pb::IMessage other) {
          if (other is sounddata_t) {
            return MergeFrom((sounddata_t) other);
          } else {
            base.MergeFrom(other);
            return this;
          }
        }
        
        public override Builder MergeFrom(sounddata_t other) {
          if (other == global::CSVCMsg_Sounds.Types.sounddata_t.DefaultInstance) return this;
          PrepareBuilder();
          if (other.HasOriginX) {
            OriginX = other.OriginX;
          }
          if (other.HasOriginY) {
            OriginY = other.OriginY;
          }
          if (other.HasOriginZ) {
            OriginZ = other.OriginZ;
          }
          if (other.HasVolume) {
            Volume = other.Volume;
          }
          if (other.HasDelayValue) {
            DelayValue = other.DelayValue;
          }
          if (other.HasSequenceNumber) {
            SequenceNumber = other.SequenceNumber;
          }
          if (other.HasEntityIndex) {
            EntityIndex = other.EntityIndex;
          }
          if (other.HasChannel) {
            Channel = other.Channel;
          }
          if (other.HasPitch) {
            Pitch = other.Pitch;
          }
          if (other.HasFlags) {
            Flags = other.Flags;
          }
          if (other.HasSoundNum) {
            SoundNum = other.SoundNum;
          }
          if (other.HasSoundNumHandle) {
            SoundNumHandle = other.SoundNumHandle;
          }
          if (other.HasSpeakerEntity) {
            SpeakerEntity = other.SpeakerEntity;
          }
          if (other.HasRandomSeed) {
            RandomSeed = other.RandomSeed;
          }
          if (other.HasSoundLevel) {
            SoundLevel = other.SoundLevel;
          }
          if (other.HasIsSentence) {
            IsSentence = other.IsSentence;
          }
          if (other.HasIsAmbient) {
            IsAmbient = other.IsAmbient;
          }
          this.MergeUnknownFields(other.UnknownFields);
          return this;
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input) {
          return MergeFrom(input, pb::ExtensionRegistry.Empty);
        }
        
        public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
          PrepareBuilder();
          pb::UnknownFieldSet.Builder unknownFields = null;
          uint tag;
          string field_name;
          while (input.ReadTag(out tag, out field_name)) {
            if(tag == 0 && field_name != null) {
              int field_ordinal = global::System.Array.BinarySearch(_sounddataTFieldNames, field_name, global::System.StringComparer.Ordinal);
              if(field_ordinal >= 0)
                tag = _sounddataTFieldTags[field_ordinal];
              else {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                continue;
              }
            }
            switch (tag) {
              case 0: {
                throw pb::InvalidProtocolBufferException.InvalidTag();
              }
              default: {
                if (pb::WireFormat.IsEndGroupTag(tag)) {
                  if (unknownFields != null) {
                    this.UnknownFields = unknownFields.Build();
                  }
                  return this;
                }
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
                break;
              }
              case 8: {
                result.hasOriginX = input.ReadSInt32(ref result.originX_);
                break;
              }
              case 16: {
                result.hasOriginY = input.ReadSInt32(ref result.originY_);
                break;
              }
              case 24: {
                result.hasOriginZ = input.ReadSInt32(ref result.originZ_);
                break;
              }
              case 32: {
                result.hasVolume = input.ReadUInt32(ref result.volume_);
                break;
              }
              case 45: {
                result.hasDelayValue = input.ReadFloat(ref result.delayValue_);
                break;
              }
              case 48: {
                result.hasSequenceNumber = input.ReadInt32(ref result.sequenceNumber_);
                break;
              }
              case 56: {
                result.hasEntityIndex = input.ReadInt32(ref result.entityIndex_);
                break;
              }
              case 64: {
                result.hasChannel = input.ReadInt32(ref result.channel_);
                break;
              }
              case 72: {
                result.hasPitch = input.ReadInt32(ref result.pitch_);
                break;
              }
              case 80: {
                result.hasFlags = input.ReadInt32(ref result.flags_);
                break;
              }
              case 88: {
                result.hasSoundNum = input.ReadUInt32(ref result.soundNum_);
                break;
              }
              case 101: {
                result.hasSoundNumHandle = input.ReadFixed32(ref result.soundNumHandle_);
                break;
              }
              case 104: {
                result.hasSpeakerEntity = input.ReadInt32(ref result.speakerEntity_);
                break;
              }
              case 112: {
                result.hasRandomSeed = input.ReadInt32(ref result.randomSeed_);
                break;
              }
              case 120: {
                result.hasSoundLevel = input.ReadInt32(ref result.soundLevel_);
                break;
              }
              case 128: {
                result.hasIsSentence = input.ReadBool(ref result.isSentence_);
                break;
              }
              case 136: {
                result.hasIsAmbient = input.ReadBool(ref result.isAmbient_);
                break;
              }
            }
          }
          
          if (unknownFields != null) {
            this.UnknownFields = unknownFields.Build();
          }
          return this;
        }
        
        
        public bool HasOriginX {
          get { return result.hasOriginX; }
        }
        public int OriginX {
          get { return result.OriginX; }
          set { SetOriginX(value); }
        }
        public Builder SetOriginX(int value) {
          PrepareBuilder();
          result.hasOriginX = true;
          result.originX_ = value;
          return this;
        }
        public Builder ClearOriginX() {
          PrepareBuilder();
          result.hasOriginX = false;
          result.originX_ = 0;
          return this;
        }
        
        public bool HasOriginY {
          get { return result.hasOriginY; }
        }
        public int OriginY {
          get { return result.OriginY; }
          set { SetOriginY(value); }
        }
        public Builder SetOriginY(int value) {
          PrepareBuilder();
          result.hasOriginY = true;
          result.originY_ = value;
          return this;
        }
        public Builder ClearOriginY() {
          PrepareBuilder();
          result.hasOriginY = false;
          result.originY_ = 0;
          return this;
        }
        
        public bool HasOriginZ {
          get { return result.hasOriginZ; }
        }
        public int OriginZ {
          get { return result.OriginZ; }
          set { SetOriginZ(value); }
        }
        public Builder SetOriginZ(int value) {
          PrepareBuilder();
          result.hasOriginZ = true;
          result.originZ_ = value;
          return this;
        }
        public Builder ClearOriginZ() {
          PrepareBuilder();
          result.hasOriginZ = false;
          result.originZ_ = 0;
          return this;
        }
        
        public bool HasVolume {
          get { return result.hasVolume; }
        }
        [global::System.CLSCompliant(false)]
        public uint Volume {
          get { return result.Volume; }
          set { SetVolume(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetVolume(uint value) {
          PrepareBuilder();
          result.hasVolume = true;
          result.volume_ = value;
          return this;
        }
        public Builder ClearVolume() {
          PrepareBuilder();
          result.hasVolume = false;
          result.volume_ = 0;
          return this;
        }
        
        public bool HasDelayValue {
          get { return result.hasDelayValue; }
        }
        public float DelayValue {
          get { return result.DelayValue; }
          set { SetDelayValue(value); }
        }
        public Builder SetDelayValue(float value) {
          PrepareBuilder();
          result.hasDelayValue = true;
          result.delayValue_ = value;
          return this;
        }
        public Builder ClearDelayValue() {
          PrepareBuilder();
          result.hasDelayValue = false;
          result.delayValue_ = 0F;
          return this;
        }
        
        public bool HasSequenceNumber {
          get { return result.hasSequenceNumber; }
        }
        public int SequenceNumber {
          get { return result.SequenceNumber; }
          set { SetSequenceNumber(value); }
        }
        public Builder SetSequenceNumber(int value) {
          PrepareBuilder();
          result.hasSequenceNumber = true;
          result.sequenceNumber_ = value;
          return this;
        }
        public Builder ClearSequenceNumber() {
          PrepareBuilder();
          result.hasSequenceNumber = false;
          result.sequenceNumber_ = 0;
          return this;
        }
        
        public bool HasEntityIndex {
          get { return result.hasEntityIndex; }
        }
        public int EntityIndex {
          get { return result.EntityIndex; }
          set { SetEntityIndex(value); }
        }
        public Builder SetEntityIndex(int value) {
          PrepareBuilder();
          result.hasEntityIndex = true;
          result.entityIndex_ = value;
          return this;
        }
        public Builder ClearEntityIndex() {
          PrepareBuilder();
          result.hasEntityIndex = false;
          result.entityIndex_ = 0;
          return this;
        }
        
        public bool HasChannel {
          get { return result.hasChannel; }
        }
        public int Channel {
          get { return result.Channel; }
          set { SetChannel(value); }
        }
        public Builder SetChannel(int value) {
          PrepareBuilder();
          result.hasChannel = true;
          result.channel_ = value;
          return this;
        }
        public Builder ClearChannel() {
          PrepareBuilder();
          result.hasChannel = false;
          result.channel_ = 0;
          return this;
        }
        
        public bool HasPitch {
          get { return result.hasPitch; }
        }
        public int Pitch {
          get { return result.Pitch; }
          set { SetPitch(value); }
        }
        public Builder SetPitch(int value) {
          PrepareBuilder();
          result.hasPitch = true;
          result.pitch_ = value;
          return this;
        }
        public Builder ClearPitch() {
          PrepareBuilder();
          result.hasPitch = false;
          result.pitch_ = 0;
          return this;
        }
        
        public bool HasFlags {
          get { return result.hasFlags; }
        }
        public int Flags {
          get { return result.Flags; }
          set { SetFlags(value); }
        }
        public Builder SetFlags(int value) {
          PrepareBuilder();
          result.hasFlags = true;
          result.flags_ = value;
          return this;
        }
        public Builder ClearFlags() {
          PrepareBuilder();
          result.hasFlags = false;
          result.flags_ = 0;
          return this;
        }
        
        public bool HasSoundNum {
          get { return result.hasSoundNum; }
        }
        [global::System.CLSCompliant(false)]
        public uint SoundNum {
          get { return result.SoundNum; }
          set { SetSoundNum(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetSoundNum(uint value) {
          PrepareBuilder();
          result.hasSoundNum = true;
          result.soundNum_ = value;
          return this;
        }
        public Builder ClearSoundNum() {
          PrepareBuilder();
          result.hasSoundNum = false;
          result.soundNum_ = 0;
          return this;
        }
        
        public bool HasSoundNumHandle {
          get { return result.hasSoundNumHandle; }
        }
        [global::System.CLSCompliant(false)]
        public uint SoundNumHandle {
          get { return result.SoundNumHandle; }
          set { SetSoundNumHandle(value); }
        }
        [global::System.CLSCompliant(false)]
        public Builder SetSoundNumHandle(uint value) {
          PrepareBuilder();
          result.hasSoundNumHandle = true;
          result.soundNumHandle_ = value;
          return this;
        }
        public Builder ClearSoundNumHandle() {
          PrepareBuilder();
          result.hasSoundNumHandle = false;
          result.soundNumHandle_ = 0;
          return this;
        }
        
        public bool HasSpeakerEntity {
          get { return result.hasSpeakerEntity; }
        }
        public int SpeakerEntity {
          get { return result.SpeakerEntity; }
          set { SetSpeakerEntity(value); }
        }
        public Builder SetSpeakerEntity(int value) {
          PrepareBuilder();
          result.hasSpeakerEntity = true;
          result.speakerEntity_ = value;
          return this;
        }
        public Builder ClearSpeakerEntity() {
          PrepareBuilder();
          result.hasSpeakerEntity = false;
          result.speakerEntity_ = 0;
          return this;
        }
        
        public bool HasRandomSeed {
          get { return result.hasRandomSeed; }
        }
        public int RandomSeed {
          get { return result.RandomSeed; }
          set { SetRandomSeed(value); }
        }
        public Builder SetRandomSeed(int value) {
          PrepareBuilder();
          result.hasRandomSeed = true;
          result.randomSeed_ = value;
          return this;
        }
        public Builder ClearRandomSeed() {
          PrepareBuilder();
          result.hasRandomSeed = false;
          result.randomSeed_ = 0;
          return this;
        }
        
        public bool HasSoundLevel {
          get { return result.hasSoundLevel; }
        }
        public int SoundLevel {
          get { return result.SoundLevel; }
          set { SetSoundLevel(value); }
        }
        public Builder SetSoundLevel(int value) {
          PrepareBuilder();
          result.hasSoundLevel = true;
          result.soundLevel_ = value;
          return this;
        }
        public Builder ClearSoundLevel() {
          PrepareBuilder();
          result.hasSoundLevel = false;
          result.soundLevel_ = 0;
          return this;
        }
        
        public bool HasIsSentence {
          get { return result.hasIsSentence; }
        }
        public bool IsSentence {
          get { return result.IsSentence; }
          set { SetIsSentence(value); }
        }
        public Builder SetIsSentence(bool value) {
          PrepareBuilder();
          result.hasIsSentence = true;
          result.isSentence_ = value;
          return this;
        }
        public Builder ClearIsSentence() {
          PrepareBuilder();
          result.hasIsSentence = false;
          result.isSentence_ = false;
          return this;
        }
        
        public bool HasIsAmbient {
          get { return result.hasIsAmbient; }
        }
        public bool IsAmbient {
          get { return result.IsAmbient; }
          set { SetIsAmbient(value); }
        }
        public Builder SetIsAmbient(bool value) {
          PrepareBuilder();
          result.hasIsAmbient = true;
          result.isAmbient_ = value;
          return this;
        }
        public Builder ClearIsAmbient() {
          PrepareBuilder();
          result.hasIsAmbient = false;
          result.isAmbient_ = false;
          return this;
        }
      }
      static sounddata_t() {
        object.ReferenceEquals(global::Netmessages.Descriptor, null);
      }
    }
    
  }
  #endregion
  
  public const int ReliableSoundFieldNumber = 1;
  private bool hasReliableSound;
  private bool reliableSound_;
  public bool HasReliableSound {
    get { return hasReliableSound; }
  }
  public bool ReliableSound {
    get { return reliableSound_; }
  }
  
  public const int SoundsFieldNumber = 2;
  private pbc::PopsicleList<global::CSVCMsg_Sounds.Types.sounddata_t> sounds_ = new pbc::PopsicleList<global::CSVCMsg_Sounds.Types.sounddata_t>();
  public scg::IList<global::CSVCMsg_Sounds.Types.sounddata_t> SoundsList {
    get { return sounds_; }
  }
  public int SoundsCount {
    get { return sounds_.Count; }
  }
  public global::CSVCMsg_Sounds.Types.sounddata_t GetSounds(int index) {
    return sounds_[index];
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgSoundsFieldNames;
    if (hasReliableSound) {
      output.WriteBool(1, field_names[0], ReliableSound);
    }
    if (sounds_.Count > 0) {
      output.WriteMessageArray(2, field_names[1], sounds_);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasReliableSound) {
        size += pb::CodedOutputStream.ComputeBoolSize(1, ReliableSound);
      }
      foreach (global::CSVCMsg_Sounds.Types.sounddata_t element in SoundsList) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_Sounds ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_Sounds ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Sounds ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_Sounds ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Sounds ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_Sounds ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_Sounds ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_Sounds ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_Sounds ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_Sounds ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_Sounds MakeReadOnly() {
    sounds_.MakeReadOnly();
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_Sounds prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_Sounds, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_Sounds cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_Sounds result;
    
    private CSVCMsg_Sounds PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_Sounds original = result;
        result = new CSVCMsg_Sounds();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_Sounds MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_Sounds.Descriptor; }
    }
    
    public override CSVCMsg_Sounds DefaultInstanceForType {
      get { return global::CSVCMsg_Sounds.DefaultInstance; }
    }
    
    public override CSVCMsg_Sounds BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_Sounds) {
        return MergeFrom((CSVCMsg_Sounds) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_Sounds other) {
      if (other == global::CSVCMsg_Sounds.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasReliableSound) {
        ReliableSound = other.ReliableSound;
      }
      if (other.sounds_.Count != 0) {
        result.sounds_.Add(other.sounds_);
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgSoundsFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgSoundsFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasReliableSound = input.ReadBool(ref result.reliableSound_);
            break;
          }
          case 18: {
            input.ReadMessageArray(tag, field_name, result.sounds_, global::CSVCMsg_Sounds.Types.sounddata_t.DefaultInstance, extensionRegistry);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasReliableSound {
      get { return result.hasReliableSound; }
    }
    public bool ReliableSound {
      get { return result.ReliableSound; }
      set { SetReliableSound(value); }
    }
    public Builder SetReliableSound(bool value) {
      PrepareBuilder();
      result.hasReliableSound = true;
      result.reliableSound_ = value;
      return this;
    }
    public Builder ClearReliableSound() {
      PrepareBuilder();
      result.hasReliableSound = false;
      result.reliableSound_ = false;
      return this;
    }
    
    public pbc::IPopsicleList<global::CSVCMsg_Sounds.Types.sounddata_t> SoundsList {
      get { return PrepareBuilder().sounds_; }
    }
    public int SoundsCount {
      get { return result.SoundsCount; }
    }
    public global::CSVCMsg_Sounds.Types.sounddata_t GetSounds(int index) {
      return result.GetSounds(index);
    }
    public Builder SetSounds(int index, global::CSVCMsg_Sounds.Types.sounddata_t value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.sounds_[index] = value;
      return this;
    }
    public Builder SetSounds(int index, global::CSVCMsg_Sounds.Types.sounddata_t.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.sounds_[index] = builderForValue.Build();
      return this;
    }
    public Builder AddSounds(global::CSVCMsg_Sounds.Types.sounddata_t value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.sounds_.Add(value);
      return this;
    }
    public Builder AddSounds(global::CSVCMsg_Sounds.Types.sounddata_t.Builder builderForValue) {
      pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
      PrepareBuilder();
      result.sounds_.Add(builderForValue.Build());
      return this;
    }
    public Builder AddRangeSounds(scg::IEnumerable<global::CSVCMsg_Sounds.Types.sounddata_t> values) {
      PrepareBuilder();
      result.sounds_.Add(values);
      return this;
    }
    public Builder ClearSounds() {
      PrepareBuilder();
      result.sounds_.Clear();
      return this;
    }
  }
  static CSVCMsg_Sounds() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_EntityMsg : pb::GeneratedMessage<CSVCMsg_EntityMsg, CSVCMsg_EntityMsg.Builder> {
  private CSVCMsg_EntityMsg() { }
  private static readonly CSVCMsg_EntityMsg defaultInstance = new CSVCMsg_EntityMsg().MakeReadOnly();
  private static readonly string[] _cSVCMsgEntityMsgFieldNames = new string[] { "class_id", "ent_data", "ent_index" };
  private static readonly uint[] _cSVCMsgEntityMsgFieldTags = new uint[] { 16, 26, 8 };
  public static CSVCMsg_EntityMsg DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_EntityMsg DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_EntityMsg ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_EntityMsg__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_EntityMsg, CSVCMsg_EntityMsg.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_EntityMsg__FieldAccessorTable; }
  }
  
  public const int EntIndexFieldNumber = 1;
  private bool hasEntIndex;
  private int entIndex_;
  public bool HasEntIndex {
    get { return hasEntIndex; }
  }
  public int EntIndex {
    get { return entIndex_; }
  }
  
  public const int ClassIdFieldNumber = 2;
  private bool hasClassId;
  private int classId_;
  public bool HasClassId {
    get { return hasClassId; }
  }
  public int ClassId {
    get { return classId_; }
  }
  
  public const int EntDataFieldNumber = 3;
  private bool hasEntData;
  private pb::ByteString entData_ = pb::ByteString.Empty;
  public bool HasEntData {
    get { return hasEntData; }
  }
  public pb::ByteString EntData {
    get { return entData_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgEntityMsgFieldNames;
    if (hasEntIndex) {
      output.WriteInt32(1, field_names[2], EntIndex);
    }
    if (hasClassId) {
      output.WriteInt32(2, field_names[0], ClassId);
    }
    if (hasEntData) {
      output.WriteBytes(3, field_names[1], EntData);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasEntIndex) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, EntIndex);
      }
      if (hasClassId) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, ClassId);
      }
      if (hasEntData) {
        size += pb::CodedOutputStream.ComputeBytesSize(3, EntData);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_EntityMsg ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_EntityMsg ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_EntityMsg ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_EntityMsg ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_EntityMsg ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_EntityMsg ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_EntityMsg ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_EntityMsg ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_EntityMsg ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_EntityMsg ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_EntityMsg MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_EntityMsg prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_EntityMsg, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_EntityMsg cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_EntityMsg result;
    
    private CSVCMsg_EntityMsg PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_EntityMsg original = result;
        result = new CSVCMsg_EntityMsg();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_EntityMsg MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_EntityMsg.Descriptor; }
    }
    
    public override CSVCMsg_EntityMsg DefaultInstanceForType {
      get { return global::CSVCMsg_EntityMsg.DefaultInstance; }
    }
    
    public override CSVCMsg_EntityMsg BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_EntityMsg) {
        return MergeFrom((CSVCMsg_EntityMsg) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_EntityMsg other) {
      if (other == global::CSVCMsg_EntityMsg.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasEntIndex) {
        EntIndex = other.EntIndex;
      }
      if (other.HasClassId) {
        ClassId = other.ClassId;
      }
      if (other.HasEntData) {
        EntData = other.EntData;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgEntityMsgFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgEntityMsgFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 8: {
            result.hasEntIndex = input.ReadInt32(ref result.entIndex_);
            break;
          }
          case 16: {
            result.hasClassId = input.ReadInt32(ref result.classId_);
            break;
          }
          case 26: {
            result.hasEntData = input.ReadBytes(ref result.entData_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasEntIndex {
      get { return result.hasEntIndex; }
    }
    public int EntIndex {
      get { return result.EntIndex; }
      set { SetEntIndex(value); }
    }
    public Builder SetEntIndex(int value) {
      PrepareBuilder();
      result.hasEntIndex = true;
      result.entIndex_ = value;
      return this;
    }
    public Builder ClearEntIndex() {
      PrepareBuilder();
      result.hasEntIndex = false;
      result.entIndex_ = 0;
      return this;
    }
    
    public bool HasClassId {
      get { return result.hasClassId; }
    }
    public int ClassId {
      get { return result.ClassId; }
      set { SetClassId(value); }
    }
    public Builder SetClassId(int value) {
      PrepareBuilder();
      result.hasClassId = true;
      result.classId_ = value;
      return this;
    }
    public Builder ClearClassId() {
      PrepareBuilder();
      result.hasClassId = false;
      result.classId_ = 0;
      return this;
    }
    
    public bool HasEntData {
      get { return result.hasEntData; }
    }
    public pb::ByteString EntData {
      get { return result.EntData; }
      set { SetEntData(value); }
    }
    public Builder SetEntData(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasEntData = true;
      result.entData_ = value;
      return this;
    }
    public Builder ClearEntData() {
      PrepareBuilder();
      result.hasEntData = false;
      result.entData_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CSVCMsg_EntityMsg() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_CmdKeyValues : pb::GeneratedMessage<CSVCMsg_CmdKeyValues, CSVCMsg_CmdKeyValues.Builder> {
  private CSVCMsg_CmdKeyValues() { }
  private static readonly CSVCMsg_CmdKeyValues defaultInstance = new CSVCMsg_CmdKeyValues().MakeReadOnly();
  private static readonly string[] _cSVCMsgCmdKeyValuesFieldNames = new string[] { "keyvalues" };
  private static readonly uint[] _cSVCMsgCmdKeyValuesFieldTags = new uint[] { 10 };
  public static CSVCMsg_CmdKeyValues DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_CmdKeyValues DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_CmdKeyValues ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_CmdKeyValues__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_CmdKeyValues, CSVCMsg_CmdKeyValues.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_CmdKeyValues__FieldAccessorTable; }
  }
  
  public const int KeyvaluesFieldNumber = 1;
  private bool hasKeyvalues;
  private pb::ByteString keyvalues_ = pb::ByteString.Empty;
  public bool HasKeyvalues {
    get { return hasKeyvalues; }
  }
  public pb::ByteString Keyvalues {
    get { return keyvalues_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgCmdKeyValuesFieldNames;
    if (hasKeyvalues) {
      output.WriteBytes(1, field_names[0], Keyvalues);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasKeyvalues) {
        size += pb::CodedOutputStream.ComputeBytesSize(1, Keyvalues);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_CmdKeyValues ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_CmdKeyValues ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_CmdKeyValues ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_CmdKeyValues ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_CmdKeyValues ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_CmdKeyValues ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_CmdKeyValues ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_CmdKeyValues ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_CmdKeyValues ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_CmdKeyValues ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_CmdKeyValues MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_CmdKeyValues prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_CmdKeyValues, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_CmdKeyValues cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_CmdKeyValues result;
    
    private CSVCMsg_CmdKeyValues PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_CmdKeyValues original = result;
        result = new CSVCMsg_CmdKeyValues();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_CmdKeyValues MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_CmdKeyValues.Descriptor; }
    }
    
    public override CSVCMsg_CmdKeyValues DefaultInstanceForType {
      get { return global::CSVCMsg_CmdKeyValues.DefaultInstance; }
    }
    
    public override CSVCMsg_CmdKeyValues BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_CmdKeyValues) {
        return MergeFrom((CSVCMsg_CmdKeyValues) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_CmdKeyValues other) {
      if (other == global::CSVCMsg_CmdKeyValues.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasKeyvalues) {
        Keyvalues = other.Keyvalues;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgCmdKeyValuesFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgCmdKeyValuesFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasKeyvalues = input.ReadBytes(ref result.keyvalues_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasKeyvalues {
      get { return result.hasKeyvalues; }
    }
    public pb::ByteString Keyvalues {
      get { return result.Keyvalues; }
      set { SetKeyvalues(value); }
    }
    public Builder SetKeyvalues(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasKeyvalues = true;
      result.keyvalues_ = value;
      return this;
    }
    public Builder ClearKeyvalues() {
      PrepareBuilder();
      result.hasKeyvalues = false;
      result.keyvalues_ = pb::ByteString.Empty;
      return this;
    }
  }
  static CSVCMsg_CmdKeyValues() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

[global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
public sealed partial class CSVCMsg_EncryptedData : pb::GeneratedMessage<CSVCMsg_EncryptedData, CSVCMsg_EncryptedData.Builder> {
  private CSVCMsg_EncryptedData() { }
  private static readonly CSVCMsg_EncryptedData defaultInstance = new CSVCMsg_EncryptedData().MakeReadOnly();
  private static readonly string[] _cSVCMsgEncryptedDataFieldNames = new string[] { "encrypted", "key_type" };
  private static readonly uint[] _cSVCMsgEncryptedDataFieldTags = new uint[] { 10, 16 };
  public static CSVCMsg_EncryptedData DefaultInstance {
    get { return defaultInstance; }
  }
  
  public override CSVCMsg_EncryptedData DefaultInstanceForType {
    get { return DefaultInstance; }
  }
  
  protected override CSVCMsg_EncryptedData ThisMessage {
    get { return this; }
  }
  
  public static pbd::MessageDescriptor Descriptor {
    get { return global::Netmessages.internal__static_CSVCMsg_EncryptedData__Descriptor; }
  }
  
  protected override pb::FieldAccess.FieldAccessorTable<CSVCMsg_EncryptedData, CSVCMsg_EncryptedData.Builder> InternalFieldAccessors {
    get { return global::Netmessages.internal__static_CSVCMsg_EncryptedData__FieldAccessorTable; }
  }
  
  public const int EncryptedFieldNumber = 1;
  private bool hasEncrypted;
  private pb::ByteString encrypted_ = pb::ByteString.Empty;
  public bool HasEncrypted {
    get { return hasEncrypted; }
  }
  public pb::ByteString Encrypted {
    get { return encrypted_; }
  }
  
  public const int KeyTypeFieldNumber = 2;
  private bool hasKeyType;
  private int keyType_;
  public bool HasKeyType {
    get { return hasKeyType; }
  }
  public int KeyType {
    get { return keyType_; }
  }
  
  public override bool IsInitialized {
    get {
      return true;
    }
  }
  
  public override void WriteTo(pb::ICodedOutputStream output) {
    int size = SerializedSize;
    string[] field_names = _cSVCMsgEncryptedDataFieldNames;
    if (hasEncrypted) {
      output.WriteBytes(1, field_names[0], Encrypted);
    }
    if (hasKeyType) {
      output.WriteInt32(2, field_names[1], KeyType);
    }
    UnknownFields.WriteTo(output);
  }
  
  private int memoizedSerializedSize = -1;
  public override int SerializedSize {
    get {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasEncrypted) {
        size += pb::CodedOutputStream.ComputeBytesSize(1, Encrypted);
      }
      if (hasKeyType) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, KeyType);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
  }
  
  public static CSVCMsg_EncryptedData ParseFrom(pb::ByteString data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_EncryptedData ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_EncryptedData ParseFrom(byte[] data) {
    return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
  }
  public static CSVCMsg_EncryptedData ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_EncryptedData ParseFrom(global::System.IO.Stream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_EncryptedData ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  public static CSVCMsg_EncryptedData ParseDelimitedFrom(global::System.IO.Stream input) {
    return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
  }
  public static CSVCMsg_EncryptedData ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
    return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
  }
  public static CSVCMsg_EncryptedData ParseFrom(pb::ICodedInputStream input) {
    return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
  }
  public static CSVCMsg_EncryptedData ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
    return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
  }
  private CSVCMsg_EncryptedData MakeReadOnly() {
    return this;
  }
  
  public static Builder CreateBuilder() { return new Builder(); }
  public override Builder ToBuilder() { return CreateBuilder(this); }
  public override Builder CreateBuilderForType() { return new Builder(); }
  public static Builder CreateBuilder(CSVCMsg_EncryptedData prototype) {
    return new Builder(prototype);
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Builder : pb::GeneratedBuilder<CSVCMsg_EncryptedData, Builder> {
    protected override Builder ThisBuilder {
      get { return this; }
    }
    public Builder() {
      result = DefaultInstance;
      resultIsReadOnly = true;
    }
    internal Builder(CSVCMsg_EncryptedData cloneFrom) {
      result = cloneFrom;
      resultIsReadOnly = true;
    }
    
    private bool resultIsReadOnly;
    private CSVCMsg_EncryptedData result;
    
    private CSVCMsg_EncryptedData PrepareBuilder() {
      if (resultIsReadOnly) {
        CSVCMsg_EncryptedData original = result;
        result = new CSVCMsg_EncryptedData();
        resultIsReadOnly = false;
        MergeFrom(original);
      }
      return result;
    }
    
    public override bool IsInitialized {
      get { return result.IsInitialized; }
    }
    
    protected override CSVCMsg_EncryptedData MessageBeingBuilt {
      get { return PrepareBuilder(); }
    }
    
    public override Builder Clear() {
      result = DefaultInstance;
      resultIsReadOnly = true;
      return this;
    }
    
    public override Builder Clone() {
      if (resultIsReadOnly) {
        return new Builder(result);
      } else {
        return new Builder().MergeFrom(result);
      }
    }
    
    public override pbd::MessageDescriptor DescriptorForType {
      get { return global::CSVCMsg_EncryptedData.Descriptor; }
    }
    
    public override CSVCMsg_EncryptedData DefaultInstanceForType {
      get { return global::CSVCMsg_EncryptedData.DefaultInstance; }
    }
    
    public override CSVCMsg_EncryptedData BuildPartial() {
      if (resultIsReadOnly) {
        return result;
      }
      resultIsReadOnly = true;
      return result.MakeReadOnly();
    }
    
    public override Builder MergeFrom(pb::IMessage other) {
      if (other is CSVCMsg_EncryptedData) {
        return MergeFrom((CSVCMsg_EncryptedData) other);
      } else {
        base.MergeFrom(other);
        return this;
      }
    }
    
    public override Builder MergeFrom(CSVCMsg_EncryptedData other) {
      if (other == global::CSVCMsg_EncryptedData.DefaultInstance) return this;
      PrepareBuilder();
      if (other.HasEncrypted) {
        Encrypted = other.Encrypted;
      }
      if (other.HasKeyType) {
        KeyType = other.KeyType;
      }
      this.MergeUnknownFields(other.UnknownFields);
      return this;
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input) {
      return MergeFrom(input, pb::ExtensionRegistry.Empty);
    }
    
    public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      PrepareBuilder();
      pb::UnknownFieldSet.Builder unknownFields = null;
      uint tag;
      string field_name;
      while (input.ReadTag(out tag, out field_name)) {
        if(tag == 0 && field_name != null) {
          int field_ordinal = global::System.Array.BinarySearch(_cSVCMsgEncryptedDataFieldNames, field_name, global::System.StringComparer.Ordinal);
          if(field_ordinal >= 0)
            tag = _cSVCMsgEncryptedDataFieldTags[field_ordinal];
          else {
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            continue;
          }
        }
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              if (unknownFields != null) {
                this.UnknownFields = unknownFields.Build();
              }
              return this;
            }
            if (unknownFields == null) {
              unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
            }
            ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
            break;
          }
          case 10: {
            result.hasEncrypted = input.ReadBytes(ref result.encrypted_);
            break;
          }
          case 16: {
            result.hasKeyType = input.ReadInt32(ref result.keyType_);
            break;
          }
        }
      }
      
      if (unknownFields != null) {
        this.UnknownFields = unknownFields.Build();
      }
      return this;
    }
    
    
    public bool HasEncrypted {
      get { return result.hasEncrypted; }
    }
    public pb::ByteString Encrypted {
      get { return result.Encrypted; }
      set { SetEncrypted(value); }
    }
    public Builder SetEncrypted(pb::ByteString value) {
      pb::ThrowHelper.ThrowIfNull(value, "value");
      PrepareBuilder();
      result.hasEncrypted = true;
      result.encrypted_ = value;
      return this;
    }
    public Builder ClearEncrypted() {
      PrepareBuilder();
      result.hasEncrypted = false;
      result.encrypted_ = pb::ByteString.Empty;
      return this;
    }
    
    public bool HasKeyType {
      get { return result.hasKeyType; }
    }
    public int KeyType {
      get { return result.KeyType; }
      set { SetKeyType(value); }
    }
    public Builder SetKeyType(int value) {
      PrepareBuilder();
      result.hasKeyType = true;
      result.keyType_ = value;
      return this;
    }
    public Builder ClearKeyType() {
      PrepareBuilder();
      result.hasKeyType = false;
      result.keyType_ = 0;
      return this;
    }
  }
  static CSVCMsg_EncryptedData() {
    object.ReferenceEquals(global::Netmessages.Descriptor, null);
  }
}

#endregion


#endregion Designer generated code
